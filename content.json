[{"title":"MonogoDB 数据库基本使用和常用命令","date":"2019-08-10T06:27:44.000Z","path":"20190810/mongodb-note/","text":"本文简单介绍了 mongodb 数据库的基本概念以及基础用法 一、简介 MongoDB 是为快速开发互联网 Web 应用而设计的数据库系统 MongoDB 的设计目标是极简、灵活、作为 Web 应用栈的一部分 MongoDB 的数据模型是面向文档的，所谓文档，是一种类似于 JSON 的结构，简单理解 MongoDB 这个数据库中存的是各种各样的 JSON(BJSON) 二、相关概念及名词 数据库：是一个仓库，在仓库中可以存放集合 集合 类似于数组，在集合中可以存放文档 存储的文档可以是多种多样的，没有格式要求 文档 数据库中的最小单位，对数据库进行存储和操作的内容都是文档 类似于 JS 中的对象，在 MongoDB 中每一条数据就是一个文档 多个文档组成集合，多个集合组成数据库 三、常用指令基本指令 show dbs/ databases: 显示当前的所有数据库 use 数据库名：进入到指定的数据库中 eg: use my_test db ：表示的是当前所处的数据库 show collections：显示数据库中所有的集合 增删改查（CRUD）指令新增（INSERT） 向数据库中插入文档：db.&lt;collection&gt;.insert(doc) 向集合中插入一个或多个文档 向集合中插入文档时，如果没有给文档指定 id 属性，则数据库会自动为文档添加 _id，该属性用来作为文档的唯一标识 _id 我们可以自己指定，如果我们指定了，则数据库就不会再自动生成了。如果自己指定 _id，也必须确保它的唯一性 例子：向 test 数据库中的 students 集合中插入一个新的学生对象：{name: &quot;小明&quot;, age: 18, addr: &quot;male&quot;}12use test;db.students.insert(&#123;name: \"小明\", age: 18, addr: \"三味书屋\"&#125;); db.&lt;collection&gt;.insertOne(doc)：向数据库中插入一条数据 db.&lt;collection&gt;.insertMany(doc)：向数据库中插入多条数据 示例：123456789101112131415use test;// 插入一条db.students.insert(&#123;name: \"小明\", age: 18, addr: \"三味书屋\", salary: 3000&#125;);// 插入多条db.students.insert([&#123;name: \"小红\", age: 16, addr: \"东方明珠\", salary: 5000&#125;, &#123;name: \"小白\", age: 19, addr: \"王府井\", salary: 6000&#125;]);// 等同于下面的方式// 插入一条db.students.insertOne(&#123;name: \"小明\", age: 18, addr: \"三味书屋\", salary: 3000&#125;);// 插入多条db.students.insertMany([&#123;name: \"小红\", age: 16, addr: \"东方明珠\", salary: 5000&#125;, &#123;name: \"小白\", age: 19, addr: \"王府井\", salary: 6000&#125;]); 查询（QUERY） db.&lt;collection&gt;.find() 默认查询当前集合中的所有文档 find({})：也是查询当前集合中所有的文档 返回的是一个数组 接收一个对象作为参数，必须满足对象中所有的属性 .count(): 查询出所有结果的数量 .length(): 查询出所有结果的数量 db.&lt;collection&gt;.findOne()：查询集合中符合条件的第一个文档 返回的是一个对象 123456789101112131415use test// 查询集合中所有的文档（实际项目中不会这么操作）db.students.find();// 查询集合中符合条件的所有文档db.students.find(&#123; age: 19 &#125;);// 查询符合条件的第一个文档db.students.findOne(&#123; age: 19 &#125;);// 查询符合条件的文档数目db.students.find(&#123; age: 19 &#125;).count();// 或db.students.find(&#123; age: 19 &#125;).length(); 投影 db.&lt;collection&gt;.find(filter, options) filter：查询条件对象 options: 投影条件对象，需要展示的属性设置为 1，不需要展示的属性设置为 0 .limit(num)：显示多少个文档 .skip(num)：跳过多少个文档 .sort({ key1: 1, key2: -1 })：按照 key1 正序排列，排完之后再按照 key2 倒序排列 示例12345678910111213141516171819use test;// 查询 students 集合中所有对象，只展示 age 字段db.students.find(&#123;&#125;, &#123; age: 1 &#125;);// 查询 students 集合中所有对象，不展示 age 字段db.students.find(&#123;&#125;, &#123; age: 0 &#125;);// 查询 students 集合，只展示符合条件的前 2 条数据db.students.find(&#123;&#125;).limit(2);// 查询 students 集合中所有对象，跳过前 2 条数据db.students.find(&#123;&#125;).skip(2);// 查询 students 集合中所有对象，按 age 正序排列db.students.find(&#123;&#125;).sort(&#123; age: 1 &#125;);// 查询 students 集合中所有对象，按 age 倒序排列db.students.find(&#123;&#125;).sort(&#123; age: -1 &#125;); 常用查询器 $gt：大于 $gte：大于等于 $eq：等于 $lt：小于 $lte：小于等于 $or：或者 之前查询不使用任何查询器时，条件的判断是包含，不是相等 示例：1234567891011121314151617181920// 工资大于 3000db.students.find(&#123;salary: &#123; $gt: 3000 &#125;&#125;);// 工资大于等于 3000db.students.find(&#123;salary: &#123; $gte: 3000 &#125;&#125;);// 工资等于 3000db.students.find(&#123;salary: &#123; $eq: 3000 &#125;&#125;);// 工资小于 6000 db.students.find(&#123;salary: &#123; $lt: 6000 &#125;&#125;);// 工资小于等于 6000db.students.find(&#123;salary: &#123; $lte: 6000 &#125;&#125;);// 工资大于 3000 且小于 6000 db.students.find(&#123;salary: &#123; $gt: 3000, $lt: 6000 &#125;&#125;);// 工资是 3000 或者 名字是 小白db.students.find(&#123;$or: [ &#123;salary: 3000&#125;, &#123;name: \"小白\"&#125; ]&#125;); 更新（UPDATE） db.&lt;collection&gt;.update(查询条件, 新对象, [options]) options: 配置对象 upsert: &lt;boolean&gt; multi: &lt;boolean&gt; 是否跟新多条，默认是 false writeConcern: &lt;document&gt; collation: &lt;document&gt; update() 默认情况下会使用新对象来替换旧的对象 如果需要修改指定的属性，而不是替换，则需要使用 “修改操作符” 来完成 $set: 修改操作符，修改属性值。 $unset: 修改操作符，删除属性值。 db..update({ name: “zgd” }, {$set: { age: 21 }}) 默认情况下只会更新匹配到的第一个文档对象 db..updateOne(查询条件, 新对象)：修改第一个符合条件的文档 db..updateMany(查询条件, 新对象)：同时修改多个符合条件的文档 db..replaceOne(查询条件, 新对象)：替换一个文档 示例12345678910111213141516171819use test// 修改一条数据db.students.update(&#123;name: '小明'&#125;, &#123;$set: &#123; age: 19 &#125;&#125;);// 等同于 updateOnedb.students.updateOne(&#123;name: '小明'&#125;, &#123;$set: &#123; age: 19 &#125;&#125;);// 修改多条数据db.students.update(&#123;age: 19&#125;, &#123;$set: &#123; addr: '水月洞天' &#125;&#125;, &#123; multi: true &#125;);// 等同于 updateManydb.students.updateMany(&#123;age: 19&#125;, &#123;$set: &#123; addr: '水月洞天' &#125;&#125;);// 数据替换db.students.update(&#123;age: 16&#125;, &#123; name: '小花', age: 14, addr: '迪士尼乐园' &#125;);// 等同于 replaceOnedb.students.replaceOne(&#123;age: 16&#125;, &#123; name: '小花', age: 14, addr: '迪士尼乐园' &#125;); 常用修改器： $set: 设置属性 $unset：删除属性 $push：向数组中添加一条数据 $addToSet：向数组中添加一条数据，与 $push 的区别：若数据已存在，则不再添加 $inc（只能用于 Number 类型的值）：用来增加已有属性的值，若属性不存在，则创建该属性 12345678910111213// 修改 addr 属性db.students.updateMany(&#123;age: 19&#125;, &#123; $set: &#123; addr: '花果山' &#125; &#125;);// 为小花删除 age 属性db.students.updateOne(&#123;name: '小花' &#125;, &#123; $unset: &#123; age: '' &#125; &#125;);// 先为小明添加一个 hobby 属性，其中有一个 cities 属性是一个数组db.students.updateOne(&#123;name: '小明' &#125;, &#123; $set: &#123; hobby: &#123; cities: '北京', '上海' &#125; &#125; &#125;);// 为小明的 cities 属性 添加一个 '杭州'，可以通过 . 操作符为下级属性赋值，但是必须用 \"\" 引号包裹起来db.students.updateOne(&#123;name: '小明' &#125;, &#123; $push: &#123; \"hobby.cities\": '杭州' &#125; &#125;);// 将 addr 为 '花果山' 的文档，年龄都加 2 岁db.students.updateMany(&#123;addr: '花果山'&#125;, &#123; $inc: &#123; age: 2 &#125; &#125;); 删除（DELETE） db.&lt;collection&gt;.remove(查询条件, [justone]]) 默认删除所有符合条件的文档 不传查询对象会报错 如果传递一个空对象 {} 作为参数，则会删除集合中的所有数据。使用这种方式清空集合性能较差 justone：&lt;boolean&gt; 默认是 false，设置为 true，则只会删除匹配到的第一个文档 db.&lt;collection&gt;.deleteOne(查询条件)：删除匹配到的第一个文档 db.&lt;collection&gt;.deleteMany(查询条件)：删除匹配到的所有文档 示例1234567891011121314// 删除一条db.students.remove(&#123; name: '小花' &#125;, true);// 等同于 deleteOnedb.students.deleteOne(&#123; name: '小花' &#125;);// 删除多条db.students.remove(&#123; age: '19' &#125;);// 等同于db.students.deleteMany(&#123; age: '19' &#125;);// 删除所有数据（不建议使用这种方式清空数据，速度较慢）db.students.deleteMany(&#123;&#125;); 删除集合和数据库 db.&lt;collection&gt;.drop(): 删除集合 db.dropDatabase()：删除数据库 示例12345// 删除 students 集合（建议使用这种方式清空数据，速度较快）db.students.drop();// 删除当前数据库db.dropDatabase(); 四、参考链接 MongoDB 官方教程","tags":[{"name":"数据库","slug":"数据库","permalink":"https://beichensky.github.io/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://beichensky.github.io/tags/MongoDB/"}]},{"title":"浅显易懂的原型与原型链知识总结","date":"2019-08-08T15:58:55.000Z","path":"20190808/prototype-chain/","text":"本文总结了原型以及原型链的一些概念和规律，并且提供了代码示例进行说明。有助于更深一步的理解原型与原型链 一、原型简介 每个函数对象都有一个 prototype 属性，默认指向一个空的 Object 实例对象（即称为原型对象） 原型对象中有一个 constructor 属性，它指向当前的函数对象 代码示例：123456789101112131415function Test() &#123;&#125;Test.prototype.say = () =&gt; &#123; console.log('Say Hello');&#125;const t1 = new Test();const t2 = new Test();Test.prototype.say = () =&gt; &#123; console.log('Say Hello');&#125;console.log(\"原型对象：\", Object.keys(Test.prototype)); // []，说明函数的原型对象是一个空对象console.log(Test.prototype.constructor === test); // true，说明 原型对象的 constructor 属性，它指向当前的函数对象 显式原型和隐式原型 每个函数都有一个 prototype 属性，即显式原型 每个实例对象都有一个 __proto__ 属性，即隐式原型 实例对象的隐式原型的值等于对应函数的显式原型的值 1234567function Test() &#123;&#125;const t1 = new Test();console.log(Test.prototype); // 一个空对象，包含 __proto__ 和 constructor 属性(指向 Test)console.log(t1.__proto__); // 一个空对象，包含 __proto__ 和 constructor 属性(指向 Test)console.log(Test.prototype === t1.__proto__); // true 显式原型和隐式原型的实现机制 函数的 prototype 属性：在定义函数时自动添加的，默认值是一个空的 Object 对象 对象的 __proto__ 属性：创建对象时自动添加的，默认值为构造函数的 prototype 属性值 开发人员一般都是通过操作函数的 prototype 属性来修改原型 原型补充 函数的显式原型指向的对象默认是空 Object 对象（但是 Object 除外，Object 的原型不是空对象，且没有 __proto__ 属性） 所以 Object 的原型对象是原型链的尽头，Object 的原型对象的原型就是 null 了123456789function Test() &#123;&#125;const o = &#123;&#125;;const t = new Test();console.log(o.__proto__); // 包含多个方法的 Object 对象，没有 __proto__ 属性console.log(t.__proto__); // 空对象console.log(o.__proto__.__proto__); // null 每个函数对象既有一个隐式原型，也有一个显式原型 所有函数都是 Function 的实例（包括 Function 自身） 每个函数的隐式原型都是同一个实例对象 唯一的一个隐式原型等于显式原型的函数对象就是 Function 这个函数对象1234567891011function Test() &#123;&#125;function Hello() &#123;&#125;console.log(Test.prototype); // 空对象console.log(Test.__proto__); // ƒ () &#123; [native code] &#125;console.log(Hello.prototype === Test.prototype) // falseconsole.log(Hello.__proto__ === Test.__proto__); // trueconsole.log(Hello.__proto__ === Function.__proto__); // trueconsole.log(Function.prototype === Function.__proto__); // true 二、原型链（别名：隐式原型链）概念 访问一个对象的属性时 先在自身属性中查找，找到返回 如果没有，再沿着 __proto__ 这条链向上查找，找到返回 如果最终没有找到，返回 undefined 作用：查询对象属性 对象读写 读取对象的属性时，会自动到对象的原型链中查找 123456789101112function Person() &#123;&#125;Person.prototype.speak = () =&gt; &#123; console.log('Speak Chinese!');&#125;const p1 = new Person();const p2 = new Person();// 每个实例对象都拥有函数原型中的属性/方法p1.speak(); // Speak Chinese!p2.speak(); // Speak Chinese! 设置对象的属性时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置值 123456789101112131415function Person() &#123;&#125;Person.prototype.name = '小明';const p1 = new Person();const p2 = new Person();// 读取属性时，会从当前对象以及原型链中进行查找console.log(p1.name); // 小明// 设置属性时，直接修改当前对象上的属性，当前对象上没有，则直接添加，不会修改原型链上的属性p2.name = '小红';console.log(p1.name); // 小明console.log(p2.name); // 小红 方法一般定义在原型上，属性一般通过构造函数定义在对象本身上 扩展：instanceOf 操作符原理 a instanceOf C: 如果 C 的显式原型在 a 的隐式原型链上，返回 true，否则返回 false123456789101112function A() &#123;&#125;;function B() &#123;&#125;;function C() &#123;&#125;// 将 C 的原型赋值给 B 的原型，将 B 的原型赋值给 A 的原型，这两行代码位置不能颠倒B.prototype = C.prototype;A.prototype = B.prototype;const a = new A();console.log(a instanceof C); 三、实例讲解1、实例一12345678910111213141516function A() &#123;&#125;A.prototype.n = 1;// 对象的原型在对象初始化时赋值为函数的显示原型，因此 b 的隐式原型为 &#123; n: 1 &#125;;const b = new A();A.prototype = &#123; n: 2, m: 3&#125;// 原因同上，因此 c 的隐式原型为 &#123; n: 2, m: 3 &#125;;const c = new A();console.log(b.n, b.m, c.n, c.m); // 1 undefined 2 3 实例二1234567891011121314151617181920212223242526function Test() &#123;&#125;Object.prototype.a = function() &#123; console.log('a 方法执行');&#125;Function.prototype.b = function() &#123; console.log('b 方法执行');&#125;var t = new Test();/** * 这里解释一波 * 1、每个函数对象的显式原型都指向一个空对象，而每个实例对象的隐式原型 === 函数对象的显式原型， * 那么 t.a() 会按照这个顺序查找: t.__proto__ === Test.prototype = &#123;&#125;; &#123;&#125;.__proto__ === Object.prototype; * 而 Object 的显式原型中有方法 a，因此可以正确执行； * 2、t.b() 同理，在原型链中没有找到 b 方法，因此会报错：t.b is not a function; * 3、Test.a() 的查找顺序：Test.__proto__ === Function.prototype = &#123; b: function() &#123; console.log('b 方法执行'); &#125; &#125;; * &#123;b: fucntion() &#123;console.log('b 方法执行');&#125;&#125;.__proto__ === Object.prototype; * 因此：Test.a() 和 Test.b() 都可以正确执行 */t.a(); // a(); t.b(); // t.b is not a functionTest.a(); // a();Test.b(); // b(); 四、总结 每个函数对象（Object 函数对象除外）都默认有一个显式原型对象，指向一个空的 Object 对象，空对象中有一个 constructor 属性，指向当前函数对象 所有函数对象都有一个隐式原型对象（包括 Function 函数对象），且都默认指向 Function 函数对象的显式原型对象 函数对象的显式原型等于实例对象的隐式原型 访问对象属性时，会先在实例对象本身进行查找，找到则返回，没找到则在隐式原型链中继续查找，找到则返回，没找到返回 undefined 额外补充一点：函数对象的隐式原型和显示原型没有关系（Function 函数对象除外），Function 函数对象的显式原型等于自身的隐式原型（因为所有函数都是 Function 的实例（包括 Function 自身）） 五、推荐链接之前看到这篇博客里有详细的原型链示意图，有兴趣的朋友可以详细去看一下： 一个例子让你彻底明白原型对象和原型链","tags":[]},{"title":"快速使用 Hexo + Github 搭建个人博客（超简单的步骤）","date":"2019-08-02T09:07:45.000Z","path":"20190802/hexo-blog/","text":"最近心血来潮，打算重新搭建一个个人博客。网上也有很多教程，但是都特别的详细，步骤特别的繁琐。所以我就将步骤说明进行了简化，只需要三步就能使用 Hexo + Github 搭建一个个人博客，方便以后需要的朋友们使用。 前言其实原理很简单，就是将 Hexo 生成的静态文件部署到 GitHub 的仓库中，利用 GitHub Pages 将静态文件展示在浏览器中，就可以通过 GitHub 的项目地址访问个人博客。 下面就通过实际操作进行博客的搭建。 前置条件：电脑中需要安装 Node 和 Git。若果没有安装，直接去官网下载，下载完成打开，一路 Next 安装即可。 Git 下载地址 Node 下载地址 一、使用 Hexo安装 Hexo首先电脑中需要先安装 node 环境，如果没有安装的话直接到 Node 官网进行下载，下载完成后一路 Next 安装完成即可。如担心安装有问题，安装过程可自行百度，过程比较简单，这里就直接省略了。 安装完 node 之后，就可以使用 npm 命令了 1234567# 全局安装 hexonpm install -g hexo-cli# 安装完成后测试是否安装成功hexo -v# 能打印出来关于 hexo 的各种信息即代表安装成功 使用 Hexo 创建项目12345678# 初始化项目hexo init &lt;folder&gt;# 这里稍微需要一点时间下载资源，请耐心等待# 打开项目，安装依赖cd &lt;folder&gt;npm install 此时项目目录应该如下展示： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 运行项目在项目根目录下运行以下命令： 1hexo server 然后在浏览器打开 http://localhost:4000/，看到如下界面，说明项目启动成功了： Hexo 默认界面 在 GitHub 中创建仓库在 GitHub 中创建仓库，使用 GitHub Pages 作为载体，展示 Hexo 编译后生成的静态文件。 如果没有 GitHub 账号，可以直接在官网注册一下。 创建新的仓库 在 Github 中创建一个新的仓库，仓库名必须命名为：&lt;你的 github 用户名&gt;.github.io。 因为使用这个名字作为仓库名的话，项目部署好之后可以直接通过 https://&lt;你的 github 用户名&gt;.github.io 访问。如果用了别的名字，就需要通过 https://&lt;你的 github 用户名&gt;.github.io/&lt;仓库名&gt; 的地址访问。 步骤如下： 新建仓库 新建仓库 设置仓库属性 设置属性 箭头指示的复选框一定要进行勾选，否则后面在使用 GitHub Pages 的时候会因为仓库中没有内容而无法使用。 在浏览器中访问在浏览器中输入 https://&lt;你的 github 用户名&gt;.github.io 地址，看到有文字展示，说明 GitHub 设置完成了。 三、整合 Hexo + GitHub拷贝当前 GitHub 仓库的地址将仓库地址进行拷贝，下一步中配置 Hexo 的 deploy 属性时要用到。 拷贝地址 设置 Hexo 发布配置打开创建好的 Hexo 项目，找到 _config.yml 文件，修改其中的 deploy 配置 1234deploy: type: git repo: &lt;上一步拷贝的 GitHub 仓库地址&gt; branch: master 将 Hexo 项目生成静态文件进入创建好的 Hexo 项目根目录下，运行： 1hexo generate 将 Hexo 项目发布到 GitHub 仓库中 在发布之前，如果没有在本地配置过 git，建议先执行以下两个命令 123git config --global user.name \"&lt;GitHub 用户名&gt;\"git config --global user.email \"&lt;邮箱账号&gt;\" 1hexo deploy 可能会弹窗提示输入密码，则输入你的 GitHub 密码即可。 发布完成后，根目录下会多出一个 .deploy 的文件夹，最好将其删除掉，不然之后提交代码可能会有问题 访问 GitHub Pages 地址此时，在浏览器中输入 https://&lt;你的 github 用户名&gt;.github.io 地址，则可以看到跟本地启动 Hexo 展示一致的界面 Hexo 默认界面 使用Hexo + GiHub 搭建个人博客的基本步骤已经完成了。如想查看如何编写博客可以继续向下浏览，如暂时只是想搭建博客，则至此已经完成了。 四、使用 Hexo 编写博客编写博客12345# 创建一个文件草稿，在其中编写内容。草稿不会被发布hexo new draft \"&lt;文件名称&gt;\"# 创建一个文件，在其中编写内容hexo new post \"&lt;文件名称&gt;\" 生成的都是 makedown 类型的文件，直接在其中使用 makedown 语法编写内容即可。 生成的草稿或者文件中会有部分内容，这些内容都是由模板生成的，模板在根目录下的 scaffolds 文件夹中，模板内容可以根据自己需要进行修改。 其他常用命令1234567891011121314# 将草稿发不成正式文件hexo publish \"&lt;文件名称&gt;\"# 启动服务，预览项目(不包括草稿文件)hexo server# 启动项目，包括草稿文件hexo server --draft# 生成静态文件hexo generate# 发布项目hexo deploy 更换主题可以进入到 Hexo 主题网站 选择自己喜欢的主题，按照其中的说明进行安装配置 评论、数据统计等功能不同主题都会有相应的配置文件，按照主题说明进行配置即可。 其他关于 Hexo 的更多使用，建议在 Hexo 中文官网进行查看。官网的说明更为详尽。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://beichensky.github.io/tags/Hexo/"}]},{"title":"Express 的基本使用","date":"2019-08-01T15:29:30.000Z","path":"20190801/express-note/","text":"本文从安装、用法、常用 API 等方面简单介绍了 Express 的用法。 一、Express 简介1、Express 是什么？ 基于 Node 平台开发的 Web 开发框架 提供一系列强大的特性，帮助创建各种 Web和移动设备应用 是 NodeJS 的一个模块 2、为什么使用 Express 为了基于 NodeJS 开发 web 应用程序更高效 二、安装与使用1、安装12345678910# 新建 my-app 文件夹mkdir my-appcd my-app# 初始化 package-json 文件npm init -y# 安装 express 依赖npm install express -S 2、基本使用根目录下新建 index.js 文件 1234567const express = require('express');const app = express();app.listen(300, () =&gt; &#123; console.dir('服务启动：http://localhost:3000/');&#125;) 根目录下运行 node index.js，即可看到控制台打印输出。说明服务已经启动 3、路由基本路由基本使用方式： 123456789101112131415161718192021222324252627// Get 请求app.get('/', (req, res) =&gt; &#123; res.send('欢迎使用 Express(GET)');&#125;);// POST 请求app.post('/', (req, res) =&gt; &#123; res.send('欢迎使用 Express(POST)');&#125;);// Put 请求app.put('/', (req, res) =&gt; &#123; res.send('欢迎使用 Express(PUT)');&#125;);app.delete('/', (req, res) =&gt; &#123; res.send('欢迎使用 Express(DELETE)');&#125;);// ... 等等其他请求方式// 路径支持正则表达式app.get('/a+b', (req, res) =&gt; &#123; res.send('类似于 /ab、/aab、/aaab 等的路径均可访问');&#125;) 或者使用 app.route() 的方式 12345678910111213app.route('/') .get((req, res) =&gt; &#123; res.send('欢迎使用 Express(GET)'); &#125;) .post((req, res) =&gt; &#123; res.send('欢迎使用 Express(POST)'); &#125;) .put((req, res) =&gt; &#123; res.send('欢迎使用 Express(PUT)'); &#125;) .delete((req, res) =&gt; &#123; res.send('欢迎使用 Express(DELETE)'); &#125;) 特殊路由：app.all([path,] callback) 不写 path 参数，默认是根路径 请求路径（pathname）必须要全等于 path，才会执行 callback； 任意请求方式都会执行 callback 函数 123app.all('/book', (req, res) =&gt; &#123; res.send('无论任意请求方式，只要请求路径（pathname）为 /book，都会返回这句话');&#125;) app.use([path,] callback) 不写 path 参数，默认是根路径 只要请求路径（pathname）第一段为 path，就会执行 callback； 任意请求方式都会执行 callback 函数 123app.use('/book', (req, res) =&gt; &#123; res.send('无论任意请求方式，只要请求路径（pathname）第一段为 /book，都会返回这句话');&#125;) 4、路由拆分：express.Router([options])options 中的参数： 属性 描述 默认值 caseSensitive 启用区分大小写。 默认情况下禁用，将“/ Foo”和“/ foo”视为相同。 mergeParams 保留req.params父路由器的值。如果父级和子级具有冲突的参数名称，则子级的值优先。 false strict 启用严格路由。 默认情况下禁用，“/ foo”和“/ foo /”由路由器处理相同。 将所有的路由都写在 index.js 文件中，不易维护而且也不安全，所以我们可以把不同路径下的路由进行拆分，分别放在不同文件下，易于维护。这个时候就会用到 express.Router(); 与 app 类似，也可以使用 route()、all()、use() 等方法 编写路由文件 order.js 123456789101112131415161718192021const express = require('express');const router = express.Router();router.use((req, resp, next) =&gt; &#123; console.log(new Date().toLocaleString()); next();&#125;)router.get('/list', (req, resp) =&gt; &#123; resp.send('订单列表');&#125;)router.get('/detail', (req, resp) =&gt; &#123; resp.send('订单详情');&#125;)router.post('/submit', (req, resp) =&gt; &#123; resp.send('提交订单');&#125;)module.exports = router; 即可在 index.js 中使用 12345678// ...const order = require('./order.js');app.use('/order', order);// ... 访问 http://localhost: 3000/order/list 或者其他 order 文件中的路径即可获取到对应返回结果 5、访问静态资源 api: app.use([pathname,] express.static(root，[options])) pathname: 访问路径 root: 静态资源文件夹路径 options： 其他配置项，可参考这里 此时假如 public 文件是静态文件存放目录，文件夹下有 a.png 的图片文件 1app.use('/public', express.static(path.join(__dirname, 'public'))); 则此时访问 http://localhost: 3000/public/a.png，可以看到图片正常显示。 6、中间件的使用app.use([path, ] (req, res, next) =&gt; { ...; next() }) path 参数可写可不写，不写则默认为根路径，所有访问路径均可使用； 比一般回调函数多一个 next 参数，必须执行，否则不会继续向下执行。 三、常用 API1、Applicationapp.listen（[port [，host [，backlog]]] [，callback]）启动服务，监听端口地址 app.METHOD（path，callback [，callback ...]）路由请求方式： METHOD 为各种请求方式 path：请求路径 callback：中间件及回调函数，可包含多个，出最后一个外，其他的必须在最后执行 next() ，否则不会再继续向下执行 app.path()返回应用程序的规范路径，一个字符串。 12345678910var app = express();var blog = express();var blogAdmin = express();app.use('/blog', blog);blog.use('/admin', blogAdmin);console.dir(app.path()); // ''console.dir(blog.path()); // '/blog'console.dir(blogAdmin.path()); // '/blog/admin' app.set(name, value) / app.get(name) app.set(name, value)：为 name 属性设置 value，存储到服务器中 app.get(name)：获取 name 属性对应的 value 错误处理中间件的使用12345app.use((err, req, res, next) =&gt; &#123; // 错误处理逻辑 console.error(err.stack) res.status(500).send('Something broke!')&#125;) 2、Requestreq.params获取请求路径中的 param 例如请求路径为：http://localhost:3000/news/2019/10 123app.get('/news/:year/:month', (req, res) =&gt; &#123; res.send(req.params); // &#123;\"year\":\"2019\",\"month\":\"10\"&#125;&#125;) req.query获取 Get 请求路径中传递的查询参数 例如 Get 请求为：http://localhost:3000?name=zgd 123app.get('/', (req, resp) =&gt; &#123; resp.send(req.query); // &#123;\"name\": \"zgd\"&#125;&#125;); req.body获取 Post 请求中能够传递的查询参数 例如 Post 请求为：curl -d &quot;name=zgd&quot; http://localhost:3000 123456app.use(express.json()) // for parsing application/jsonapp.use(express.urlencoded(&#123; extended: true &#125;)) // for parsing application/x-www-form-urlencodedapp.post('/', (req, resp) =&gt; &#123; resp.send(req.body); // &#123;\"name\": \"zgd\"&#125;&#125;); req 获取路径 req.baseUrl：安装路由器实例的URL路径，不包含请求参数 req.path: 当前请求路径，不包含请求参数 req.originalUrl：院士路径，即全路径，包含请求参数 req.url：当前请求路径，包含请求参数123456789101112131415app.get('/book/list', (req, res) =&gt; &#123; res.write(req.baseUrl); // '' res.write(req.path); // '/book/list' res.write(req.originalUrl); // '/book/list'&#125;);app.use('/book', book);// book.jsrouter.get('/list', (req, res) =&gt; &#123; res.write(req.baseUrl); // '/book' res.write(req.path); // '/list' res.write(req.originalUrl); // '/book/list'&#125;) 其他属性 属性 描述 例子 req.baseUrl 安装路由器实例的URL路径。 用法查看这里 req.path 当前请求路径 用法查看这里 req.originalUrl 原始 URL 请求路径。后面没有跟请求参数时，相当于是 baseUrl + path；路径后面跟了请求参数，则请求参数也包含在内 / GET /search?q=something / console.dir(req.originalUrl); // =&gt; ‘/search?q=something’ req.cookies 此属性是包含请求发送的cookie的对象。如果请求不包含cookie，则默认为{}。 console.dir(req.cookies.name) req.signedCookies 同 req.cookies 如果cookie已签名，必须使用这个，而不能使用 req.cookies req.fresh 指示请求是否“新鲜”。它是相反的req.stale。 用法查看这里 req.stale 指示请求是否“陈旧”，并且与之相反req.fresh。 用法查看这里 req.hostname 包含从HostHTTP标头派生的主机名。 / Host: “example.com:3000” / console.dir(req.hostname); // =&gt; ‘example.com’ req.ip 包含请求的远程IP地址。 console.dir(req.ip); // =&gt; ‘127.0.0.1’ req.method 包含对应于该请求的HTTP方法的字符串： GET，POST，PUT，等。 - req.protocol 包含请求协议字符串：http或者（对于TLS请求）https。 console.dir(req.protocol); // =&gt; ‘http’ req.route 包含当前匹配的路由，一个对象。 用法查看这里 req.secure 一个布尔属性，如果建立了TLS连接，则该属性为true。 相当于：console.dir(req.protocol === ‘https’); // =&gt; true req.subdomains 请求的域名中的一组子域。 / Host: “tobi.ferrets.example.com” / console.dir(req.subdomains); // =&gt; [‘ferrets’, ‘tobi’] req.xhr 一个布尔属性，true如果请求的X-Requested-With头字段是“XMLHttpRequest”，则表示该请求是由客户端库（如jQuery）发出的。 console.dir(req.xhr); // =&gt; true 3、Responseres.end（[data] [，encoding]）结束响应过程。 12res.end()res.status(404).end() res.send([body])与 res.end() 的区别： 参数 body 可以是 String、Buffer，也可以是 Array、Object 会自动添加响应头：”Content-Type: text/html; charset=utf-8” 123res.send(Buffer.from('whoop'))res.send(&#123; some: 'json' &#125;)res.send('&lt;p&gt;some html&lt;/p&gt;') res.sendFile（path [，options] [，fn]）在指定时间发送文件到客户端。Content-Type 会根据文件的扩展名设置响应 HTTP 响应头字段。除非在 options 对象中设置了该选项，否则 path 必须是该文件的绝对路径。 12345678910111213141516171819app.get('/file/:name', function (req, res, next) &#123; var options = &#123; root: path.join(__dirname, 'public'), dotfiles: 'deny', headers: &#123; 'x-timestamp': Date.now(), 'x-sent': true &#125; &#125; var fileName = req.params.name res.sendFile(fileName, options, function (err) &#123; if (err) &#123; next(err) &#125; else &#123; console.log('Sent:', fileName) &#125; &#125;)&#125;) res.sendStatus（statusCode）设置响应状态码并结束响应 1res.sendStatus(200) // equivalent to res.status(200).send('OK') res.status设置响应状态码 1res.status(200).send('OK') res.set(field [，value])将响应的 HTTP 请求头 field 设置为 value。要一次设置多个字段，请传递一个对象作为参数。 1234567res.set('Content-Type', 'text/plain')res.set(&#123; 'Content-Type': 'text/plain', 'Content-Length': '123', 'ETag': '12345'&#125;) res.get(field)返回由指定的HTTP响应头field。该匹配不区分大小写。12res.get('Content-Type')// =&gt; \"text/plain\" res.redirect([status，] path)重定向到指定的 URL path，具有指定的status与HTTP状态代码对应的正整数。如果未指定，则status默认为”302”。 1234res.redirect('/foo/bar')res.redirect('http://example.com')res.redirect(301, 'http://example.com')res.redirect('../login') res.json（[body]）用法同 res.send(); res.append(field [，value])将指定的内容追加 value 到 HTTP 响应头 field。如果尚未设置标头，则会创建具有指定值的标头。所述 value 参数可以是字符串或数组。 注意：调用res.set()after res.append()将重置先前设置的标头值。 123res.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;'])res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')res.append('Warning', '199 Miscellaneous warning') res.cookie(name，value [, options])设置 cookie 中的 name 属性为 value 12res.cookie('name', 'tobi', &#123; domain: '.example.com', path: '/admin', secure: true &#125;)res.cookie('rememberme', '1', &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;) res.clearCookie(name [，options])清除 cookie 中对应的 name 属性 12res.cookie('name', 'tobi', &#123; path: '/admin' &#125;)res.clearCookie('name', &#123; path: '/admin' &#125;) Router与 app 中使用 路由的方式类似： router.Method(path, callback) router.use() router.all() router.route() 四、参考文档 express 中文文档 express 英文文档","tags":[{"name":"Node","slug":"Node","permalink":"https://beichensky.github.io/tags/Node/"},{"name":"Express","slug":"Express","permalink":"https://beichensky.github.io/tags/Express/"}]},{"title":"使用 JSBridge 与原生 IOS、Android 进行交互（含H5、Android、IOS端代码，附 Demo）","date":"2019-07-09T02:18:29.000Z","path":"20190709/jsbridge-native/","text":"本文详细讲述了如何使用 JSBridge 在 H5 和原生 Android、IOS之间进行交互。IOS 端包含 OC 和 Swift 的版本，Android 端包含 Java 和 Kotlin 版本。 一、写在前面本文主要是通过代码讲述了如何使用 JSBridge 在 H5 和 原生之间进行通信。文中包含 H5、IOS、Android 三部分的代码。IOS 中使用 OC 和 Swift 分别进行了代码实现。Android 中使用 Java 和 Kotlin 分别进行了代码实现。 Demo 地址：jsbridge-example JSBridgeH5：H5 端代码实现 JSBridgeIOSOC：原生 IOS 端 OC 代码实现 JSBridgeIOSSwift：原生 IOS 端 Swift 代码实现 JSBridgeAndroidJava：原生 Android 端 Java 代码实现 JSBridgeAndroidKotlin：原生 IOS 端 Kotlin 代码实现 本文没有讲解关于原理的部分，只是详细使用代码介绍了 JSBridge 的使用。想要了解原理的朋友，可以另行搜索关于原理的博客。 二、H5 端代码 初始化 WebViewJavascriptBridge，方式代码如下 注册供原生调用的事件函数：window.setupWebViewJavascriptBridge(bridge =&gt; bridge.registerHandler(&#39;fnName&#39;, function) ) 调用原生事件函数：window.setupWebViewJavascriptBridge(bridge =&gt; bridge.callHandler(&#39;fnName&#39;, data, callback) ) 1、初始化 WebViewJavascriptBridge在项目入口文件或者根 js 文件下，添加以下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 这里根据移动端原生的 userAgent 来判断当前是 Android 还是 iosconst u = navigator.userAgent;// Android终端const isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1;// IOS 终端const isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); /** * 配合 IOS 使用时的初始化方法 */const iosFunction = (callback) =&gt; &#123; if (window.WebViewJavascriptBridge) &#123; return callback(window.WebViewJavascriptBridge) &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback) &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function()&#123; document.documentElement.removeChild(WVJBIframe); &#125;, 0);&#125;/** * 配合 Android 使用时的初始化方法 */const andoirFunction = (callback) =&gt; &#123; if (window.WebViewJavascriptBridge) &#123; callback(window.WebViewJavascriptBridge); &#125; else &#123; document.addEventListener('WebViewJavascriptBridgeReady', function () &#123; callback(window.WebViewJavascriptBridge); &#125;, false) &#125;&#125;window.setupWebViewJavascriptBridge = isAndroid ? andoirFunction : iosFuntion;isAndroid &amp;&amp; window.setupWebViewJavascriptBridge(function (bridge) &#123; // 注册 H5 界面的默认接收函数（与安卓交互时，安卓端可以不调用函数名，直接 send 数据过来，就能够在这里接收到数据） bridge.init(function (msg, responseCallback) &#123; message.success(msg); responseCallback(\"JS 返回给原生的消息内容\"); &#125;)&#125;); 2、注册与原生交互的事件函数123456789101112131415/* window.setupWebViewJavascriptBridge(bridge =&gt; &#123; bridge.registerHandler('事件函数名',fun 执行函数); &#125;)*/window.setupWebViewJavascriptBridge(bridge =&gt; &#123; /** * data：原生传过来的数据 * fn: 原生传过来的回调函数 */ bridge.registerHandler(\"H5Function\", (data, fn) =&gt; &#123; console.log(data); fn &amp;&amp; fn(); &#125;);&#125;); 3、调用原生注册的事件函数调用原生注册的时间函数时使用如下的代码：12345678910/* window.setupWebViewJavascriptBridge(bridge =&gt; &#123; bridge.callHandler('安卓端函数名', \"传给原生端的数据\", callback 回调函数); &#125;)*/window.setupWebViewJavascriptBridge(bridge =&gt; &#123; bridge.callHandler('changeData', data, (result) =&gt; &#123; console.log(result); &#125;);&#125;) 三、IOS 端代码 初始化 WebViewJavascriptBridge: 12+ (instancetype)bridgeForWebView:(id)webView;+ (instancetype)bridge:(id)webView; 注册与 H5 端交互的事件函数：- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler; 调用 H5 端事件函数： 123- (void)callHandler:(NSString*)handlerName;- (void)callHandler:(NSString*)handlerName data:(id)data;- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback; 1、引入 WebViewJavascriptBridge直接使用方式 下载 WebViewJavascriptBridge 找到 WebViewJavascriptBridge文件夹，直接拖入到 XCode 项目中，在提示的弹窗中选择 Copy items if needed 和 Create groups，如下图： 在 ViewController.h 头文件中引入 #import &quot;WebViewJavascriptBridge.h&quot; 即可 Cocopad 使用方式如必须使用这种方式请自行 Google。 2、初始化 WebViewJavascriptBridge12345678910111213141516171819202122232425262728// 启用 WebViewJavascriptBridge Log[WebViewJavascriptBridge enableLogging];// 初始化 WKWebViewConfiguration 对象self.webConfig = [[WKWebViewConfiguration alloc] init];// 设置偏好设置_webConfig.preferences = [[WKPreferences alloc] init];// 默认为0_webConfig.preferences.minimumFontSize = 10;// 默认认为YES_webConfig.preferences.javaScriptEnabled = YES;// 在iOS上默认为NO，表示不能自动通过窗口打开_webConfig.preferences.javaScriptCanOpenWindowsAutomatically = NO;// TODO: 请替换成页面的 url 地址NSString *URLSTR = @\"http://xxx.xxx.xxx.xx:xxxx\";self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:_webConfig];// 设置 UserAgent 后缀_webView.customUserAgent = [NSString stringWithFormat:self.webView.customUserAgent, @\"app\"];_webView.UIDelegate = self;_webView.navigationDelegate = self;NSURL *url = [NSURL URLWithString:URLSTR];NSURLRequest *urlRequest = [NSURLRequest requestWithURL:url];[_webView loadRequest:urlRequest];[self.view addSubview:_webView];self.bridge = [WebViewJavascriptBridge bridgeForWebView:self.webView];[_bridge setWebViewDelegate:self]; 3、注册与 H5 端交互的事件函数123456789// 例：注册修改 User 名称的 changeUser 函数[self.bridge registerHandler:@\"changeUser\" handler:^(id data, WVJBResponseCallback responseCallback) &#123; // 在这里处理逻辑 NSLog(@\"JS 传过来的数据%@\", data); if (responseCallback) &#123; // 执行回调函数 responseCallback(@\"返回给 JS 的数据\"); &#125;&#125;]; 4、调用 H5 端事件函数1234// 调用 H5 界面的 changeName 事件函数[self.bridge callHandler:@&quot;changeName&quot; data:name responseCallback:^(id responseData) &#123; NSLog(@&quot;JS 调用 OC 回调函数返回的值：%@&quot;, responseData);&#125;]; 四、Android 端代码 注册与 H5 交互的事件函数： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 调用 H5 端事件函数 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack);&#125; 注册与 H5 交互的默认事件，即 H5 端不调用函数名，直接使用 send 函数传递数据，安卓端也可以在这个事件中接收到数据 1234// 设置默认接收函数public void setDefaultHandler(BridgeHandler handler) &#123; this.defaultHandler = handler;&#125; 调用 H5 端注册的默认事件函数 1234@Overridepublic void send(String data, CallBackFunction responseCallback) &#123; doSend(null, data, responseCallback);&#125; 1、引入 BridgeWebView 在项目的 build.gradle 文件中添加如下代码： 1234567buildTypes &#123; // ... repositories &#123; // ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 添加依赖：implementation &#39;com.github.lzyzsd:jsbridge:1.0.4&#39; 2、初始化 BridgeWebView在 activity_main.xml 文件中添加布局12345&lt;com.github.lzyzsd.jsbridge.BridgeWebView android:id=\"@+id/main_wv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/com.github.lzyzsd.jsbridge.BridgeWebView&gt; 在 MainActivity 中初始化 BridgeWebView123456789101112131415161718mWebView = findViewById(R.id.main_wv);mWebView.getSettings().setAllowFileAccess(true);mWebView.getSettings().setAppCacheEnabled(true);mWebView.getSettings().setDatabaseEnabled(true);// 开启 localStoragemWebView.getSettings().setDomStorageEnabled(true);// 设置支持javascriptmWebView.getSettings().setJavaScriptEnabled(true);// 进行缩放mWebView.getSettings().setBuiltInZoomControls(true);// 设置UserAgentmWebView.getSettings().setUserAgentString(mWebView.getSettings().getUserAgentString() + \"app\");// 设置不用系统浏览器打开,直接显示在当前WebViewmWebView.setWebChromeClient(new WebChromeClient());mWebView.setWebViewClient(new MyWebViewClient(mWebView));mWebView.loadUrl(URL); 3、注册与 H5 交互的事件函数12345678910111213141516171819// 默认事件函数mWebView.setDefaultHandler(new BridgeHandler() &#123; @Override public void handler(String data, CallBackFunction function) &#123; Toast.makeText(MainActivity.this, data, Toast.LENGTH_LONG).show(); function.onCallBack(\"安卓返回给 JS 的消息内容\"); &#125;&#125;);// 普通事件函数mWebView.registerHandler(\"reloadUrl\", new BridgeHandler() &#123; @Override public void handler(String data, CallBackFunction function) &#123; mWebView.reload(); Toast.makeText(MainActivity.this, \"刷新成功~\", Toast.LENGTH_SHORT).show(); function.onCallBack(\"\"); &#125;&#125;); 4、调用 H5 端事件函数12345678910111213141516// 调用 H5 端默认事件函数mWebView.send(\"安卓传递给 JS 的消息\", new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Toast.makeText(MainActivity.this, data, Toast.LENGTH_LONG).show(); &#125;&#125;);// 调用 H5 端普通事件函数mWebView.callHandler(\"changeName\", mEditName.getText().toString(), new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Toast.makeText(MainActivity.this, \"name 修改成功\", Toast.LENGTH_SHORT).show(); mEditName.setText(\"\"); &#125;&#125;); 5、添加网络权限这一步是必须的，否则的话， WebView 加载不出来，手机界面会提示 Webpage not available。 在 AndroidManifest.xml 清单文件中添加： 123&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; 添加了权限之后，网页可能还是加载不出来，可能是因为对未加密的流量不信任，在 AndroidManifest.xml 的 application 中添加一个属性：android:usesCleartextTraffic=&quot;true&quot;。如下： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest ...&gt; &lt;application ... android:usesCleartextTraffic=\"true\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 五、Tips1、在 Swift 中使用 WebViewJavascriptBridge和在 OC 中使用类似，直接将下载好的 WebViewJavascriptBridge 文件夹拖到 Swift 项目中。但此时还不能直接使用，因为 WebViewJavascriptBridge 中使用 OC 编写的。所以需要先创建一个头文件，名为：项目名-Bridging-Header.h，将需要用到的 OC 的头文件引入进去。这里我建议不要手动创建，可以让 XCode 自动帮忙创建。创建方式：在 Swift 项目中创建一个 OC 文件： 创建 OC 文件 之后 XCode 会自动提示创建 Bridging Header： 创建 Bridging Header 创建之后，在文件夹中引入 WebViewJavascriptBridge.h 头文件： 引入 OC 头文件 最后，就可以在 Swift 代码中正常使用 OC 编写的方法了： 使用 OC 编写方法 2、运行 XCode 项目报错，控制台提示：Unknown class ViewController in Interface Builder file.解决办法：打开 Main.storyboard 文件，按照下图所示，找到箭头所指输入框中的 ViewController，删除掉，之后再重新输入，找到新的 ViewController，填进去即可： 解决异常 六、参考链接 JsBridge WebViewJavascriptBridge iOS开发-WKWebView设置cookie swift项目中使用OC/C的方法 iOS类似Android上toast效果 七、Demo 地址jsbridge-example 如果有所帮助，欢迎 Star！","tags":[{"name":"JS","slug":"JS","permalink":"https://beichensky.github.io/tags/JS/"},{"name":"IOS","slug":"IOS","permalink":"https://beichensky.github.io/tags/IOS/"},{"name":"Andoird","slug":"Andoird","permalink":"https://beichensky.github.io/tags/Andoird/"},{"name":"JSBridge","slug":"JSBridge","permalink":"https://beichensky.github.io/tags/JSBridge/"}]},{"title":"SSH 学习笔记","date":"2019-05-31T08:59:02.000Z","path":"20190531/SSH-学习笔记/","text":"一、创建命令 1ssh-keygen -t rsa -C \"这里换上你的邮箱\" 二、ssh-add 命令 将 ssh 添加到 ssh-agent：ssh-add ~/admin/.ssh/id_rsa 将 ssh 从 ssh-agent 中删除：ssh-add -d ~/admin/.ssh/id_rsa 切换用户，只需要将 前一个秘钥使用 ssh-add 删除，将后一个秘钥使用 ssh-add 添加上即可 检查当前秘钥：ssh-add -l 更多命令 三、ssh 命令 检查当前用户：ssh -T git@github.com 测试能不能连接到远程仓库服务器，并获取信息：ssh 172.16.6.1 四、查看 git 凭证 查看当前系统支持的git 凭证：git help -a | grep credential 查看自己电脑的全局配置：git config —list 查看本机的 git 凭证是否全部删除：git config credential.helper，如果出现osxkeychain， store 或者 cache 等文件说明没有全部删除，没有任何反应，说明凭证文件全部清除了 查看凭证文件所在目录：git config --show-origin --get credential.helper 如果你的Mac上还有Xcode的话，那么Xcode中还会有一个.gitconfig文件，找出他然后打开，清空[credential]。 五、其他命令 查看指定目录下指定文件是否存在：ls -al 文件目录/文件 eg：ls -al ~/admin/.ssh 六、可能遇到的问题 The authenticity of host ‘github.com (52.74.223.119)’ can’t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? 解决办法：直接输入 yes 即可，会在 .ssh 文件中生成一个 known_hosts 文件，之后在 clone 项目就不会出现这个问题了 七、参考文档 git ssh key配置 git多用户切换 多个git账号的登录与切换 git 缓存密码导致的不能和远程仓库交互unable to access… 403错误 git—如何解决The authenticity of host ‘gitee.com (120.55.226.24)’ can’t be established","tags":[{"name":"SSH","slug":"SSH","permalink":"https://beichensky.github.io/tags/SSH/"},{"name":"Shell","slug":"Shell","permalink":"https://beichensky.github.io/tags/Shell/"}]},{"title":"JS 小数运算出现误差的两种解决办法","date":"2019-05-28T07:50:07.000Z","path":"20190528/JS-小数运算出现误差的解决办法/","text":"本文介绍了解决 JS 中小数运算出现误差的两种解决办法 问题在 JS 的小数运算中可能会出现一些问题，比如说下面两种情况： 0.1 + 0.2 加法出现精度偏差问题 0.14 * 100 乘法出现精度偏差问题 解决方案下面简单介绍了两种常用的解决方案： 限制精确位数可以限制保留几位小数的方式来避免误差： 12// 保留两位小数const num = (0.1 + 0.2).toFixed(2); 先将小数转化为整数，运算之后再重新转化为小数限制保留小数位数的方式不一定适用于所有场景，有些时候我们必须要根据不同的小数位数来进行计算。那么我们就可以使用下面这种方式。 定义一个方法，用来对小数进行加法运算12345678910111213141516171819202122/** * 用来进行小数相加的工具方法 * @param &#123;*&#125; num1 * @param &#123;*&#125; num2 */addNum (num1, num2) &#123; let sq1, sq2, multiple; try &#123; sq1 = num1.toString().split(\".\")[1].length; &#125; catch (e) &#123; sq1 = 0; &#125; try &#123; sq2 = num2.toString().split(\".\")[1].length; &#125; catch (e) &#123; sq2 = 0; &#125; multiple = Math.pow(10, Math.max(sq1, sq2) + 1); return (num1 * multiple + num2 * multiple) / multiple;&#125; 使用上面的方法进行小数相加1const num = addNum(0.1 + 0.2); 总结 第一种方法简单，方便，易于操作； 第二种方法基本可以使用所有小数相加的场景。（如果是其他的运算，修改运算符号，也可以正常使用）","tags":[{"name":"JS","slug":"JS","permalink":"https://beichensky.github.io/tags/JS/"}]},{"title":"从零开始搭建一个 React + Mobx + React Router 脚手架","date":"2019-04-11T07:17:53.000Z","path":"20190411/react-mobx-starter/","text":"本文详细介绍了如何从零开始搭建一个 React 开发的脚手架，包含如何添加 Redux 以及 React Router 的环境。 本文代码地址：react-mobx-starter。 建议将代码拉下来之后，配合本文一起查看，效果更佳。 代码下载命令：1git clone https://github.com/beichensky/react-mobx-starter.git 一、前情提要本文的 Demo 分为两个环境，一个是开发环境，另一个是生产环境。 开发环境中讲述的是如何配置出一个更好的、更方便的开发环境； 而生产环境中讲述的是如何配置出一个更优化、更小版本的生产环境。 之前我也就 Webpack 的使用写了几篇文章，本文也是在 Webpack 的基础上进行开发，也是在之前的代码上进行的扩展。 开发环境的配置是在 从零开始搭建一个 Webpack 开发环境配置（附 Demo） 一文的基础上进行的扩展。 生产环境的配置是在 使用 Webpack 进行生产环境配置（附 Demo） 一文的基础上进行的扩展。 建议：对于 Webpack 还不了解的朋友，可以先看一下 从零开始搭建一个 Webpack 开发环境配置（附 Demo） 和 使用 Webpack 进行生产环境配置（附 Demo） 这两篇文章，可以更好的入手本文。 虽然本文是在之前文章上进行的扩展，但本文还是会详细的介绍每一步的配置。 二、创建项目结构新建文件夹，命名为：react-mobx-starter1mkdir react-mobx-starter 初始化 package.json 文件1234cd react-mobx-starter# 直接生成默认的 package.json 文件npm init -y 创建 src 目录，用来存放我们编写的代码创建 public 目录，用来存放公共的文件创建 webpack 目录，用来存放 webpack 配置文件12345mkdir srcmkdir publicmkdir webpack 在 src 目录下新建 pages 文件夹，用来存放书写的页面组件新建 components 文件夹，用来存放公共组件新建 utils 文件夹，用来存放常用的工具类1234567cd srcmkdir pagesmkdir componentsmkdir utils 在 public 目录下新建 index.html 文件在 src 目录下新建 index.js 文件在 webpack 目录下创建 webpack.config.dev.js 和 webpack.config.prod.js webpack.config.dev.js 用来编写 webpack 开发环境配置 webpack.config.prod.js 用来编写 webpack 生产环境配置 index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;React + Mobx 全家桶脚手架&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.js12345678function createElement() &#123; const ele = document.createElement('div'); ele.innerHTML = 'Hello, React'; const root = document.querySelector('#root'); root.appendChild(ele);&#125;createElement(); webpack.config.dev.js 和 webpack.config.prod.js 此时还没有书写内容，我们之后会详细的进行讲述。 我们看一下此时的项目结构，之后就可以进行 webpack 的配置了。 123456789101112react-mobx-starter ├─ public/ └─ index.html ├─ src/ ├─ components/ ├─ pages/ ├─ utils/ └─ index.js ├─ webpack/ ├─ webpack.config.dev.js └─webpack.config.prod.js ├─ package.json 三、React 开发环境配置在 package.json 文件中添加一个执行脚本，用来执行 webpack 命令：1234567&#123; ..., \"scripts\": &#123; \"start\": \"webpack --config webpack/webpack.config.dev.js\" &#125;, ...&#125; 安装 webpack 相关插件安装 webpack 和 webpack-cli1npm install webpack webpack-cli --save-dev 入口和出口使用 webpack 进行项目配置的时候，必须要有入口和出口，作为模块引入和项目输出。 webpack.config.dev.js123456789101112131415const path = require('path');const appSrc = path.resolve(__dirname, '../src');const appDist = path.resolve(__dirname, '../dist');const appPublic = path.resolve(__dirname, '../public');const appIndex = path.resolve(appSrc, 'index.js');module.exports = &#123; entry: appIndex, output: &#123; filename: 'public/js/[name].[hash:8].js', path: dist, publicPath: '/' &#125;&#125; 添加 html-webpack-plugin 插件执行 npm run start 脚本，可以看到 dist/public/js 目录下多了一个 js 文件，但是这个是由 hash 值命名的的，我们每次都手动引入到 index.html 文件里面过于麻烦，所以可以引入 html-webpack-plugin 插件。 html-webpack-plugin 插件有两个作用 可以将 public 目录下的文件夹拷贝到 dist 输出文件夹下 可以自动将 dist 下的 js 文件引入到 html 文件中 安装 html-webpack-plugin 插件1npm install html-webpack-plugin --save-dev 使用 html-webpack-plugin 插件webpack.config.dev.js123456789101112131415161718192021222324const path = require('path');+ const HTMLWebpackPlugin = require('html-webpack-plugin');const appSrc = path.resolve(__dirname, '../src');const appDist = path.resolve(__dirname, '../dist');const appPublic = path.resolve(__dirname, '../public');const appIndex = path.resolve(appSrc, 'index.js');+ const appHtml = path.resolve(appPublic, 'index.html');module.exports = &#123; entry: appIndex, output: &#123; filename: 'public/js/[name].[hash:8].js', path: appDist, publicPath: '/' &#125;,+ plugins: [+ new HTMLWebpackPlugin(&#123;+ template: appHtml,+ filename: 'index.html'+ &#125;)+ ]&#125; 设置开发模式webpack 配置中的 mode 属性，可以设置为 ‘development’ 和 ‘production’，我们目前是进行开发环境配置，所以可以设置为 ‘development’ webpack.config.dev.js12345...module.exports = &#123;+ mode: 'development', ...&#125; 设置 devtool为了方便在项目出错时，迅速定位到错误位置，可以设置 devtool，生成资源映射，我们这里使用 inline-source-map，更多选择可以在这里查看区别。 webpack.config.dev.js123456...module.exports = &#123; mode: 'development',+ devtool: 'inline-source-map', ...&#125; 使用 webpack-dev-server 启动项目服务安装 webpack-dev-server1npm install webpack-dev-server --save-dev 配置 webpack-dev-serverwebpack.config.dev.js12345678910111213141516171819202122232425262728...module.exports = &#123; mode: 'development', devtool: 'inline-source-map',+ devServer: &#123;+ contentBase: appPublic,+ hot: true,+ host: 'localhost',+ port: 8000,+ historyApiFallback: true,+ // 是否将错误展示在浏览器蒙层+ overlay: true,+ inline: true,+ // 打印信息+ stats: 'errors-only',+ // 设置代理+ proxy: &#123;+ '/api': &#123;+ changeOrigin: true,+ target: 'https://easy-mock.com/mock/5c2dc9665cfaa5209116fa40/example',+ pathRewrite: &#123;+ '^/api/': '/'+ &#125;+ &#125;+ &#125;+ &#125;, ...&#125; 修改一下 package.json 文件中的 start 脚本：1234567&#123; ..., \"scripts\": &#123; \"start\": \"webpack-dev-server --config webpack/webpack.config.dev.js\" &#125;, ...&#125; 使用 friendly-errors-webpack-plugin 插件friendly-errors-webpack-plugin 插件可以在命令行展示更有好的提示功能。 安装 friendly-errors-webpack-plugin：1npm install friendly-errors-webpack-plugin --save-dev 使用 friendly-errors-webpack-plugin： webpack.config.dev.js1234567891011121314151617const path = require('path');const HTMLWebpackPlugin = require('html-webpack-plugin');+ const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin');...module.exports = &#123; ... plugins: [ new HTMLWebpackPlugin(&#123; template: appHtml, filename: 'index.html' &#125;),+ new FriendlyErrorsWebpackPlugin(), ]&#125; 启用热加载webpack.config.dev.js123456789101112131415const path = require('path');const HTMLWebpackPlugin = require('html-webpack-plugin');const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin');+ const webpack = require('webpack');...module.exports = &#123; ... plugins: [ ... new FriendlyErrorsWebpackPlugin(),+ new webpack.HotModuleReplacementPlugin() ]&#125; 运行项目，测试配置成果执行 npm run start 命令，命令行提示成功后，在浏览器打开 http://localhost:8000，可以看到 Hello React，说明基本的Webpack 配置已经成功了。 配置 babel我们现在 index.js 里面的代码量比较少，所以没有问题。但是我如果想在里面使用一些 ES6 的语法或者是还未被标准定义的 JS 特性，那么我们就需要使用 babel 来进行转换了。下面我们来配置一下 babel。 安装 babel 相关插件1npm install babel-core babel-loader@7 --save-dev 使用 babel-loader设置 cacheDirectory 属性，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。 webpack.config.dev.js123456789101112131415...module.exports = &#123; ... plugins: [ ... ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, loader: 'babel-loader?cacheDirectory', include: [ appSrc ], exclude: /node_modules/ &#125; ] &#125;&#125; 在项目根目录下新建 .babelrc 文件.babelrc 文件是运行时控制文件，在项目编译的时候会自动读取 .babelrc 文件中的 babel 配置。 使用 babel 相关 presets安装相关插件： babel-preset-env：可以在项目中使用所有 ECMAScript 标准里的最新特性。 babel-preset-stage0：可以在项目中使用社区提出来的但还未被写入 ECMAScript 标准里的特性。 babel-preset-react：可以在项目中使用 react 语法。 1npm install babel-preset-env babel-preset-stage-0 babel-preset-react --save-dev 配置 .babelrc 文件：1234567&#123; \"presets\": [ \"env\", \"stage-0\", \"react\" ]&#125; 使用 babel 相关 plugins安装相关插件： babel-plugin-transform-decorators-legacy：可以在项目中使用装饰器语法。 babel-plugin-transform-class-properties：可以在项目中使用新的 class 属性语法。 babel-plugin-transform-runtime：使用此插件可以直接使用 babel-runtime 中的代码对 js 文件进行转换，避免代码冗余。 babel-runtime：配合 babel-plugin-transform-runtime 插件成对使用 1npm install babel-plugin-transform-decorators-legacy babel-plugin-transform-class-properties babel-plugin-transform-runtime babel-runtime --save-dev 配置 .babelrc 文件：123456789101112&#123; \"presets\": [ \"env\", \"stage-0\", \"react\" ], \"plugins\": [ \"transform-decorators-legacy\", \"transform-runtime\", \"transform-class-properties\" ]&#125; 这里需要注意 transform-decorators-legacy 插件的放置顺序，最好放在第一位，否则可能会出现某些注解失效的问题。 至此，babel 相关的基本配置完成了。之后我们就可以在项目中肆意使用各种新的 JS 特性了。 添加 css 相关 loaderjs 文件相关的 babel-loader 配置好了，但是有时候我们想在项目中为元素添加一些样式，而 webpack 中认为一切都是模块，所以我们这时候也需要别的 loader 来解析一波样式代码了。 安装相关插件： css-loader：处理 css 文件中的 url() 等。 style-loader：将 css 插入到页面的 style 标签。 less-loader：是将 less 文件编译成 css。 postcss-loader：可以集成很多插件，用来操作 css。我们这里使用它集成 autoprefixer 来自动添加前缀。 1npm install css-loader style-loader less less-loader postcss-loader autoprefixer --save-dev 配置样式相关 loader 由于 React 无法直接使用类似 Vue 中 scope 这种局部作用变量，所以我们可以使用 webpack 提供的 CSS Module。2、由于等会儿会使用 antd，所以引入 antd 时需要开启 less 的 javascript 选项，所以要将 less-loader 中的属性 javascriptEnabled 设置为 true。 在 webpack.config.dev.js 中配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364...const autoprefixer = require('autoprefixer');module.exports = &#123; ..., plugins: [...], module: &#123; rules: [ ..., &#123; test: /\\.(css|less)$/, exclude: /node_modules/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; sourceMap: true, modules: true, localIdentName: '[local].[hash:8]' &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [autoprefixer()] &#125; &#125;, &#123; loader: 'less-loader', options: &#123; javascriptEnabled: true &#125; &#125; ] &#125;, &#123; test: /\\.(css|less)$/, include: /node_modules/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123;&#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [autoprefixer()] &#125; &#125;, &#123; loader: 'less-loader', options: &#123; javascriptEnabled: true &#125; &#125; ] &#125;, ] &#125;&#125; 添加其他模块解析 loader 配置安装相关插件：1npm install file-loader csv-loader xml-loader html-loader markdown-loader --save-dev 在 webpack.config.dev.js 中配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647...module.exports = &#123; ..., plugins: [...], module: &#123; rules: [ ..., // 解析图片资源 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, // 解析 字体 &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, // 解析 MakeDown 文件 &#123; test: /\\.md$/, use: [ 'html-loader', 'markdown-loader' ] &#125; ] &#125;&#125; 额外的 webpack 配置优化添加 resolve allias 属性，设置别名在项目开发过程中，随着项目越来越大， 文件层级越来越深，引入文件的时候可能会需要一层一层的找路径，就会比较繁琐，我们可以使用 resolve 中的 alias 属性为一些常用的文件夹设置别名 webpack.config.dev.js123456789101112131415··· module.exports = &#123; ..., plugins: [...], module: &#123;...&#125;,+ resolve: &#123;+ alias: &#123;+ src: appSrc,+ utils: path.resolve(__dirname, '../src/utils'),+ pages: path.resolve(__dirname, '../src/pages'),+ components: path.resolve(__dirname, '../src/components')+ &#125;+ &#125;&#125; 添加 resolve.modules 属性，指明第三方模块存放位置我们知道，一般进行模块搜索时，会从当前目录下的 node_modules 一直搜索到磁盘根目录下的 node_modules。所以为了减少搜索步骤，我们可以设置 resolve.modules 属性强制只从项目的 node_modules 中查找模块。 webpack.config.dev.js1234567891011··· module.exports = &#123; ..., plugins: [...], module: &#123;...&#125;, resolve: &#123; ...,+ modules: [path.resolve(__dirname, '../node_modules')], &#125;&#125; 安装 React、MObx 以及 React Router 相关插件1npm install react react-dom prop-types mobx mobx-react react-router-dom --save 引入 antd按照 antd 官网的说明，直接在 .babelrc 文件中添加配置，之后即可在项目中正常使用了。 安装 antd 相关插件：1npm install antd moment --save 安装 babel-plugin-import 对组件进行按需加载：1npm install babel-plugin-import --save-dev 在 .babelrc 文件中添加 antd 配置：12345678910111213141516171819&#123; \"presets\": [ \"env\", \"stage-0\", \"react\" ], \"plugins\": [ \"transform-decorators-legacy\",+ [+ \"import\",+ &#123;+ \"libraryName\": \"antd\",+ \"style\": true+ &#125;+ ], \"transform-runtime\", \"transform-class-properties\" ]&#125; 四、进行 React 开发基本上需要的插件目前都已经引入了，是时候进行开发了。 修改根目录下的 index.js 文件index.js123456789101112131415161718192021222324252627import React from 'react';import ReactDom from 'react-dom';import &#123; Provider &#125; from 'mobx-react'import &#123; LocaleProvider &#125; from 'antd';import &#123; HashRouter &#125; from 'react-router-dom';import zh_CN from 'antd/lib/locale-provider/zh_CN';import 'moment/locale/zh-cn';import GlobalModel from './GlobalModel';// import App from './App';const globalModel = new GlobalModel();const App = () =&gt; &#123; return &lt;div&gt;开发环境配置完成&lt;/div&gt;&#125;ReactDom.render( &lt;Provider globalModel=&#123; globalModel &#125;&gt; &lt;LocaleProvider locale=&#123;zh_CN&#125;&gt; &lt;HashRouter&gt; &lt;App /&gt; &lt;/HashRouter&gt; &lt;/LocaleProvider&gt; &lt;/Provider&gt;, document.querySelector('#root')); 运行 npm run start 命令，在浏览器打开 http://localhost:8000/，就能够看到 开发环境配置完成 正常显示。 此时说明我们各种插件、库都已经引入完成，可以正常使用了。 使用 React Route 进行页面间路由跳转在 src 目录下新建 App.js 文件：App.js1234567891011121314151617181920212223import React from 'react';import &#123; Switch, Route &#125; from 'react-router-dom';import Home from 'pages/home';import Settings from 'pages/settings';import Display from 'pages/display';import NotFound from 'pages/exception'import styles from './App.less';export default (props) =&gt; &#123; return ( &lt;div className=&#123; styles.app &#125;&gt; &lt;Switch&gt; &lt;Route path='/settings' component=&#123; Settings &#125; /&gt; &lt;Route path='/display' component=&#123; Display &#125; /&gt; &lt;Route exact path='/' component=&#123; Home &#125; /&gt; &lt;Route component=&#123; NotFound &#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; )&#125; 在 src 目录下创建 App.less 文件，编写 App 组件样式 App.less123.app &#123; padding: 60px;&#125; 在 pages 目录下编写 Home、Settings、Display、NotFound 组件 Home 组件是根路由组件，用来跳转到 Setting 界面和 Display 界面 Settings 组件演示了如何获取和修改 mobx 的全局 Model Display 组件演示了如何使用 mobx 进行同步和异步的数据处理 NotFound 组件在匹配不到正确路由时展示 Home、Settings、Display 相关的代码我就不贴了，占的篇幅较长，大家需要的话可以去我的 Github 上看一下或者下载下来也可以。比较方便。地址：Github 再修改一下 index.js 文件index.js1234567891011121314151617181920212223import React from 'react';import ReactDom from 'react-dom';import &#123; Provider &#125; from 'mobx-react'import &#123; LocaleProvider &#125; from 'antd';import &#123; HashRouter &#125; from 'react-router-dom';import zh_CN from 'antd/lib/locale-provider/zh_CN';import 'moment/locale/zh-cn';import GlobalModel from './GlobalModel';import App from './App';const globalModel = new GlobalModel();ReactDom.render( &lt;Provider globalModel=&#123; globalModel &#125;&gt; &lt;LocaleProvider locale=&#123;zh_CN&#125;&gt; &lt;HashRouter&gt; &lt;App /&gt; &lt;/HashRouter&gt; &lt;/LocaleProvider&gt; &lt;/Provider&gt;, document.querySelector('#root')); 可以看到这里有一个 GlobalModel 存放全局通用数据的 Model，里面的逻辑比较简单，我们稍微看一下。 GlobalModel.js1234567891011import &#123; observable, action &#125; from 'mobx';export default class GlobalModel &#123; @observable username = '小明'; @action changeUserName = (name) =&gt; &#123; this.username = name; &#125;&#125; 添加 fetch 工具类进行网络请求由于我们在 Display 组件中需要进行网络请求的异步操作，所以我们这里引入 fetch 进行网络请求。 安装 fetch 相关插件：1npm install whatwg-fetch qs --save 编写网络请求工具类在 utils 目录下创建 request.js 文件。 utils/request.js1234567891011121314151617181920212223242526272829303132333435363738import 'whatwg-fetch';import &#123; stringify &#125; from 'qs';/** * 使用 Get 方式进行网络请求 * @param &#123;*&#125; url * @param &#123;*&#125; data */export const get = (url, data) =&gt; &#123; const newUrl = url + '?' + stringify(data) + (stringify(data) === '' ? '' : '&amp;') +'_random=' + Date.now(); return fetch(newUrl, &#123; cache: 'no-cache', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json; charset=utf-8' &#125;, method: 'GET', &#125;) .then(response =&gt; response.json());&#125;/** * 进行 Post 方式进行网络请求 * @param &#123;*&#125; url * @param &#123;*&#125; data */export const post = (url, data) =&gt; &#123; return fetch(url, &#123; body: JSON.stringify(data), cache: 'no-cache', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json; charset=utf-8' &#125;, method: 'POST', &#125;) .then(response =&gt; response.json()) // parses response to JSON&#125; 至此，简单的 React 框架搭建完成了执行 npm run start，编译成功后，可以看到界面长这样。 Home 界面： Home 界面 Settings 界面： Settings 界面 Display 界面： Display 界面 NotFound 界面： NotFound 界面 五、进行 React 项目打包配置先在 package.json 文件中新增一个执行脚本：12345678&#123; ..., \"scripts\": &#123; \"start\": \"webpack-dev-server --config webpack/webpack.config.dev.js\", \"build\": \"webpack --config webpack/webpack.config.prod.js\" &#125;, ...&#125; 配置 webpack.config.prod.js 文件其中大部分的 module 和 plugin 还有 resolve 都与开发环境的一致。所以我们就以 webpack.config.dev.js 文件中的配置为基础进行说明。 将 mode 属性值修改为：’production’ 将 devtool 属性值修改为：’hidden-source-map’ 删除 devServer 属性所有的配置。 删除使用的热加载插件：·webpack.HotModuleReplacementPlugin`, 添加 optimization 属性进行代码压缩安装相关插件：1npm install uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin --save-dev 添加代码压缩配置： webpack.config.prod.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364...;const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");...;module.exports = &#123; mode: 'production', devtool: 'hidden-source-map', entry: ..., output: &#123;...&#125;, plugins: [...], module: &#123;...&#125;, optimization: &#123; // 打包压缩js/css文件 minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125; &#125; &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ], splitChunks: &#123; cacheGroups: &#123; styles: &#123; name: 'styles', test: /\\.(css|less)/, chunks: 'all', enforce: true, reuseExistingChunk: true // 表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。 &#125;, commons: &#123; name: 'commons', chunks: 'initial', minChunks: 2, reuseExistingChunk: true &#125;, vendors: &#123; name: 'vendors', test: /[\\\\/]node_modules[\\\\/]/, priority: -10, reuseExistingChunk: true &#125; &#125; &#125;, runtimeChunk: true &#125;, resolve: &#123;...&#125;&#125; 使用 mini-css-extract-plugin 插件提取 CSS 代码安装相关插件：1npm install mini-css-extract-plugin --save-dev 配置 mini-css-extract-plugin 插件： 在 plugins 属性中引入 将 module 的 rules 中使用的 style-loader 替换为 MiniCssExtractPlugin.loader webpack.config.prod.js123456789101112131415161718192021222324252627282930313233343536373839404142...const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; ..., plugins: [ ..., new MiniCssExtractPlugin(&#123; filename: 'public/styles/[name].[contenthash:8].css', chunkFilename: 'public/styles/[name].[contenthash:8].chunk.css' &#125;) ], modules: &#123; rules: [ ..., &#123; test: /\\.(css|less)$/, exclude: /node_modules/, use: [ &#123;- loader: 'style-loader'+ loader: MiniCssExtractPlugin.loader &#125;, ... ] &#125;, &#123; test: /\\.(css|less)$/, exclude: /node_modules/, use: [ &#123;- loader: 'style-loader'+ loader: MiniCssExtractPlugin.loader &#125;, ... ] &#125;, ... ] &#125;, ...&#125; 使用 DefinePlugin 插件定义当前为生产环境webpack.config.prod.js123456789101112131415...module.exports = &#123; ..., plugins: [ ..., new webpack.DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], ...&#125; 使用 clean-webpack-plugin 清理 dist 目录打包的过程中，由于部分文件名使用的是 hash 值，会导致每次文件不同，因而在 dist 中生成一些多余的文件。所以我们可以在每次打包之前清理一下 dist 目录。 安装插件：1npm install clean-webpack-plugin --save-dev 使用插件： webpack.config.prod.js12345678910...,module.exports = &#123; ..., plugins: [ ..., new CleanWebpackPlugin() ], ...&#125; 添加其他优化配置 添加 stats 配置过滤打包时出现的一些统计信息。 添加 performance 配置关闭性能提示 webpack.config.prod.js123456789101112module.exports = &#123; ..., stats: &#123; modules: false, children: false, chunks: false, chunkModules: false &#125;, performance: &#123; hints: false &#125;&#125; 进行项目的打包发布打包项目运行 npm run build 指令，控制台打包完成之后，根目录下多出了 dist 文件夹。 使用 Nginx 发布项目我这里是用的是 Nginx 作为服务器，发布在本地。 Nginx 下载地址：http://nginx.org/en/download.html。 下载完成之后，解压完成。打开 Nginx 目录，可以找到一个 conf 文件夹，找到其中的 nginx.conf 文件，修改器中的配置： Nginx 配置 将图中标注的 html 更换为 dist。 然后我们就可以放心的将打包生成的 dist 文件夹直接放到 Nginx 的安装目录下了。（此时 dist 目录与刚才的 conf 目录应该是同级的）。 启动 Nginx 服务：1start nginx 打开浏览器，输入 http://127.0.0.1 或者 http://localhost 即可看到我们的项目已经正常的跑起来了。 Nginx 其他命令：12345678# 停止 Nginx 服务nginx -s stop# 重启 Nginx 服务nginx -s reload# 退出 nginxnginx -s quit 更多 Ngnix 相关请参考：Nginx官方文档 注意：需要在 Nginx 安装目下执行 nginx 相关命令！ 六、使用 webpack-merge 引入webpack 公共配置观察 webpack.config.dev.js 和 webpack.config.prod.js 文件，可以发现有大量的代码和配置出现了重复。所以我们可以编写一个 webpack.common.js 文件，将共有的配置放入其中，然后使用 webpack-merge 插件分别引入到 webpack.config.dev.js 和 webpack.config.prod.js 文件中使用。 插件安装：1npm install webpack-merge --save-dev 使用：1234567+ const merge = require('webpack-merge');+ const common = require('./webpack.common.js');+ module.exports = merge(common, &#123;+ mode: 'production',+ ...+ &#125;); 这里就展示了一下用法，由于篇幅太长，三个文件中具体的配置代码我就不贴了，大家可以到 我的 GitHub 上查看一下使用 webpack-merge 后的配置文件。 七、本文源码地址react-mobx-starter 欢迎Star，谢谢各位！ 文章及代码中如有问题，欢迎指正，谢谢！ 八、参考文档：如何在react项目中配置ESlint webpack 官网 从零开始搭建一个 Webpack 开发环境配置（附 Demo） 使用 Webpack 进行生产环境配置（附 Demo）","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"},{"name":"前端开发","slug":"前端开发","permalink":"https://beichensky.github.io/tags/前端开发/"}]},{"title":"React Hooks 使用详解","date":"2019-04-08T02:07:43.000Z","path":"20190408/react-hooks/","text":"本文对 16.8 版本之后 React 发布的新特性 Hooks 进行了详细讲解，并对一些常用的 Hooks 进行代码演示，希望可以对需要的朋友提供点帮助。 一、Hooks 简介Hooks 是 React v16.7.0-alpha 中加入的新特性。它可以让你在 class 以外使用 state 和其他 React 特性。本文就是演示各种 Hooks API 的使用方式，对于内部的原理这里就不做详细说明。 二、Hooks 初体验Example.js 1234567891011121314151617import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个名为“count”的新状态变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Example; useState 就是一个 Hook，可以在我们不使用 class 组件的情况下，拥有自身的 state，并且可以通过修改 state 来控制 UI 的展示。 三、常用的两个 Hooks1、useState语法 const [state, setState] = useState(initialState) 传入唯一的参数: initialState，可以是数字，字符串等，也可以是对象或者数组。 返回的是包含两个元素的数组：第一个元素，state 变量，setState 修改 state值的方法。 与在类中使用 setState 的异同点： 相同点：也是异步的，例如在 onClick 事件中，调用两次 setState，数据只改变一次。 不同点：类中的 setState 是合并，而函数组件中的 setState 是替换。 使用对比之前想要使用组件内部的状态，必须使用 class 组件，例如： Example.js123456789101112131415161718192021import React, &#123; Component &#125; from 'react';export default class Example extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 而现在，我们使用函数式组件也可以实现一样的功能了。也就意味着函数式组件内部也可以使用 state 了。 Example.js1234567891011121314151617import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个名为“count”的新状态变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Example; 优化创建初始状态是比较昂贵的，所以我们可以在使用 useState API 时，传入一个函数，就可以避免重新创建忽略的初始状态。 普通的方式：12// 直接传入一个值，在每次 render 时都会执行 createRows 函数获取返回值const [rows, setRows] = useState(createRows(props.count)); 优化后的方式（推荐）：12// createRows 只会被执行一次const [rows, setRows] = useState(() =&gt; createRows(props.count)); 2、useEffect之前很多具有副作用的操作，例如网络请求，修改 UI 等，一般都是在 class 组件的 componentDidMount 或者 componentDidUpdate 等生命周期中进行操作。而在函数组件中是没有这些生命周期的概念的，只能 return 想要渲染的元素。但是现在，在函数组件中也有执行副作用操作的地方了，就是使用 useEffect 函数。 语法 useEffect(() =&gt; { doSomething }); 两个参数： 第一个是一个函数，是在第一次渲染以及之后更新渲染之后会进行的副作用。 这个函数可能会有返回值，倘若有返回值，返回值也必须是一个函数，会在组件被销毁时执行。 第二个参数是可选的，是一个数组，数组中存放的是第一个函数中使用的某些副作用属性。用来优化 useEffect 如果使用此优化，请确保该数组包含外部作用域中随时间变化且 effect 使用的任何值。 否则，您的代码将引用先前渲染中的旧值。 如果要运行 effect 并仅将其清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。 这告诉React你的 effect 不依赖于来自 props 或 state 的任何值，所以它永远不需要重新运行。 虽然传递 [] 更接近熟悉的 componentDidMount 和 componentWillUnmount 执行规则，但我们建议不要将它作为一种习惯，因为它经常会导致错误。 使用对比假如此时我们有一个需求，让 document 的 title 与 Example 中的 count 次数保持一致。 使用 class 组件： Example.js1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';export default class Example extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123; this.state.count &#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123; this.state.count &#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 而现在在函数组件中也可以进行副作用操作了。 Example.js1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; // 声明一个名为“count”的新状态变量 const [count, setCount] = useState(0); // 类似于 componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 使用浏览器API更新文档标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Example; 不仅如此，我们可以使用 useEffect 执行多个副作用（可以使用一个 useEffect 执行多个副作用，也可以分开执行） 12345678910111213useEffect(() =&gt; &#123; // 使用浏览器API更新文档标题 document.title = `You clicked $&#123;count&#125; times`;&#125;);const handleClick = () =&gt; &#123; console.log('鼠标点击');&#125;useEffect(() =&gt; &#123; // 给 window 绑定点击事件 window.addEventListener('click', handleClick);&#125;); 现在看来功能差不多了。但是在使用类组件时，我们一般会在 componentWillMount 生命周期中进行移除注册的事件等操作。那么在函数组件中又该如何操作呢？ 123456789101112131415161718useEffect(() =&gt; &#123; // 使用浏览器API更新文档标题 document.title = `You clicked $&#123;count&#125; times`;&#125;);const handleClick = () =&gt; &#123; console.log('鼠标点击');&#125;useEffect(() =&gt; &#123; // 给 window 绑定点击事件 window.addEventListener('click', handleClick); return () =&gt; &#123; // 给 window 移除点击事件 window.addEventListener('click', handleClick); &#125;&#125;); 可以看到，我们传入的第一个参数，可以 return 一个函数出去，在组件被销毁时，会自动执行这个函数。 优化 useEffect上面我们一直使用的都是 useEffect 中的第一个参数，传入了一个函数。那么 useEffect 的第二个参数呢？ useEffect 的第二个参数是一个数组，里面放入在 useEffect 使用到的 state 值，可以用作优化，只有当数组中 state 值发生变化时，才会执行这个 useEffect。 1234useEffect(() =&gt; &#123; // 使用浏览器API更新文档标题 document.title = `You clicked $&#123;count&#125; times`;&#125;, [ count ]); Tip：如果想模拟 class 组件的行为，只在 componetDidMount 时执行副作用，在 componentDidUpdate 时不执行，那么 useEffect 的第二个参数传一个 [] 即可。（但是不建议这么做，可能会由于疏漏出现错误） 四、其他 Hoos API1、useContext语法 const value = useContext(MyContext); 接受上下文对象（从中React.createContext返回的值）并返回该上下文的当前上下文值。当前上下文值由树中调用组件上方value最近的prop 确定&lt;MyContext.Provider&gt;。 useContext(MyContext) 则相当于 static contextType = MyContext 在类中，或者 &lt;MyContext.Consumer&gt;。 用法在 App.js 文件中创建一个 context，并将 context 传递给 Example 子组件 App.js123456789101112131415import React, &#123; createContext &#125; from 'react';import Example from './Example';import './App.css';export const ThemeContext = createContext(null);export default () =&gt; &#123; return ( &lt;ThemeContext.Provider value=\"light\"&gt; &lt;Example /&gt; &lt;/ThemeContext.Provider&gt; )&#125; 在 Example 组件中，使用 useContext API 可以获取到传入的 context 值 Example.js123456789101112import React, &#123; useContext &#125; from 'react';import &#123; ThemeContext &#125; from './App';export default () =&gt; &#123; const context = useContext(ThemeContext); return ( &lt;div&gt;Example 组件：当前 theme 是：&#123; context &#125;&lt;/div&gt; )&#125; 注意事项useContext必须是上下文对象本身的参数： 正确： useContext(MyContext) 不正确： useContext(MyContext.Consumer) 不正确： useContext(MyContext.Provider) useContext(MyContext)只允许您阅读上下文并订阅其更改。您仍然需要&lt;MyContext.Provider&gt;在树中使用以上内容来为此上下文提供值。 2、useReducer语法 const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。 接受类型为 (state, action) =&gt; newState 的reducer，并返回与 dispatch 方法配对的当前状态。 当你涉及多个子值的复杂 state(状态) 逻辑时，useReducer 通常优于 useState 。 用法Example.js12345678910111213141516171819202122232425262728import React, &#123; useReducer &#125; from 'react';const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;export default () =&gt; &#123; // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数 const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 优化：延迟初始化还可以懒惰地创建初始状态。为此，您可以将init函数作为第三个参数传递。初始状态将设置为 init(initialArg)。 它允许您提取用于计算 reducer 外部的初始状态的逻辑。这对于稍后重置状态以响应操作也很方便： Example.js123456789101112131415161718192021222324252627282930313233343536import React, &#123; useReducer &#125; from 'react';function init(initialCount) &#123; return &#123;count: initialCount&#125;; &#125; function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; case 'reset': return init(action.payload); default: throw new Error(); &#125;&#125;export default (&#123;initialCount = 0&#125;) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'reset', payload: initialCount&#125;)&#125;&gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 与 useState 的区别 当 state 状态值结构比较复杂时，使用 useReducer 更有优势。 使用 useState 获取的 setState 方法更新数据时是异步的；而使用 useReducer 获取的 dispatch 方法更新数据是同步的。 针对第二点区别，我们可以演示一下：在上面 useState 用法的例子中，我们新增一个 button： useState 中的 Example.js1234567891011121314151617181920212223import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个名为“count”的新状态变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); &#125;&#125;&gt; 测试能否连加两次 &lt;/button&gt; &lt;/div&gt; );&#125;export default Example; 点击 测试能否连加两次 按钮，会发现，点击一次， count 还是只增加了 1，由此可见，useState 确实是 异步 更新数据； 在上面 useReducer 用法的例子中，我们新增一个 button：useReducer 中的 Example.js12345678910111213141516171819202122232425262728293031323334import React, &#123; useReducer &#125; from 'react';const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;export default () =&gt; &#123; // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数 const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123;type: 'increment'&#125;); dispatch(&#123;type: 'increment'&#125;); &#125;&#125;&gt; 测试能否连加两次 &lt;/button&gt; &lt;/&gt; );&#125; 点击 测试能否连加两次 按钮，会发现，点击一次， count 增加了 2，由此可见，每次dispatch 一个 action 就会更新一次数据，useReducer 确实是 同步 更新数据； 3、useCallback语法 const memoizedCallback = useCallback(() =&gt; { doSomething(a, b); }, [a, b]); 返回值 memoizedCallback 是一个 memoized 回调。传递内联回调和一系列依赖项。useCallback将返回一个回忆的memoized版本，该版本仅在其中一个依赖项发生更改时才会更改。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的渲染（例如shouldComponentUpdate）时，这非常有用。 这个 Hook 的 API 不能够一两句解释的清楚，建议看一下这篇文章：useHooks 第一期：聊聊 hooks 中的 useCallback。里面介绍的比较详细。 4、useMemo语法 const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个memoized值。传递“创建”函数和依赖项数组。useMemo只会在其中一个依赖项发生更改时重新计算memoized值。此优化有助于避免在每个渲染上进行昂贵的计算。 useMemo在渲染过程中传递的函数会运行。不要做那些在渲染时通常不会做的事情。例如，副作用属于useEffect，而不是useMemo。 用法useMemo 可以帮助我们优化子组件的渲染，比如这种场景：在 A 组件中有两个子组件 B 和 C，当 A 组件中传给 B 的 props 发生变化时，A 组件状态会改变，重新渲染。此时 B 和 C 也都会重新渲染。其实这种情况是比较浪费资源的，现在我们就可以使用 useMemo 进行优化，B 组件用到的 props 变化时，只有 B 发生改变，而 C 却不会重新渲染。 例子： ExampleA.js12345678import React from 'react';export default (&#123; text &#125;) =&gt; &#123; console.log('Example A：', 'render'); return &lt;div&gt;Example A 组件：&#123; text &#125;&lt;/div&gt;&#125; ExampleB.js12345678import React from 'react';export default (&#123; text &#125;) =&gt; &#123; console.log('Example B：', 'render'); return &lt;div&gt;Example B 组件：&#123; text &#125;&lt;/div&gt;&#125; App.js12345678910111213141516171819202122import React, &#123; useState &#125; from 'react';import ExampleA from './ExampleA';import ExampleB from './ExampleB';import './App.css';export default () =&gt; &#123; const [a, setA] = useState('ExampleA'); const [b, setB] = useState('ExampleB'); return ( &lt;div&gt; &lt;ExampleA text=&#123; a &#125; /&gt; &lt;ExampleB text=&#123; b &#125; /&gt; &lt;br /&gt; &lt;button onClick=&#123; () =&gt; setA('修改后的 ExampleA') &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123; () =&gt; setB('修改后的 ExampleB') &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt; &lt;/div&gt; )&#125; 此时我们点击上面任意一个按钮，都会看到控制台打印了两条输出， A 和 B 组件都会被重新渲染。 现在我们使用 useMemo 进行优化 App.js123456789101112131415161718192021222324252627import React, &#123; useState, useMemo &#125; from 'react';import ExampleA from './ExampleA';import ExampleB from './ExampleB';import './App.css';export default () =&gt; &#123; const [a, setA] = useState('ExampleA'); const [b, setB] = useState('ExampleB');+ const exampleA = useMemo(() =&gt; &lt;ExampleA /&gt;, [a]);+ const exampleB = useMemo(() =&gt; &lt;ExampleB /&gt;, [b]); return ( &lt;div&gt;+ &#123;/* &lt;ExampleA text=&#123; a &#125; /&gt;+ &lt;ExampleB text=&#123; b &#125; /&gt; */&#125;+ &#123; exampleA &#125;+ &#123; exampleB &#125; &lt;br /&gt; &lt;button onClick=&#123; () =&gt; setA('修改后的 ExampleA') &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123; () =&gt; setB('修改后的 ExampleB') &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt; &lt;/div&gt; )&#125; 此时我们点击不同的按钮，控制台都只会打印一条输出，改变 a 或者 b，A 和 B 组件都只有一个会重新渲染。 5、useRef语法 const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。 从本质上讲，useRef就像一个“盒子”，可以在其.current财产中保持一个可变的价值。 useRef() Hooks 不仅适用于 DOM 引用。 “ref” 对象是一个通用容器，其 current 属性是可变的，可以保存任何值（可以是元素、对象、基本类型、甚至函数），类似于类上的实例属性。 注意：useRef() 比 ref 属性更有用。与在类中使用 instance(实例) 字段的方式类似，它可以 方便地保留任何可变值。 注意，内容更改时useRef 不会通知您。变异.current属性不会导致重新渲染。如果要在React将引用附加或分离到DOM节点时运行某些代码，则可能需要使用回调引用。 使用下面这个例子中展示了可以在 useRef() 生成的 ref 的 current 中存入元素、字符串 Example.js1234567891011121314151617181920212223242526272829303132333435import React, &#123; useRef, useState, useEffect &#125; from 'react'; export default () =&gt; &#123; // 使用 useRef 创建 inputEl const inputEl = useRef(null); const [text, updateText] = useState(''); // 使用 useRef 创建 textRef const textRef = useRef(); useEffect(() =&gt; &#123; // 将 text 值存入 textRef.current 中 textRef.current = text; console.log('textRef.current：', textRef.current); &#125;); const onButtonClick = () =&gt; &#123; // `current` points to the mounted text input element inputEl.current.value = \"Hello, useRef\"; &#125;; return ( &lt;&gt; &#123;/* 保存 input 的 ref 到 inputEl */&#125; &lt;input ref=&#123; inputEl &#125; type=\"text\" /&gt; &lt;button onClick=&#123; onButtonClick &#125;&gt;在 input 上展示文字&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt; &lt;/&gt; );&#125; 点击 在 input 上展示文字 按钮，就可以看到第一个 input 上出现 Hello, useRef；在第二个 input 中输入内容，可以看到控制台打印出对应的内容。 6、useLayoutEffect语法 useLayoutEffect(() =&gt; { doSomething }); 与 useEffect Hooks 类似，都是执行副作用操作。但是它是在所有 DOM 更新完成后触发。可以用来执行一些与布局相关的副作用，比如获取 DOM 元素宽高，窗口滚动距离等等。 进行副作用操作时尽量优先选择 useEffect，以免阻止视觉更新。与 DOM 无关的副作用操作请使用 useEffect。 用法用法与 useEffect 类似。 Example.js 12345678910111213141516171819import React, &#123; useRef, useState, useLayoutEffect &#125; from 'react'; export default () =&gt; &#123; const divRef = useRef(null); const [height, setHeight] = useState(100); useLayoutEffect(() =&gt; &#123; // DOM 更新完成后打印出 div 的高度 console.log('useLayoutEffect: ', divRef.current.clientHeight); &#125;) return &lt;&gt; &lt;div ref=&#123; divRef &#125; style=&#123;&#123; background: 'red', height: height &#125;&#125;&gt;Hello&lt;/div&gt; &lt;button onClick=&#123; () =&gt; setHeight(height + 50) &#125;&gt;改变 div 高度&lt;/button&gt; &lt;/&gt;&#125; 五、尝试编写自定义 Hooks这里我们就仿照官方的 useReducer 做一个自定义的 Hooks。 1、编写自定义 useReducer在 src 目录下新建一个 useReducer.js 文件： useReducer.js123456789101112import React, &#123; useState &#125; from 'react';function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; tip: Hooks 不仅可以在函数组件中使用，也可以在别的 Hooks 中进行使用。 2、使用自定义 useReducer好了，自定义 useReducer 编写完成了，下面我们看一下能不能正常使用呢？ 改写 Example 组件 Example.js12345678910111213141516171819202122232425262728293031import React from 'react';// 从自定义 useReducer 中引入import useReducer from './useReducer';const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;export default () =&gt; &#123; // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数 const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 五、Hooks 使用及编写规范 不要从常规 JavaScript 函数调用 Hooks; 不要在循环，条件或嵌套函数中调用 Hooks; 必须在组件的顶层调用 Hooks; 可以从 React 功能组件调用 Hooks; 可以从自定义 Hooks 中调用 Hooks; 自定义 Hooks 必须使用 use 开头，这是一种约定; 六、使用 React 提供的 ESLint 插件根据上一段所写，在 React 中使用 Hooks 需要遵循一些特定规则。但是在代码的编写过程中，可能会忽略掉这些使用规则，从而导致出现一些不可控的错误。这种情况下，我们就可以使用 React 提供的 ESLint 插件：eslint-plugin-react-hooks。下面我们就看看如何使用吧。 安装 ESLint 插件1$ npm install eslint-plugin-react-hooks --save 在 .eslintrc 中使用插件123456789101112// Your ESLint configuration&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\", // Checks rules of Hooks \"react-hooks/exhaustive-deps\": \"warn\" // Checks effect dependencies &#125;&#125; 七、参考文档React 官网 React Hooks FAQ","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://beichensky.github.io/tags/Hooks/"}]},{"title":"Webpack3 升级到 webpack4 时遇到的问题汇总","date":"2019-04-04T02:55:21.000Z","path":"20190404/webpack-update/","text":"项目在对 webpack 的版本升级的过程中，出现了各种各样的问题，今天就把其中比较典型的问题总结一下，作为记录。 一、MissingDeps.some is not a function错误提示中，提示 react-dev-utils 包有问题，TypeError: MissingDeps.some is not a function。 解决方案：升级 react-utils-dev 包到 6.0.0 版本之后即可。将 package.json 中的 react-utils-dev 依赖删除掉，重新安装匹配版本插件。1$ npm install react-utils-dev --save-dev 二、this.htmlWebpackPlugin.getHooks is not a function运行项目时，提示错误：this.htmlWebpackPlugin.getHooks is not a function 解决方案： 安装与 webpack4 匹配的 html-webpack-plugin 插件：npm install html-webpack-plugin@next --save-dev 修改 webpack 配置文件：12- new InterpolateHtmlPlugin(env.raw),+ new InterpolateHtmlPlugin(HtmlWebpackPlugin, env.raw), 三、When specified, “proxy” in package.json must be a string运行报错提示为：123When specified, \"proxy\" in package.json must be a string.Instead, the type of \"proxy\" was \"object\".Either remove \"proxy\" from package.json, or make it a string. 错误出现原因：使用 create-react-app 搭建脚手架，在 CRA2.X 升级之后，对 proxy 的设置作了修改。 当使用 proxy 为字符串时不需要修改，可以直接在 package.json中添加 proxy 字段，例如：&quot;proxy&quot;: &quot;http://localhost:4000&quot;, 当使用多个 proxy 时，就需要结合 http-proxy-middleware 进行使用。 create-react-app 官网说明地址 解决方案： 安装 http-proxy-middleware 插件：123$ npm install http-proxy-middleware --save$ # 或$ yarn add http-proxy-middleware 创建 src/setupProxy.js 并将以下内容放入该文件中(将路由和 target 值修改为自己需要的即可):1234567const proxy = require('http-proxy-middleware');module.exports = function(app) &#123; app.use(proxy('/api', &#123; target: 'http://localhost:5000/api' &#125;)); app.use(proxy('/test', &#123; target: 'http://localhost:4000/test' &#125;)); ...&#125;; 注意： 无需在任何位置导入此文件。 它在启动开发服务器时会自动注册。 注意： 此文件仅支持 Node 的 JavaScript 语法。 请务必仅使用支持的语言特性（即不支持 Flow ，ES Modules 等）。 注意： 将路径传递给代理函数允许你在路径上使用 globbing 和/或 模式匹配，这比 express 路由匹配更灵活。","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"},{"name":"前端开发","slug":"前端开发","permalink":"https://beichensky.github.io/tags/前端开发/"}]},{"title":"react-dnd 用法详解","date":"2019-03-21T01:46:43.000Z","path":"20190321/react-dnd/","text":"本文详细讲解了 react-dnd 的 API 以及用法，并且附上了可供参考的 Demo，希望能够给需要的朋友提供一下帮助。 一、概念React DnD 是一组 React 高阶组件，使用的时候只需要使用对应的 API 将目标组件进行包裹，即可实现拖动或接受拖动元素的功能。将拖动的事件转换成对象中对应状态的形式，不需要开发者自己判断拖动状态，只需要在传入的 spec 对象中各个状态属性中做对应处理即可。刚刚接触可能难以理解，真正熟悉用法之后会感觉很方便。 二、DragSource：使组件能够被拖拽使用 DragSource 包裹住组件，使其可以进行拖动。 使用方式12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';import &#123; DragSource &#125; from 'react-dnd';const spec = &#123; beginDrag(props, monitor, component) &#123; // 这里 return 出去的对象属性自行选择，这里只是用 id 作为演示 return &#123; id: props.id &#125; &#125; endDrag(props, monitor, component) &#123; ... &#125; canDrag(props, monitor) &#123; ... &#125; isDragging(props, monitor) &#123; ... &#125;&#125;const collect = (connect, monitor) =&gt; (&#123; // 这里返回一个对象，会将对象的属性都赋到组件的 props 中去。这些属性需要自己定义。 connectDropTarget: connect.dropTarget(), id: monitor.getItem().id&#125;)@DragSource(type, spec, collect)class MyComponent extends Component &#123; /* ... */&#125;export default MyComponent; 参数讲解： type: 必填。字符串，ES6符号或返回给定组件的函数props。只有为相同类型注册的 drop targets 才会对此拖动源生成的项目做出反应 spec：必填。一个普通的JavaScript对象，上面有一些允许的方法。它描述了拖动源如何对拖放事件做出反应。 collect：必填。收集功能。它应该返回一个普通的对象注入你的组件。它接收两个参数：connect和monitor。 options：可选的。一个普通的对象。 spec 对象中的方法 beginDrag(props, monitor, component)：必填。当拖动开始时，beginDrag 被调用。您必须返回描述被拖动数据的纯 JavaScript 对象。您返回的内容会被放置到 monitor.getItem() 获取到的对象中。 endDrag(props, monitor, component)：可选的。当拖动停止时，endDrag 被调用。对于每个 beginDrag，endDrag 都会对应。 canDrag(props, monitor)： 可选的。用它来指定当前是否允许拖动。如果您想要始终允许它，只需省略此方法即可。注意：您可能无法调用monitor.canDrag() 此方法。 isDragging(props, monitor)： 可选的。默认情况下，仅启动拖动操作的拖动源被视为拖动。注意：您可能无法调用 monitor.isDragging() 此方法。 方法中的参数 props, monitor, component props：当前组件的 props monitor：一个 DragSourceMonitor 实例。使用它来查询有关当前拖动状态的信息，例如当前拖动的项目及其类型，当前和初始坐标和偏移，以及它是否已被删除。 component：指定时，它是组件的实例。使用它来访问底层DOM节点以进行位置或大小测量，或调用 setState 以及其他组件方法。isDragging、 canDrag 方法里获取不到 component 这个参数，因为它们被调用时实例可能不可用 collect 中的 connect 和 monitor 参数 connect: 一个 DragSourceConnector 实例。它有两种方法：dragPreview()和dragSource()。 dragSource() =&gt; (elementOrNode, options?)：常用方法，返回一个函数，传递给组件用来将 source DOM 和 React DnD Backend 连接起来 dragPreview()：返回一个函数，传递给组件用来将拖动时预览的 DOM 节点 和 React DnD Backend 连接起来 monitor：一个 DragSourceMonitor 实例。包含下面各种方法： 方法 含义 canDrag() 是否可以被拖拽。如果没有正在进行拖动操作，则返回 true isDragging() 是否正在被拖动。如果正在进行拖动操作，则返回 true getItemType() 返回标识当前拖动项的类型的字符串或ES6符号。 如果没有拖动项目，则返回 null getItem() 返回表示当前拖动项的普通对象。 每个拖动源都必须通过从其beginDrag（）方法返回一个对象来指定它。 如果没有拖动项目，则返回 null getDropResult() 返回表示最后记录的放置 drop result 对象 didDrop() 如果某个 drop target 处理了 drop 事件，则返回 true，否则返回 false。即使 target 没有返回 drop 结果，didDrop() 也会返回true。 在 endDrag() 中使用它来测试任何放置目标是否已处理掉落。 如果在 endDrag() 之外调用，则返回 false getInitialClientOffset() 返回当前拖动操作开始时指针的{x，y} client 偏移量。 如果没有拖动项目，则返回 null getInitialSourceClientOffset() 返回当前拖动操作开始时 drag source 组件的根DOM节点的{x，y}client 偏移量。 如果没有拖动项目，则返回 null getClientOffset() 拖动操作正在进行时，返回指针的最后记录的{x，y}client 偏移量。 如果没有拖动项目，则返回 null getDifferenceFromInitialOffset() 返回当前拖动操作开始时鼠标的最后记录 client 偏移量与 client 偏移量之间的{x，y}差异。 如果没有拖动项目，则返回 null getSourceClientOffset() 返回 drag source 组件的根DOM节点的预计{x，y} client 偏移量，基于其在当前拖动操作开始时的位置以及移动差异。 如果没有拖动项目，则返回 null 三、DropTarget：使组件能够放置拖拽组件使用 DropTarget 包裹住组件，使其对拖动，悬停或 dropped 的兼容项目做出反应。 使用方式12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import &#123; DropTarget &#125; from 'react-dnd';const spec = &#123; drop(props, monitor, component) &#123; // 这里 return 出去的对象属性自行选择，这里只是用 id 作为演示 return &#123; id: props.id &#125; &#125; hover(props, monitor, component) &#123; ... &#125; canDrop(props, monitor) &#123; ... &#125;&#125;const collect = (connect, monitor) =&gt; (&#123; // 这里返回一个对象，会将对象的属性都赋到组件的 props 中去。这些属性需要自己定义。 connectDropTarget: connect.dropTarget()&#125;)@DropTarget(type, spec, collect)class MyComponent extends Component &#123; /* ... */&#125;export default MyComponent; 参数讲解： type: 必填。字符串，ES6符号或返回给定组件的函数props。此放置目标仅对指定类型的 drag sources 项目做出反应 spec：必填。一个普通的JavaScript对象，上面有一些允许的方法。它描述了放置目标如何对拖放事件做出反应。 collect：必填。收集功能。它应该返回一个普通的道具对象注入你的组件。它接收两个参数：connect 和 monitor。 options：可选的。一个普通的对象。 spec 对象中的方法 drop(props, monitor, component)： 可选的。在目标上放置兼容项目时调用。可以返回 undefined 或普通对象。如果返回一个对象，它将成为放置结果，可以使用 monitor.getDropResult() 获取到。 hover(props, monitor, component)： 可选的。当项目悬停在组件上时调用。您可以检查 monitor.isOver({ shallow: true }) 以测试悬停是仅发生在当前目标上还是嵌套上。 canDrop(props, monitor)： 可选的。使用它来指定放置目标是否能够接受该项目。如果想要始终允许它，只需省略此方法即可。 文档没有提供按目的处理进入或离开事件的方法。而是 monitor.isOver() 从收集函数返回调用结果，以便我们可以使用 componentDidUpdateReact 钩子函数来处理组件中的进入和离开事件。 方法中的参数 props, monitor, component props：当前组件的 props monitor：一个 DropTargetMonitor 实例。使用它来查询有关当前拖动状态的信息，例如当前拖动的项目及其类型，当前和初始坐标和偏移，是否超过当前目标，以及是否可以删除它。 component：指定时，它是组件的实例。使用它来访问底层DOM节点以进行位置或大小测量，或调用 setState 以及其他组件方法。canDrag 方法里获取不到 component 这个参数，因为它们被调用时实例可能不可用。 collect 中的 connect 和 monitor 参数 connect: 一个 DropTargetConnector 实例。它只有一种 dropTarget() 方法。 dropTarget() =&gt; (elementOrNode)：常用方法，返回一个函数，传递给组件用来将 target DOM 和 React DnD Backend 连接起来。通过{ connectDropTarget: connect.dropTarget() }从收集函数返回，可以将任何React元素标记为可放置节点。 monitor：一个 DropTargetMonitor 实例。包含下面各种方法： 方法 含义 canDrop() 是否可以被放置。如果正在进行拖动操作，则返回true isOver(options) drag source 是否悬停在 drop target 区域。可以选择传递{ shallow: true }以严格检查是否只有 drag source 悬停，而不是嵌套目标 getItemType() 返回标识当前拖动项的类型的字符串或ES6符号。如果没有拖动项目则返回 null getItem() 返回表示当前拖动项的普通对象，每个拖动源都必须通过从其beginDrag()方法返回一个对象来指定它。如果没有拖动项目则返回 null getDropResult() 返回表示最后记录的放置 drop result 对象 didDrop() 如果某个 drop target 处理了 drop 事件，则返回 true，否则返回 false。即使 target 没有返回 drop 结果，didDrop() 也会返回true。 在 endDrag() 中使用它来测试任何放置目标是否已处理掉落。 如果在 endDrag() 之外调用，则返回 false getInitialClientOffset() 返回当前拖动操作开始时指针的{x，y} client 偏移量。 如果没有拖动项目，则返回 null getInitialSourceClientOffset() 返回当前拖动操作开始时 drag source 组件的根DOM节点的{x，y}client 偏移量。 如果没有拖动项目，则返回 null getClientOffset() 拖动操作正在进行时，返回指针的最后记录的{x，y}client 偏移量。 如果没有拖动项目，则返回 null getDifferenceFromInitialOffset() 返回当前拖动操作开始时鼠标的最后记录 client 偏移量与 client 偏移量之间的{x，y}差异。 如果没有拖动项目，则返回 null getSourceClientOffset() 返回 drag source 组件的根DOM节点的预计{x，y} client 偏移量，基于其在当前拖动操作开始时的位置以及移动差异。 如果没有拖动项目，则返回 null 四、DragDropContext &amp; DragDropContextProvider 注意： 使用 DragSource 和 DropTarget 包裹的组件，必须放在： DragDropContext 包裹的根组件内部，或者 DragDropContextProvider 根标签的内部。 DragDropContext使用 DragDropContext 包装应用程序的根组件以启用 React DnD。 用法12345678910import React, &#123; Component &#125; from 'react';import HTML5Backend from 'react-dnd-html5-backend';import &#123; DragDropContext &#125; from 'react-dnd';@DragDropContext(HTML5Backend)class YourApp extends Component &#123; /* ... */&#125;export default YourApp; 参数 backend：必填。一个 React DnD 后端。除非您正在编写自定义的，否则建议使用 React DnD 附带的 HTML5Backend。 context：backend 依赖。用于自定义后端的上下文对象。例如，HTML5Backend可以为iframe场景注入自定义窗口对象。 DragDropContextProvider作为 DragDropContext 的替代方法，您可以使用 DragDropContextProvider 元素为应用程序启用React DnD。与 DragDropContext 类似，这可以通过 backendprop 注入后端，但也可以注入一个 window 对象。 用法12345678910111213import React, &#123; Component &#125; from 'react';import HTML5Backend from 'react-dnd-html5-backend';import &#123; DragDropContextProvider &#125; from 'react-dnd';export default class YourApp extends Component &#123; render() &#123; return ( &lt;DragDropContextProvider backend=&#123;HTML5Backend&#125;&gt; /* ... */ &lt;/DragDropContextProvider&gt; ) &#125;&#125; 参数 backend：必填。一个 React DnD 后端。除非您正在编写自定义的，否则建议使用 React DnD 附带的 HTML5Backend。 context：backend 依赖。用于自定义后端的上下文对象。例如，HTML5Backend可以为iframe场景注入自定义窗口对象。 五、react-dnd 的简单示例本示例参照官方的 Dustbin 示例进行讲解。 项目准备当前项目使用 create-react-app 脚手架进行搭建，而且使用 react-dnd 时都是使用装饰器语法进行编写。所以需要先在项目里添加一些配置。 启用装饰器的配置方式可以参考我的上一篇文章：在 create-react-app 中启用装饰器语法。 新建 components 文件夹，用来存放编写的组件。新建 types 文件夹，用来存放 type 字符串常量，在 types 目录下创建 index.js 文件声明对应的 type 值。 types/index.js123export default &#123; BOX: 'box'&#125; 所以当前项目 src 目录下文件结构如下：1234567src├── components/├── types/ └── index.js├── App.js├── index.css└── index.js 创建 Box 组件，作为 DragSource在 components 目录下，创建 Box.js 文件，编写 Box 组件，使其可以进行拖动 components/Box.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import React from 'react';import PropTypes from 'prop-types';import &#123; DragSource &#125; from 'react-dnd';import ItemTypes from '../types';const style = &#123; border: '1px dashed gray', backgroundColor: 'white', padding: '0.5rem 1rem', marginRight: '1.5rem', marginBottom: '1.5rem', cursor: 'move', float: 'left',&#125;const boxSource = &#123; /** * 开始拖拽时触发当前函数 * @param &#123;*&#125; props 组件的 props */ beginDrag(props) &#123; // 返回的对象可以在 monitor.getItem() 中获取到 return &#123; name: props.name, &#125; &#125;, /** * 拖拽结束时触发当前函数 * @param &#123;*&#125; props 当前组件的 props * @param &#123;*&#125; monitor DragSourceMonitor 对象 */ endDrag(props, monitor) &#123; // 当前拖拽的 item 组件 const item = monitor.getItem() // 拖拽元素放下时，drop 结果 const dropResult = monitor.getDropResult() // 如果 drop 结果存在，就弹出 alert 提示 if (dropResult) &#123; alert(`You dropped $&#123;item.name&#125; into $&#123;dropResult.name&#125;!`) &#125; &#125;,&#125;@DragSource( // type 标识，这里是字符串 'box' ItemTypes.BOX, // 拖拽事件对象 boxSource, // 收集功能函数，包含 connect 和 monitor 参数 // connect 里面的函数用来将 DOM 节点与 react-dnd 的 backend 建立联系 (connect, monitor) =&gt; (&#123; // 包裹住 DOM 节点，使其可以进行拖拽操作 connectDragSource: connect.dragSource(), // 是否处于拖拽状态 isDragging: monitor.isDragging(), &#125;),)class Box extends React.Component &#123; static propTypes = &#123; name: PropTypes.string.isRequired, isDragging: PropTypes.bool.isRequired, connectDragSource: PropTypes.func.isRequired &#125; render() &#123; const &#123; isDragging, connectDragSource &#125; = this.props const &#123; name &#125; = this.props const opacity = isDragging ? 0.4 : 1 // 使用 connectDragSource 包裹住 DOM 节点，使其可以接受各种拖动 API // connectDragSource 包裹住的 DOM 节点才可以被拖动 return connectDragSource &amp;&amp; connectDragSource( &lt;div style=&#123;&#123; ...style, opacity &#125;&#125;&gt; &#123;name&#125; &lt;/div&gt; ); &#125;&#125;export default Box; 创建 Dustbin 组件，作为 DropTarget在 components 目录下，创建 Dustbin.js 文件，编写 Dustbin 组件，使其可以接受对应的拖拽组件。 components/Dustbin.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React from 'react';import PropTypes from 'prop-types';import &#123; DropTarget &#125; from 'react-dnd';import ItemTypes from '../types';const style = &#123; height: '12rem', width: '12rem', marginRight: '1.5rem', marginBottom: '1.5rem', color: 'white', padding: '1rem', textAlign: 'center', fontSize: '1rem', lineHeight: 'normal', float: 'left',&#125;const boxTarget = &#123; // 当有对应的 drag source 放在当前组件区域时，会返回一个对象，可以在 monitor.getDropResult() 中获取到 drop: () =&gt; (&#123; name: 'Dustbin' &#125;)&#125;@DropTarget( // type 标识，这里是字符串 'box' ItemTypes.BOX, // 接收拖拽的事件对象 boxTarget, // 收集功能函数，包含 connect 和 monitor 参数 // connect 里面的函数用来将 DOM 节点与 react-dnd 的 backend 建立联系 (connect, monitor) =&gt; (&#123; // 包裹住 DOM 节点，使其可以接收对应的拖拽组件 connectDropTarget: connect.dropTarget(), // drag source是否在 drop target 区域 isOver: monitor.isOver(), // 是否可以被放置 canDrop: monitor.canDrop(), &#125;))class Dustbin extends React.Component &#123; static propTypes = &#123; canDrop: PropTypes.bool.isRequired, isOver: PropTypes.bool.isRequired, connectDropTarget: PropTypes.func.isRequired &#125; render() &#123; const &#123; canDrop, isOver, connectDropTarget &#125; = this.props; const isActive = canDrop &amp;&amp; isOver; let backgroundColor = '#222'; // 拖拽组件此时正处于 drag target 区域时，当前组件背景色变为 darkgreen if (isActive) &#123; backgroundColor = 'darkgreen'; &#125; // 当前组件可以放置 drag source 时，背景色变为 pink else if (canDrop) &#123; backgroundColor = 'darkkhaki'; &#125; // 使用 connectDropTarget 包裹住 DOM 节点，使其可以接收对应的 drag source 组件 // connectDropTarget 包裹住的 DOM 节点才能接收 drag source 组件 return connectDropTarget &amp;&amp; connectDropTarget( &lt;div style=&#123;&#123; ...style, backgroundColor &#125;&#125;&gt; &#123;isActive ? 'Release to drop' : 'Drag a box here'&#125; &lt;/div&gt; ); &#125;&#125;export default Dustbin; 在 App.js 文件中使用 DragDropContextApp.js123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';import &#123; DragDropContext &#125; from 'react-dnd';import HTMLBackend from 'react-dnd-html5-backend';import Dustbin from './components/Dustbin';import Box from './components/Box';// 将 HTMLBackend 作为参数传给 DragDropContext@DragDropContext(HTMLBackend)class App extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; paddingLeft: 200, paddingTop: 50 &#125;&#125;&gt; &lt;div style=&#123;&#123; overflow: 'hidden', clear: 'both' &#125;&#125;&gt; &lt;Box name=\"Glass\" /&gt; &lt;Box name=\"Banana\" /&gt; &lt;Box name=\"Paper\" /&gt; &lt;/div&gt; &lt;div style=&#123;&#123; overflow: 'hidden', clear: 'both' &#125;&#125;&gt; &lt;Dustbin /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 运行项目，查看效果运行项目：1$ npm run start 浏览器会自动打开 http://localhost:3000/ 窗口，此时可以操作浏览器上的 Box 组件，结合项目代码，查看效果。预览效果如下： 预览效果 六、本文 Demo 地址react-dnd-dustbin 欢迎 Star！谢谢！ 七、参考链接react-dnd 官方文档拖拽组件：React DnD 的使用","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"react-dnd","slug":"react-dnd","permalink":"https://beichensky.github.io/tags/react-dnd/"},{"name":"拖拽组件","slug":"拖拽组件","permalink":"https://beichensky.github.io/tags/拖拽组件/"}]},{"title":"在 create-react-app 中启用装饰器语法","date":"2019-03-20T10:15:17.000Z","path":"20190320/cra-decorators/","text":"本文简单介绍了一下如何在 create-react-app 中启用装饰器语法的两种方式。 方式一：暴露 create-react-app 的配置暴露出 create-react-app 的所有配置运行命令：1$ npm run eject 项目中就会展示出各种 config 配置文件。 在 babel 中添加 plugins 配置在 package.json 文件中找到 babel 的配置，添加如下代码即可： package.json1234567891011\"babel\": &#123; \"presets\": [ \"react-app\" ],+ \"plugins\": [+ [+ \"@babel/plugin-proposal-decorators\",+ &#123; \"legacy\": true &#125;+ ]+ ]&#125; 重新运行项目，即可正常使用装饰器语法。 create-react-app 脚手架中已经安装了 @babel/plugin-proposal-decorators 插件，如果是自己配置的脚手架，请先安装插件：npm install @babel/plugin-proposal-decorators --save-dev 方式二：直接在项目的 node-modules 中添加配置打开项目的 node_modules 文件夹，找到 babel-preset-react-app 目录。打开目录下 create.js 文件。找到 plugins 属性配置的地方，修改如下配置即可：123456789-isTypeScriptEnabled &amp;&amp; [- require('@babel/plugin-proposal-decorators').default,- false,-],+[+ require('@babel/plugin-proposal-decorators').default,+ &#123; legacy: true &#125;,+], 不建议使用方式二，因为一旦需要重新安装 node_modules， 就需要再去 babel-preset-react-app 里面添加一次配置。 总结上面两种方式使用了之后，均可在项目中正常使用装饰器语法，但是使用装饰器时。可能还是会出现红线报错提示，此时在 VSCode 的配置文件中（Visual Studio Code左下角的设置按钮(或者文件&gt;首选项&gt;设置)）添加如下配置即可： setting.json1\"javascript.implicitProjectConfig.experimentalDecorators\": true, 建议使用第一种方式，虽然可能比较麻烦，需要暴露出所有的配置。但是第二种方式，如果只是自己进行一些小的 Demo 测试还好。不然的话，一旦需要重新安装 node_modules，就需要再重新去 babel-preset-react-app 里面添加一次配置。 参考链接redux connect的装饰器问题","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"create-react-app","slug":"create-react-app","permalink":"https://beichensky.github.io/tags/create-react-app/"}]},{"title":"nvm 和 nrm 的安装与使用","date":"2019-03-20T10:14:56.000Z","path":"20190320/nvm-nrm-install/","text":"本文介绍了如何使用 nvm 切换 node 和 npm 版本，以及如何使用 nrm 切换 npm 下载源。 一、NVMNvm 可以切换 node 与 npm 版本，在开发不同项目时，可能会用到不同的 node 与 npm 版本，所以使用 nvm 可以方便的在不同 node 与 npm 版本之间进行切换。 写在前面 在安装 Nvm 之前，先将之前安装的 node 进行卸载。否则可能会出现无法切换 node 版本的问题 将之前安装的全局插件删除掉，否则可能会导致 nvm 命令不起作用。文件目录如下12C:\\Users\\Administrator\\AppData\\Roaming\\npmC:\\Users\\Administrator\\AppData\\Roaming\\npm-cache nvm 的安装下载 nvm 插件，安装地址： Github： Download nvm-windows （nvm-setup.zip）。 下载完成，解压文件之后，双击进行安装： 设置 nvm 安装目录，这里的路径可以根据自己的需要进行填写，不要包含中文名 第一步 设置 nodejs 各版本安装目录。这个目录是 nvm install node版本 时存放 nodejs 的目录 第二步 安装完成，在命令行输入：nvm version，查看到对应的版本号，说明 nvm 安装成功了。 nvm 常用命令 nvm install latest：安装最新的 nodejs 版本 nvm install 11.12.0：安装对应的 nodejs 版本 nvm uninstall 11.12.0：卸载对应的 nodejs 版本 nvm list available：列出所有可用的 nodejs 版本 nvm list：查看 nvm 列出已经安装的 nodejs 版本 nvm use 11.12.0：使用对应的 nodejs 版本 更多命令在命令行输入 nvm 即可查看 常见问题 提示 nvm 不是内部或外部命令的问题 将之前 npm 安装的全局包删除掉。文件目录如下：12C:\\Users\\Administrator\\AppData\\Roaming\\npmC:\\Users\\Administrator\\AppData\\Roaming\\npm-cache nvm 切换 node 版本无效的问题 卸载原来安装的 node 版本与全局安装的包 nvm 下载速度慢的问题 在 nvm 安装目录下找到 settings.txt 文件，添加下面两行代码：1234root: D:\\DevTools\\NVM\\nvmpath: D:\\DevTools\\NVM\\nodejs+ node_mirror: https://npm.taobao.org/mirrors/node/+ npm_mirror: https://npm.taobao.org/mirrors/npm/ 二、NRM在使用 npm 的过程中，可能插件安装速度比较慢，我们可能会使用淘宝源对插件进行下载安装。或者在公司内部，有一些私有的插件，需要使用公司的源才可以下载。这种情况，我们就需要设置不同的源来进行下载。每次手动设置相对比较麻烦。而 nrm 可以很好的解决这个问题。 nrm 的安装12# 全局安装 nrm$ npm install nrm -g 安装完成后，输入命令 nrm ls，可以看到默认已经有了 6 个源（带 * 号的为当前使用的源）123456* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 输入 nrm use taobao，即切换 registry 到 taobao，即可使用淘宝的源进行插件的安装下载了。 nrm 常用命令 nrm ls ：查看所有配置好的源以及对应名称 nrm add company http://npm.xxx.cn：添加源，company 是名称，可以自行命名，后面是源的 url 地址 nrm del company ：删除源，根据名称 company 可以删除对应的源 nrm test [registry] ：测试源的速度，不加对应的 registry 名称，测试所有源的速度，添加对应的名称，比如 company，就是测试 company 对应的源的速度 nrm use company ：切换源，即可使用 company 对应名称的源 更多命令在命令行输入 nrm 即可查看 三、额外知识点 安装 cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org 设置 npm 全局包的安装路径（如果不想自己控制路径就不需要做下面这些操作）： 执行命令：npm config set prefix &quot;D:\\DevTools\\Nvm\\npm-global&quot; 设置环境变量：将 Path 中： C:\\\\Users\\\\Administrator\\\\AppData\\\\Roaming\\\\npm 修改为 D:\\\\DevTools\\\\Nvm\\\\npm-global 查看已经安装的全局包：npm ls -g --depth=0 手动设置 npm 源 npm config get registry ： 查看 npm 当前源 npm config set registry https://registry.npm.taobao.org/：设置 npm 源为淘宝 npm install --registry=https://registry.npm.taobao.org ：使用特定源安装所有依赖的包 npm install express --registry=https://registry.npm.taobao.org：使用特定源安装 express 包 四、参考链接 Windows 下安装 nvm 管理 nodejs 版本 npm源管理器nrm使用教程","tags":[{"name":"nvm","slug":"nvm","permalink":"https://beichensky.github.io/tags/nvm/"},{"name":"nrm","slug":"nrm","permalink":"https://beichensky.github.io/tags/nrm/"},{"name":"node","slug":"node","permalink":"https://beichensky.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://beichensky.github.io/tags/npm/"}]},{"title":"JavaScript 项目迁移到 TypeScript 步骤以及遇到的问题","date":"2019-03-15T03:13:35.000Z","path":"20190315/js-project-ts/","text":"本文讲述了如何将 JavaScript 项目迁移到 TypeScript 上，以及如何在项目中添加 TypeScript 配置，编写 TypeScript 代码。 一、插件安装安装项目所需插件，一般对应的模块都会有对应的 @types 插件可以使用。不知道的是否需要安装对应的 @types 插件的话，可以到 TypeSearch 进行查找。 12345678# 安装项目中使用的插件$ npm install typescript ts-jest ts-loader @types/enzyme @types/jest @types/node @types/react @types/react-dom --save-dev# 安装 tslint 相关插件$ npm install tslint tslint-config-prettier tslint-react --save# 安装 webpack 中对 typescript 支持的插件$ npm install fork-ts-checker-webpack-plugin tsconfig-paths-webpack-plugin --save-dev 二、添加 tsconfig.json 配置文件在项目根目录下添加 tsconfig.json 配置文件。tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 tsconfig.json1234567891011121314151617181920212223242526272829303132333435&#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", \"outDir\": \"build/dist\", \"module\": \"commonjs\", \"target\": \"es5\", \"lib\": [\"es6\", \"dom\"], \"sourceMap\": true, \"allowJs\": true, \"jsx\": \"react\", \"moduleResolution\": \"node\", \"rootDir\": \"src\", \"noImplicitReturns\": true, \"noImplicitThis\": true, \"noImplicitAny\": true, \"strictNullChecks\": true, \"experimentalDecorators\": true &#125;, \"exclude\": [ \"config\", \"public\", \"node_modules\", \"build\", \"dist\", \"scripts\", \"acceptance-tests\", \"webpack\", \"jest\", \"src/setupTests.ts\", \"jest.config.js\" ], \"types\": [ \"typePatches\" ]&#125; 再添加一个 tsconfig.prod.json 文件，用来在项目生产环境配置中使用。 tsconfig.prod.json123&#123; \"extends\": \"./tsconfig.json\"&#125; 这里直接继承类 tsconfig.json 文件中的内容。也可以添加一些不同的配置。 三、为项目添加 TsLint 配置文件在项目根目录下添加 tslint.json 文件。tslint.json 中配置了开发过程中的规则。 tslint.json123456789101112131415161718192021222324252627282930&#123; \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"], \"defaultSeverity\": \"warning\", \"rules\": &#123; // 对象属性是否按照顺序进行编写 \"object-literal-sort-keys\": false, // jsx 中是否允许使用 lambda 语法 \"jsx-no-lambda\": false, // 引入模块是否需要按照字母顺序 \"ordered-imports\": false, // 不允许打印 console \"no-console\": false, // 不允许隐式的依赖模块，比如引用别名中的模块 \"no-implicit-dependencies\": false, // 是否必须使用 === 取代 == \"triple-equals\": false, // 对象成员是否需要按照顺序进行编写 \"member-ordering\": false &#125;, \"linterOptions\": &#123; \"exclude\": [ \"config/**/*.js\", \"webpack/**/*.js\", \"node_modules/**/*.ts\", \"coverage/lcov-report/*.js\", \"src/**/*.js\", \"src/**/*.jsx\" ] &#125;&#125; extends：继承了哪些规则 defaultSeverity：TsLint 严重性等级，可以是 warning 或是 error rules：配置规则，可以修改一些默认的 TsLint 规则 linterOptions.exclude：排除掉不需要进行 TsLint 检查的文件 更多 TsLint 的规则配置可以参考 TsLint 四、在 webpack 配置文件中添加 TypeScript 配置在 webpack 开发环境中添加配置使用插件在 webpack 配置文件中使用插件： 在 plugins 中使用 ForkTsCheckerWebpackPlugin 插件 注意： 在 resolve.plugin 中使用 TsconfigPathsPlugin 插件 webpack.config.dev.js12345678910111213141516171819202122232425...const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');const TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin');...module.exports = &#123; ... plugins: [ new ForkTsCheckerWebpackPlugin(&#123; async: false, watch: path.resolve(__dirname, '../src'), tsconfig: path.resolve(__dirname, '../tsconfig.json'), tslint: path.resolve(__dirname, '../tslint.json') &#125;) ], resolve: &#123; ... plugins: [ new TsconfigPathsPlugin(&#123; configFile: path.resolve(__dirname, '../tsconfig.json') &#125;) ], ... &#125;&#125; 在 webpack 中添加 TypeScript 的 rules 配置使用 ts-loader webpack.config.dev.js12345678910111213141516171819202122...module.exports = &#123; ... rules: [ &#123; test: /\\.(ts|tsx)$/, include: path.resolve(__dirname, '../src'), use: [ &#123; loader: require.resolve('ts-loader'), options: &#123; // disable type checker - we will use it in fork plugin transpileOnly: true &#125; &#125; ] &#125;, ... ], ...&#125; 在 webpack 生产环境中添加配置使用方式和上面 在 webpack 开发环境中添加配置 的方式一致。唯一不同的就是在使用插件的时候，将 tsconfig.json 修改为 tsconfig.prod.json webpack.prod.config.js1234567891011121314151617181920module.exports = &#123; ... plugins: [ new ForkTsCheckerWebpackPlugin(&#123; async: false, watch: path.resolve(__dirname, '../src'), tsconfig: path.resolve(__dirname, '../tsconfig.prod.json'), tslint: path.resolve(__dirname, '../tslint.json') &#125;) ], resolve: &#123; ... plugins: [ new TsconfigPathsPlugin(&#123; configFile: path.resolve(__dirname, '../tsconfig.prod.json') &#125;) ], ... &#125;&#125; 五、遇到的问题装饰器使用问题本来配置好的装饰器，使用的好好的，配置完 TypeScript 之后，却发现编辑器对应文件里面报红线错误提示：1Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning. 解决办法：在根目录下的 tsconfig.json 文件里面添加对应配置即可 tsconfig.json12345&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true &#125;&#125; 生命周期提示红线报错问题使用函数方式创建组件没有问题，使用类的方式创建时，生命周期函数下面都会报红线提示错误：Parsing error: Unexpected token。 解决办法：将 VSCode 设置中的配置项进行修改即可1234567\"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"typescript\", // 下面这个对使用 ts 编写的 React 组件进行 ESLint 的文件检查暂时先去掉 // \"typescriptreact\" ] tsconfig.json 文件内部报错问题tsconfig.json 文件内部报错，第一行大括号那里就出现错误，错误提示类似下面这种：123'c:/xxx/config/dev.js' is not under 'rootDir' 'c:/xxx/src'. 'rootDir' is expected to contain all source files.\"JSON schema for the TypeScript compiler's configuration file 这里我 tsconfig.json 文件中我配置的 rootDir 是 src 目录，但是在 exclude 属性里，我没有将 src 的同级目录 config 给排除，所以就会提示这个错误，在 tsconfig.json 中添加配置即可： tsconfig.json123456&#123; \"exclude\": [ ... \"config\" ],&#125; 出现类似的问题，提示哪个目录不在 rootDir 目录下，就将哪个目录添加到 exclude 属性里。 webpack 中配置的别名，在 ts 文件中不识别的问题在 webpack 中为部分目录配置了别名，可以直接目录，会自动到对应目录下寻找模块，在 js 文件中可以正常使用，但是在 ts 文件中却会报错：Cannot find module &#39;utils/xxx&#39;。 解决办法：这时需要在 tsconfig.json文件中单独配置 paths 列表，对对应的路径进行映射： tsconfig.json1234567891011121314&#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", \"paths\": &#123; \"src/*\": [ \"src/*\" ], \"utils/*\": [ \"src/utils/*\" ] &#125; &#125;, ...&#125; 这样启动项目就不会再报错，但是在 ts 文件里还是会有红线报错提醒，此时还需要在 tslint.json 文件中添加 rules 配置： tslint.json1234567&#123; ... \"rules\": &#123; \"no-implicit-dependencies\": false &#125; ...&#125; TsconfigPathsPlugin 插件位置配置错误问题TsconfigPathsPlugin 插件要配置在webpack 配置文件中 resolve 属性下的 plugins 里，否则的话会有问题。比如，直接放在了 webpack 配置文件中的 plugins 中就可能会出现两个问题： 如果 tsconfig.json 文件中 compilerOptions 属性下没有配置 baseUrl 属性，就会提示 Found no baseUrl in tsconfig.json, not applying tsconfig-paths-webpack-plugin 然后配置 baseUrl 属性 ，配置好之后还可能会报错：`tsconfig-paths-webpack-plugin: No file system found on resolver. Please make sure you’ve placed the plugin in the correct part of the configuration. This plugin is a resolver plugin and should be placed in the resolve part of the Webpack configuration. 注意：所以 tsconfig-paths-webpack-plugin 插件的位置一定要放在 webpack 配置文件中 resolve 属性下的 plugins 里。 写在后面这就是目前在项目中添加的部分 TypeScript 以及 TsLint 配置。此时已经可以在项目中正常编写 TypeScript 代码了。 如果大家在项目迁移的过程中如果遇到了别的问题，也可以拿出来交流探讨一下。","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://beichensky.github.io/tags/TypeScript/"},{"name":"前端开发","slug":"前端开发","permalink":"https://beichensky.github.io/tags/前端开发/"}]},{"title":"使用 TypeScript + React + Redux 进行项目开发（入门篇，附源码）","date":"2019-03-08T02:48:10.000Z","path":"20190308/cra-ts-react/","text":"本文详细介绍了如何使用 Create-React-App 编写 TypeScript + React 项目 前言对于 TypeScript + React 开发，MicroSoft 编写了一个 TypeScript-React-Starter 的例子：Github 地址。有需要的朋友可以去看一下。 我自己也看了一下，文档说明讲解的很好，但是 Demo 拉下来却无法正常运行，一直报错。所以我自己使用 TypeScript + React + Redux 写了 Demo，作为范例来用一下。 本文 Demo 地址 本文 Counter Demo 是一个简易的例子，可以用来作为入门参考：Counter Demo 另外还写了一个 TodoList 的例子，稍微更有难度一些，代码量和组件更多更详细。有需要的朋友也可以参考一下：TodoList Demo 建议： 可以先下载 Counter Demo 后，运行项目，查看运行效果，然后对照本文进行阅读，效果更佳！ 使用 TypeScript 编写 React 需要注意的规范必须遵守的要求： 所有用到 jsx 语法的文件都需要以 tsx 后缀命名 使用组件声明时的 Component&lt;P, S&gt; 泛型参数声明，来代替 PropTypes进行类型校验 额外的代码规范： 全局变量或者自定义的 window 对象属性，统一在项目根下的 global.d.ts 中进行声明定义 对于项目中常用到的接口数据对象，最好在 types/ 目录下定义好其结构化类型声明 安装 Create-React-App1$ npm install create-react-app -g 创建项目先创建一个新的项目，这里我们命名为 typescript-react-app1$ create-react-app typescript-react-app --scripts-version=react-scripts-ts react-scripts-ts是一系列适配器，它利用标准的create-react-app工程管道并把TypeScript混入进来。 项目创建成功后，此时项目结构如下所示：1234567891011121314151617181920212223242526272829303132333435my-app/├─ node_modules/├─ public/├─ src/│ └─ ...├─ .gitignore├─ images.d.ts├─ package.json├─ README.md├─ tsconfig.json├─ tsconfig.prod.json├─ tsconfig.test.json├─ tslint.json└─ yarn.lock``` ### 注意： - tsconfig.json包含了工程里TypeScript特定的选项。 - tslint.json保存了要使用的代码检查器的设置，TSLint。 - package.json包含了依赖，还有一些命令的快捷方式，如测试命令，预览命令和发布应用的命令。 - public包含了静态资源如HTML页面或图片。除了index.html文件外，其它的文件都可以删除。 - src包含了TypeScript和CSS源码。index.tsx是强制使用的入口文件。### 运行项目先运行项目，看看是否能够正常启动，如果可以，说明项目创建没有问题。运行命令：``` bash$ npm run start# 或者运行 yarn run start React 配合 TypeScript 的基本使用在当前项目中，可以看到 index.tsx 和 App.jsx 文件中已经使用了 TypeScript，我们现在自己来用 TypeScript 编写一个 React 组件吧。 定义一个 Counter 组件我们在 src 下创建一个 components 目录，新增 Counter 组件： Counter.tsx1234567891011121314import * as React from &apos;react&apos;;// 创建类型接口export interface Iprops &#123; value: number&#125;// 使用接口代替 PropTypes 进行类型校验const Counter = (&#123; value &#125;: Iprops) =&gt; &#123; return &lt;p&gt;Clicked: &#123; value &#125; times&lt;/p&gt;&#125;export default Counter; 在 App.tsx 中引用 Counter 组件并展示1234567891011121314151617import * as React from &apos;react&apos;;import &apos;./App.css&apos;;import Counter from &apos;./components/Counter.jsx&apos;;// import logo from &apos;./logo.svg&apos;;class App extends React.Component &#123; public render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Counter value=&#123; 0 &#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 运行项目：npm run start，可以看到浏览器中展示出了 Clicked: 0 times，说明我们第一个 Counter 组件已经编写并使用成功了。 使用类的方式定义 Counter 组件刚才是使用函数组件的方式定义的 Counter 组件，现在我们使用类的方式来改写一下。两种方式都试一试： Counter.tsx1234567891011121314import * as React from &apos;react&apos;;// 创建类型接口export interface IProps &#123; value: number&#125;// 使用接口代替 PropTypes 进行类型校验export default class Counter extends React.PureComponent&lt;IProps&gt; &#123; public render() &#123; return &lt;p&gt;Clicked: &#123; this.props.value &#125; times&lt;/p&gt; &#125;&#125; 进阶：在项目中配合 Redux 进行使用安装项目需要的插件安装redux和react-redux以及它们的类型文件做为依赖。1$ npm install -S redux react-redux @types/react-redux 这里我们不需要安装@types/redux，因为Redux已经自带了声明文件（.d.ts文件）。 定义应用的状态 State一般会将常用的结构类型存放到 /types 目录下。所以我们在 src 目录下新建 types 目录。此时项目中只有一个 state，就是 Counter 中的点击次数，所以就没有使用借口来作为约束，而是直接使用了 type。 type/index.tsx12// 定义 State 结构类型export type StoreState = number; 添加 actions在 src 下创建 constants 目录，在 index.tsx 文件中添加需要响应的消息类型 constants/index.tsx1234567// 定义增加 state 类型常量export const INCREMENT = &quot;INCREMENT&quot;;export type INCREMENT = typeof INCREMENT;// 定义减少 state 类型常量export const DECREMENT = &quot;DECREMENT&quot;;export type DECREMENT = typeof DECREMENT; 这里的const/type模式允许我们以容易访问和重构的方式使用TypeScript的字符串字面量类型。接下来，我们创建一些 actions 以及创建这些 actions 的函数，src/actions/index.tsx。 actions/index.tsx123456789101112131415161718192021export interface IINCREMENTAction &#123; type: INCREMENT;&#125;export interface IDECREMENTAction &#123; type: DECREMENT;&#125;// 定义 modifyAction 类型，包含 IINCREMENTAction 和 IDECREMENTAction 接口类型export type ModifyAction = IINCREMENTAction | IDECREMENTAction;// 增加 state 次数的方法export const increment = (): IINCREMENTAction =&gt; (&#123; type: INCREMENT,&#125;)// 减少 state 次数的方法export const decrement = (): IDECREMENTAction =&gt; (&#123; type: DECREMENT&#125;) actions/index.tsx 中定义了两个类型，分别负责添加和减少操作的行为。我们还定义了一个类型（ModifyAction），它描述了哪些 action 是可以增加或减少的。 最后，我们定义了两个函数用来创建实际的 actions。 添加 reducer我们的reducer将放在src/reducers/index.tsx文件里。 它的功能是保证增加操作会让 times 加1，减少操作则要将 times 减1。 reducers/index.tsx123456789101112131415import &#123; ModifyAction &#125; from &apos;../actions&apos;;import &#123; DECREMENT, INCREMENT &#125; from &apos;../constants&apos;;// 处理并返回 state export default (state = 0, action: ModifyAction): number =&gt; &#123; switch (action.type) &#123; case INCREMENT: return state + 1 case DECREMENT: return state - 1 default: return state &#125;&#125; 创建容器组件之前我们已经使用了 Counter 组件，但是这个组件是一个纯组件，此时我们需要一个组件将 Counter 和 数据连接起来。我们先修改一下原先的 Counter 组件，在其中添加一些操作按钮 components/Counter.tsx12345678910111213141516171819202122232425import * as React from &apos;react&apos;;// 创建类型接口export interface IProps &#123; value: number, onIncrement: () =&gt; void, onDecrement: () =&gt; void&#125;// 使用接口代替 PropTypes 进行类型校验export default class Counter extends React.PureComponent&lt;IProps&gt; &#123; public render() &#123; const &#123; value, onIncrement, onDecrement &#125; = this.props; return ( &lt;p&gt; Clicked: &#123; value &#125; times &lt;br /&gt; &lt;br /&gt; &lt;button onClick=&#123; onIncrement &#125; style=&#123;&#123; marginRight: 20 &#125;&#125;&gt; + &lt;/button&gt; &lt;button onClick=&#123; onDecrement &#125;&gt; - &lt;/button&gt; &lt;/p&gt; ) &#125;&#125; 然后我们再创建一个 container 目录，用来存放需要与数据交互的组件，新建 CounterCon.tsx 文件. 两个关键点是初始的 Counter 组件和 react-redux 的 connect 函数。 connect 可以将我们的 Counter 组件转换成一个容器，通过以下两个函数： mapStateToProps将当前store里的数据以我们的组件需要的形式传递到组件。 mapDispatchToProps利用dispatch函数，创建回调props将actions送到store。 container/CounterCon.tsx123456789101112131415161718192021import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; Dispatch &#125; from &apos;redux&apos;;import &#123; decrement, increment &#125; from &apos;../actions&apos;;import Counter from &apos;../components/Counter&apos;;import &#123; StoreState &#125; from &apos;../types&apos;;// 将 reducer 中的状态插入到组件的 props 中const mapStateToProps = (state: StoreState): &#123; value: number &#125; =&gt; (&#123; value: state&#125;)// 将 对应action 插入到组件的 props 中const mapDispatchToProps = (dispatch: Dispatch) =&gt; (&#123; onDecrement: () =&gt; dispatch(decrement()), onIncrement: () =&gt; dispatch(increment())&#125;)// 使用 connect 高阶组件对 Counter 进行包裹export default connect(mapStateToProps, mapDispatchToProps)(Counter); 创建 store让我们回到src/index.tsx。 要把所有的东西合到一起，我们需要创建一个带初始状态的store，并用我们所有的reducers来设置它。并且使用 react-redux 的 Provider 将 props 和 容器连接起来 index.tsx12345678910111213141516171819202122import * as React from &apos;react&apos;;import * as ReactDOM from &apos;react-dom&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import &#123; createStore &#125; from &apos;redux&apos;;import App from &apos;./App&apos;;import &apos;./index.css&apos;;import reducer from &apos;./reducer&apos;; import registerServiceWorker from &apos;./registerServiceWorker&apos;;// 1、创建 storeconst store = createStore(reducer);ReactDOM.render( // 2、然后使用react-redux的Provider将props与容器连通起来 &lt;Provider store=&#123; store &#125;&gt; &lt;App /&gt; &lt;/Provider&gt; , document.getElementById(&apos;root&apos;) as HTMLElement);registerServiceWorker(); 回到我们的 App.jsx 文件中，之前我们引用的是 components 中的 Counter 组件，但是此时我们需要使用的是与数据有交互的 CounterCon 组件。改写如下： App.jsx123456789101112131415161718import * as React from 'react';import './App.css';// 引入 container 组件 CountConimport CountCon from './container/CountCon';// import logo from './logo.svg';class App extends React.Component &#123; public render() &#123; return ( &lt;div className=\"App\"&gt; &lt;CountCon /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 注意，此时 CountCon 不再需要 props 了，因为我们使用了 connect 函数为包裹起来的 Hello 组件的 props 适配了应用的状态。 此时，运行项目，点击 + 或者 - 按钮，即可看到 times 的次数会发生变化。 总结至此，对于使用 TypeScript 编写 React 应用应该有了一定的了解。其实写法也比较固定，刚接触的话可能有些地方容易出现问题，多写几个组件之后，应该就没什么问题了。在编写项目的过程中，create-react-app 自带的 tslint 可能要求比较严严格，比如： 在标签里不允许使用 lambda 表达式，在 tslint.json 文件 rules 属性中添加：&quot;jsx-no-lambda&quot;: false 即可 在导入模块时，必须按照字母顺序导入，在 tslint.json 文件 rules 属性中添加：”ordered-imports&quot;: false 即可 还有很多别的配置，有需要的话，可以查看文档：TSLint core rules。 本文 Demo 地址 本文 Counter Demo 是一个简易的例子，可以用来作为入门参考：Counter Demo 另外还写了一个 TodoList 的例子，稍微更有难度一些，代码量和组件更多更详细。有需要的朋友也可以参考一下：TodoList Demo","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://beichensky.github.io/tags/TypeScript/"},{"name":"Redux","slug":"Redux","permalink":"https://beichensky.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"前端开发","slug":"前端开发","permalink":"https://beichensky.github.io/tags/前端开发/"}]},{"title":"使用 happypack 提升 Webpack 项目构建速度","date":"2019-02-21T02:58:55.000Z","path":"20190221/webpack-happypack/","text":"本文简单介绍了 Happypack 的简单使用，不了解的同学可以进来看一看。也许会有所帮助。 Happypack 作用在使用 Webpack 对项目进行构建时，会对大量文件进行解析和处理。当文件数量变多之后，Webpack 构件速度就会变慢。由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的任务要一个一个进行操作。 而 Happypack 的作用就是将文件解析任务分解成多个子进程并发执行。子进程处理完任务后再将结果发送给主进程。所以可以大大提升 Webpack 的项目构件速度 由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。 本文项目代码地址：webpack-happypack-demo 欢迎 Star！ Happypack 的使用Happypack 只是作用在 loader 上，使用多个进程同时对文件进行编译。 安装1$ npm install happypack --save-dev 使用（三步操作即可完成）一、安装完成之后引入 HappyPackwebpack.config.js12345const HappyPack = require('happypack');module.exports = &#123; ...&#125; 二、将常用的 loader 替换为 happypack/loaderwebpack.config.js123456789101112131415const HappyPack = require('happypack');module.exports = &#123; ... module: &#123; rules: [ test: /\\.js$/, // use: ['babel-loader?cacheDirectory'] 之前是使用这种方式直接使用 loader // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件 use: ['happypack/loader?id=babel'], // 排除 node_modules 目录下的文件 exclude: /node_modules/ ] &#125;&#125; 三、创建 HappyPack 插件webpack.config.js12345678910111213141516171819202122232425262728const HappyPack = require('happypack');module.exports = &#123; ... module: &#123; rules: [ test: /\\.js$/, // use: ['babel-loader?cacheDirectory'] 之前是使用这种方式直接使用 loader // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件 use: ['happypack/loader?id=babel'], // 排除 node_modules 目录下的文件 exclude: /node_modules/ ] &#125;, plugins: [ ..., new HappyPack(&#123; /* * 必须配置 */ // id 标识符，要和 rules 中指定的 id 对应起来 id: 'babel', // 需要使用的 loader，用法和 rules 中 Loader 配置一样 // 可以直接是字符串，也可以是对象形式 loaders: ['babel-loader?cacheDirectory'] &#125;) ]&#125; 这样 Happypack 的使用就配置完了，运行项目，可以看到控制台打印如下提示：12Happy[babel]: Version: 5.0.1. Threads: 3Happy[babel]: All set; signaling webpack to proceed. 说明配置生效了。 Happypack 示例使用单个 loader 时上面的使用中就是单个 loader 时的配置，这里再写一次 123456789101112131415exports.module = &#123; rules: [ &#123; test: /.js$/, use: 'happypack/loader?id=babel' &#125; ]&#125;;exports.plugins = [ new HappyPack(&#123; id: 'babel', loaders: [ 'babel-loader?cacheDirectory' ] &#125;);]; 使用多个 loader 时123456789101112131415exports.module = &#123; rules: [ &#123; test: /\\.(css|less)$/, use: 'happypack/loader?id=styles' &#125;, ]&#125;;exports.plugins = [ new HappyPack(&#123; id: 'styles', loaders: [ 'style-loader', 'css-loader', 'less-loader' ] &#125;);]; Happypack 配置项 id: String类型，对于 happypack 来说唯一的 id 标识，用来关联 module.rules 中的 happypack/loader loaders: Array类型，设置各种 loader 配置，与 module.rules 中 loader 的配置用法一样 123456789101112131415161718// 无配置时，可直接使用字符串形式new HappyPack(&#123; id: 'babel', loaders: ['babel-loader?cacheDirectory']&#125;)// 有配置项时，可以使用对象形式new HappyPack(&#123; id: 'babel', loaders: [ &#123; loader: 'babel-loader', options: &#123; cacheDirectory: true &#125; &#125; ]&#125;) threads: Number类型，指示对应 loader 编译源文件时同时使用的进程数，默认是 3 threadPool: HappyThreadPool对象，代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多 12345678910111213141516// 创建一个 HappyThreadPool，作为所有 loader 共用的线程池const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);...new HappyPack(&#123; id: 'babel', loaders: [ &#123; loader: 'babel-loader', options: &#123; cacheDirectory: true &#125; &#125; ], threadPool: happyThreadPool&#125;) verbose: 是否允许 happypack 输出日志，默认是 true verboseWhenProfiling: 是否允许 happypack 在运行 webpack --profile 时输出日志，默认是 false debug: 是否允许 happypack 打印 log 分析信息，默认是 false 个人总结 个人的一点小总结，不足以作为参考依据 在测试 Demo 或者小型项目中，使用 happypack 对项目构建速度的提升不明显，甚至会增加项目的构建速度 在比较复杂的大中型项目中，使用 happypack 才能看到比较明显的构建速度提升 因此，在使用 happypack 时请根据具体情况进行选择，如果反而延长了项目的构建速度，就没有必要使用 happypack 本文 Demo 地址本文项目代码地址：webpack-happypack-demo 欢迎 Star！","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"},{"name":"Externals","slug":"Externals","permalink":"https://beichensky.github.io/tags/Externals/"}]},{"title":"使用 Webpack 的 DllPlugin 提升项目构建速度","date":"2019-02-15T08:07:40.000Z","path":"20190215/dllplugin/","text":"本文介绍了 Webpack 中 DllPlugin 插件的使用，以及配合使用 AddAssetHtmlPlugin 将构建好的 JS 文件插入到 html 页面中。 本文 Demo 地址本文项目代码位置：源码地址欢迎 Star！ DLLPlugin 和 DllReferencePlugin 简介DLLPlugin 就是将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件（这里可以称为动态链接库）中。在之后的构建过程中不会再对这些模块进行编译，而是直接使用 DllReferencePlugin 来引用动态链接库的代码。因此可以大大提高构建速度。一般会对常用的第三方模块使用这种方式，例如 react、react-dom、lodash 等等。只要这些模块不升级更新，这些动态链接库就不需要重新编译。 在 Webpack 中进行使用需要插件Webpack 已经内置了对动态链接库的支持，需要通过两个内置插件的配合使用。它们分别是： DllPlugin 插件：用于打包出一个个单独的动态链接库文件 DllReferencePlugin 插件：用于在主配置文件中去引入 DllPlugin 插件打包好的动态链接库文件 创建项目找一个空文件夹，打开命令行，执行命令1234567891011121314151617# 创建项目目录$ mkdir webpack-dll-demo# 初始化 package.json 文件$ npm init -y # 创建 src 文件夹$ mkdir src# 创建 public 文件夹$ mkdir public# 安装需要用到的插件$ npm install webpack webpack-cli html-webpacl-plugin clean-webpacl-plugin friendly-errors-webpack-plugin -D# 安装 lodash 插件，用于演示 DllPlugin 用法$ npm install lodash 在 public 目录下创建 index.html 文件index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpak DllPlugin 的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 src 目录下创建 index.js 文件index.js123456789import &#123; join &#125; from 'lodash';function createSpan()&#123; const element = document.createElement('span'); element.innerHTML = join(['Hello', 'DllPlugin'], ' , '); return element;&#125;document.querySelector('#root').appendChild(createSpan()); 当前项目目录结构123456webpack-prod-demo|- /public |- index.html|- /src |- index.js|- package.json 使用 DllPlugin 和 DllReferencePlugin（分为三步）一、先编写一个配置文件专门用来编译生成动态链接库（使用 DllPlugin）webpack_dll.config.js12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path');const webpack = require('webpack');const CleanWebpaclPlugin = require('clean-webpack-plugin');const FirendlyErrorePlugin = require('friendly-errors-webpack-plugin');module.exports = &#123; mode: 'production', entry: &#123; // 将 lodash 模块作为入口编译成动态链接库 lodash: ['lodash'] &#125;, output: &#123; // 指定生成文件所在目录 // 由于每次打包生产环境时会清空 dist 文件夹，因此这里我将它们存放在了 public 文件夹下 path: path.resolve(__dirname, 'public/vendor'), // 指定文件名 filename: '[name].dll.js', // 存放动态链接库的全局变量名称，例如对应 lodash 来说就是 lodash_dll_lib // 这个名称需要与 DllPlugin 插件中的 name 属性值对应起来 // 之所以在前面 _dll_lib 是为了防止全局变量冲突 library: '[name]_dll_lib' &#125;, plugins: [ new CleanWebpaclPlugin(['vendor'], &#123; root: path.resolve(__dirname, 'public') &#125;), new FirendlyErrorePlugin(), // 接入 DllPlugin new webpack.DllPlugin(&#123; // 描述动态链接库的 manifest.json 文件输出时的文件名称 // 由于每次打包生产环境时会清空 dist 文件夹，因此这里我将它们存放在了 public 文件夹下 path: path.join(__dirname, 'public', 'vendor', '[name].manifest.json'), // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 lodash.manifest.json 中就有 \"name\": \"lodash_dll_lib\" name: '[name]_dll_lib' &#125;) ]&#125; 二、编写配置文件用来打包项目（使用 DllReferencePlugin）webpack.config.js12345678910111213141516171819202122232425262728293031const path = require('path');const webpack = require('webpack');const HTMLWebpackPlugin = require('html-webpack-plugin');const CleanWebpaclPlugin = require('clean-webpack-plugin');const FirendlyErrorePlugin = require('friendly-errors-webpack-plugin');module.exports = &#123; mode: 'production', devtool: 'source-map', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'build-[hash:5].js' &#125;, plugins: [ new HTMLWebpackPlugin(&#123; title: 'Webpak DllPlugin 的使用', template: './public/index.html' &#125;), new CleanWebpaclPlugin(['dist']), new FirendlyErrorePlugin(), new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), // 告诉 Webpack 使用了哪些动态链接库 new webpack.DllReferencePlugin(&#123; // 描述 lodash 动态链接库的文件内容 manifest: require('./public/vendor/lodash.manifest.json') &#125;) ]&#125; 三、在 index.html 文件中引入动态链接库由于动态链接库我们一般只编译一次，之后就不用编译，复用模块都被打包到了动态链接库中，因此入口的 index.js 文件中已经不包含这些模块了，所以要在 index.html 中单独引入。 index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpak DllPlugin 的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"../public/vendor/lodash.dll.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：由于在打包项目的时候会清理掉 dist 文件，所以我将生成的动态链接库放到了 public 目录下，所以这里是引入 public 下的动态链接库。 我们在 package.json 中添加两条指令： build：打包项目 build:dll：编译生成动态链接库 package.json123456...\"scripts\": &#123; \"build\": \"webpack --config webpack.config.js\", \"build:dll\": \"webpack --config webpack_dll.config.js\"&#125;... 运行根据上面所说的三个步骤，Dll 的用法已经结束了。现在我们运行一下看看结果。 打开命令行，执行命令 12345# 生成动态链接库，只需要运行一次这个指令，以后打包项目不需要再执行这个指令$ npm run build:dll# 打包项目$ npm run build 在浏览器中打开 dist 文件夹下的 index.html 文件，可以看到浏览器上出现：Hello , DllPlugin。说明项目配置成功。 DllPlugin 和 DllReferencePlugin 分别做了什么运行 npm run build:dll 指令之后，可以看到项目中 public 目录下多出了一个 vendor 的文件夹，可以看到其中包含两个文件： lodash.dll.js 里面包含 lodash 的基础运行环境，也就是 lodash 模块 lodash.manifest.json 也是由 DllPlugin 生成出，用于描述动态链接库文件中包含哪些模块 lodash.dll.js1var lodash_dll_lib=... // 此处代码过多，进行省略 lodash.manifest.json1&#123;\"name\":\"lodash_dll_lib\",\"content\":&#123;\"./node_modules/lodash/lodash.js\":&#123;\"id\":1,\"buildMeta\":&#123;\"providedExports\":true&#125;&#125;,\"./node_modules/webpack/buildin/global.js\":&#123;\"id\":2,\"buildMeta\":&#123;\"providedExports\":true&#125;&#125;,\"./node_modules/webpack/buildin/module.js\":&#123;\"id\":3,\"buildMeta\":&#123;\"providedExports\":true&#125;&#125;&#125;&#125; 对比之后可以明白： 一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 lodash_dll_lib 变量把自己暴露在了全局中，也就是可以通过 window.lodash_dll_lib 可以访问到它里面包含的模块 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID 至此，Dll 的使用以及配置完成了。但是这里还有值得思考的地方：目前看来，项目可以正常运行，但是现在动态链接库是存放到 public 目录下的，如果我们需要将项目打包上线的话，如何能够让动态链接库自动也存放到 dist 目录下呢？如何在我们不手动添加脚本的情况下，自动将动态链接库引入到 index.html 文件中呢？如果有兴趣的话，可以继续往下来看一看配合 add-asset-html-webpack-plugin 的使用。 add-asset-html-webpack-plugin 的使用上面也已经说了，虽然 Dll 的使用和配置没有问题了，但是还不是很满意，打包的时候不能将动态链接库自动的存放到 dist 文件夹，也不能自动在 html 文件中引入动态链接库脚本。所以这时候 add-asset-html-webpack-plugin 就派上用场了。 安装插件1$ npm install add-asset-html-webpack-plugin -D 使用在 webpack.config.js 文件中进行使用 webpack.config.js1234567891011121314151617181920...;const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');module.exports = &#123; ..., plugins: [ ..., // 该插件将把给定的 JS 或 CSS 文件添加到 webpack 配置的文件中，并将其放入资源列表 html webpack插件注入到生成的 html 中。 new AddAssetHtmlPlugin([ &#123; // 要添加到编译中的文件的绝对路径，以及生成的HTML文件。支持globby字符串 filepath: require.resolve(path.resolve(__dirname, 'public/vendor/lodash.dll.js')), // 文件输出目录 outputPath: 'vendor', // 脚本或链接标记的公共路径 publicPath: 'vendor' &#125; ]) ]&#125; 此时可以删除 index.html 文件中手动引入的脚本了1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpak DllPlugin 的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;!-- 删除下面这行引入脚本 --&gt;- &lt;script src=\"../public/vendor/lodash.dll.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行项目打开命令行，执行命令：12# 打包项目$ npm run build 现在查看项目中 dist 文件夹，可以看到 public 目录下 vendor 文件夹中的 js 文件已经全部自动拷贝到 dist 目录中的 vendor 文件夹下了 打开 dist 文件夹中的 index.html 文件，可以看到已经自动将生成的脚本文件引入了 在浏览器中打开 index.html，可以看到 ‘Hello , DllPlugin’ 也能够正常显示 add-asset-html-webpack-plugin 更多配置请参考 github 地址：AddAssetHtmlPlugin 配置 总结 Dll 动态链接库的使用可以提高项目构建速度，因为对于大量复用的模块可以提前进行编译，且只需要编译一次，之后的开发中，使用这些模块的地方都不会再重新进行编译 DllPlugin 和 DllReferencePlugin 需要配合使用 DllPlugin 用于打包出一个个单独的动态链接库文件并生成对应的主清单文件用于描述动态链接库中包含哪些模块 DllReferencePlugin 用于在主清单文件中去引入 DllPlugin 插件打包好的动态链接库文件 可以使用 AddAssetHtmlPlugin 将生成的动态链接库文件拷贝到出口文件夹下，然后 HTMLWebpackPlugin 就会自动的将脚本文件注入到生成的 html 文件中去 注意：如想测试一下构建速度是否有提升，可以将 webpack.config.js 中的 DllReferencePlugin 和 AddAssetHtmlPlugin 使用注释起来，运行 npm run build，观察打包时间；再将注释打开，运行 npm run build，观察打包时间，进行对比，即可发现区别 如是第一次打包，请先运行 npm run build:dll 生成动态链接库。 本文 Demo 地址：源码地址欢迎 Star！","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"},{"name":"DllPlugin","slug":"DllPlugin","permalink":"https://beichensky.github.io/tags/DllPlugin/"}]},{"title":"使用 Webpack 进行生产环境配置（附 Demo）","date":"2019-02-01T09:15:24.000Z","path":"20190201/webpack-prod/","text":"本文从代码压缩、代码拆分、样式分离等三个方面对生产环境的代码打包进行了优化配置。只是最简单的一些配置，如果真正运用到项目中，还需要根据项目添加更多配置。 前言本文讲述的是如何对生产环境下的代码进行压缩，如果还不是太了解 Webpack 的朋友，可以先看一下我的上一篇文章：从零开始搭建一个 Webpack 开发环境配置（附 Demo） 本文项目代码位置：源码地址 环境搭建项目结构首先编写一个项目，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）：1234567$ mkdir webpack-prod-demo$ cd webpack-prod-demo$ npm init -y$ npm install webpack webpack-cli --save-dev project1234567webpack-prod-demo|- package.json|- /public |- index.html|- /src |- index.js |- index.css pubic/index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpack 生产环境配置&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; index.js1234567891011import './index.css';function component() &#123; var element = document.createElement('div'); element.innerHTML = 'Hello World'; return element;&#125; document.body.appendChild(component()); index.css1234div &#123; color: blue; text-align: center;&#125; package.json12345678910111213&#123; \"name\": \"webpack-prod-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; 配置 webpack.config.js 文件在根目录下新建 webpack.config.js 文件，并进行基本配置 安装插件1234567891011121314# 安装 babel-loader$ npm install babel-core babel-loader@7 --save-dev# 安装 babel presets$ npm install babel-preset-env babel-preset-stage-0 --save-dev# 安装 babel plugins $ npm install babel-plugin-transform-class-properties babel-plugin-transform-runtime babel-runtime --save-dev# 安装其余所需 loader$ npm install css-loader style-loader file-loader csv-loader xml-loader html-loader markdown-loader --save-dev# 安装 webpack 插件$ npm install clean-webpack-plugin html-webpack-plugin friendly-errors-webpack-plugin --save-dev 配置 webpack.config.js： webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const path = require('path');const HTMLWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'hidden-source-map', entry: './src/index.js', output: &#123; filename: '[name]-[hash:8].js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new HTMLWebpackPlugin(&#123; // 用于生成的HTML文档的标题 title: 'Webpack 生产环境配置', // webpack 生成模板的路径 template: './public/index.html' &#125;), // 用法：new CleanWebpackPlugin(paths [, &#123;options&#125;]) new CleanWebpackPlugin(['dist']), // 在命令行进行友好提示 new FriendlyErrorsWebpackPlugin() ], module: &#123; rules: [ &#123; test: /\\.js/, include: path.resolve(__dirname, 'src'), loader: 'babel-loader?cacheDirectory' &#125;, // 解析 css &#123; test: /\\.css$/, include: path.resolve(__dirname, 'src'), use: [ 'style-loader', // 还可以给 loader 添加一些配置 &#123; loader: 'css-loader', options: &#123; // 开启 sourceMop sourceMap: true &#125; &#125; ] &#125;, // 解析图片资源 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, // 解析 字体 &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, // 解析 MakeDown 文件 &#123; test: /\\.md$/, use: [ \"html-loader\", \"markdown-loader\" ] &#125; ] &#125;&#125; 在项目根目录下创建 .babelrc 文件 .babelrc1234567&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [ \"transform-runtime\", \"transform-class-properties\" ]&#125; 基本配置完成后运行项目在命令行运行指令：1$ npm run build 此时在浏览器打开 dist 文件夹下的 html 文件，页面上正常显示 蓝色居中的 Hello World 查看此时 dist 文件大小： 普通打包 设置 mode 为 productionwebpack.config.js12345...module.exports = &#123; mode: 'production' ...&#125; 设置为生产环境后运行项目在命令行运行指令：1$ npm run build 此时在浏览器打开 dist 文件夹下的 html 文件，页面上还是能够正常显示 蓝色居中的 Hello World 查看此时 dist 文件大小： 生产环境打包 本文的重点：优化打包安装需要用到的插件：12345# 安装压缩 js、 css 代码的插件$ npm install uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin --save-dev# 安装提取 css 的插件$ npm install mini-css-extract-plugin --save-dev uglifyjs-webpack-plugin 和 optimize-css-assets-webpack-plugin 的使用webpack.config.js12345678910111213141516171819202122232425262728293031323334353637...;const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");module.exports = &#123; ..., optimization: &#123; // 打包压缩js/css文件 minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125; &#125; &#125;), new OptimizeCSSAssetsPlugin(&#123; cssProcessorOptions: &#123; safe: true &#125; &#125;) ] &#125;&#125; uglifyjs-webpack-plugin 更多配置请参考：插件文档。 optimize-css-assets-webpack-plugin 更多配置请参考：插件文档。 mini-css-extract-plugin 的使用 注意： MiniCssExtractPlugin.loader 和 style-loader 一起使用可能出现问题。所以下面我将 style-loader 去掉了。 webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738...;const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; ... plugins: [ ..., // 打包后提取出css文件 new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css', chunkFilename: '[name].[contenthash:8].chunk.css' &#125;) ], module: [ rules: [ ..., // 解析 css &#123; test: /\\.css$/, include: path.resolve(__dirname, 'src'), use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, // 还可以给 loader 添加一些配置 &#123; loader: 'css-loader', options: &#123; // 开启 sourceMop sourceMap: true &#125; &#125; ] &#125;, ... ] ]&#125; mini-css-extract-plugin 更多配置请参考：插件文档。 chunk 拆分webpack.config.js1234567891011121314...;module.exports = &#123; ..., optimization: &#123; // 打包压缩js/css文件 minimizer: [ ... ], splitChunks: &#123; chunks: 'all' &#125; &#125;&#125; splitChunks 更多配置请参考：官方文档。 区分环境在开发网页的时候，一般都会有多套运行环境，例如： 在开发过程中方便开发调试的环境 发布到线上给用户使用的运行环境 为了尽可能的复用代码，在构建的过程中需要根据目标代码要运行的环境而输出不同的代码，我们需要一套机制在源码中去区分环境。可以通过 Webpack 内置的 DefinePlugin 插件进行环境的区分。 区分环境的原因：很多第三方库中也做了环境区分的优化 开发环境：包含类型检查、HTML 元素检查等等针对开发者的警告日志代码 线上环境：去掉了所有针对开发者的代码，只保留让 React 能正常运行的部分，以优化大小和性能 注意： NODE_ENV 和 ‘production’ 两个值是社区的约定，通常使用这条判断语句在区分开发环境和线上环境。 配置： webpack.config.js12345678910111213141516...module.exports = &#123; ..., plugins: [ ..., // 区分环境 new webpack.DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], ...&#125; 进行配置优化后运行项目在命令行运行指令：1$ npm run build 此时在浏览器打开 dist 文件夹下的 html 文件，页面上仍能正常显示 蓝色居中的 Hello World 查看此时 dist 文件大小： 优化配置后打包 webpack.config.js 文件最终代码其余文件基本未进行修改。在此将 webpack.config.js 代码贴出来 webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138const path = require('path');const HTMLWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; mode: 'production', devtool: 'hidden-source-map', entry: './src/index.js', output: &#123; filename: '[name]-[hash:8].js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new HTMLWebpackPlugin(&#123; // 用于生成的HTML文档的标题 title: 'Webpack 开发环境配置', // webpack 生成模板的路径 template: './public/index.html' &#125;), // 用法：new CleanWebpackPlugin(paths [, &#123;options&#125;]) new CleanWebpackPlugin(['dist']), // 在命令行进行友好提示 new FriendlyErrorsWebpackPlugin(), // 打包后提取出css文件 new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css', chunkFilename: '[name].[contenthash:8].chunk.css' &#125;), // 区分环境 new webpack.DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js/, include: path.resolve(__dirname, 'src'), loader: 'babel-loader?cacheDirectory' &#125;, // 解析 css &#123; test: /\\.css$/, include: path.resolve(__dirname, 'src'), use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, // 还可以给 loader 添加一些配置 &#123; loader: 'css-loader', options: &#123; // 开启 sourceMop sourceMap: true &#125; &#125; ] &#125;, // 解析图片资源 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, // 解析 字体 &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, // 解析 MakeDown 文件 &#123; test: /\\.md$/, use: [ \"html-loader\", \"markdown-loader\" ] &#125; ] &#125;, optimization: &#123; // 打包压缩js/css文件 minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125; &#125; &#125;), new OptimizeCSSAssetsPlugin(&#123; cssProcessorOptions: &#123; safe: true &#125; &#125;) ], splitChunks: &#123; chunks: 'all' &#125; &#125;&#125; 对比通过三次打包的对比，可以看到： 第一次普通配置打包后，包大小为 48.1 K 第二次设置为生产环境后打包，包大小为 39.0 K 第三次进行优化配置后打包，包大小为 1.46 K 目前这个项目一个 js 文件，代码量很少，但是还是可以看到优化的效果的。如果项目更大的话，优化的效果也会更明显。当然，需要的配置可能更多了。 项目源码源码地址 总结本文只是对于生产环境下代码打包的简单优化，在项目实战的过程中，可能会需要更多的配置。其实无论看多少教程，其实里面的配置都不一定能够满足自身的要求。在开发的过程中，还是需要自己根据需求进行配置。 其实 Webpack 的学习并不难，根据官网的说明和指南，其实基本都会使用。难的是各种 loader、plugin 自身的配置。这些都需要去到 loader 和 plugin 的网站上深入研究才可以。所以想要更好的进行 webpack 配置，还是需要多多留意最新技术的出现，多搜集有用的插件和配置。积少成多，慢慢的就能配置出更好的项目脚手架（目前这也是我的目标）。","tags":[{"name":"Webapck","slug":"Webapck","permalink":"https://beichensky.github.io/tags/Webapck/"},{"name":"Production","slug":"Production","permalink":"https://beichensky.github.io/tags/Production/"}]},{"title":"从零开始搭建一个 Webpack 开发环境配置（附 Demo）","date":"2019-01-30T07:40:30.000Z","path":"20190130/webpack-dev/","text":"本文使用 Webpack 从零开始搭建一个开发环境的脚手架配置，在此做个记录，也方便以后使用。 前言我的上一篇文章简单介绍了一下 Webpack 的一些核心概念和基本配置，需要了解的朋友可以先参考一下Webpack 的简单介绍 从 webpack v4.0.0 开始，可以不用引入一个配置文件。直接使用 webpack 命令就可进行打包。但是，一般我们需要进行更灵活的配置功能，所以本文我也创建一个 webpack 的配置文件，对webpack 的一些属性进行配置。 本文 Demo 地址 环境搭建项目结构首先我们创建一个目录，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）： 12345$ mkdir webpack-dev-demo &amp;&amp; cd webpack-dev-demo$ npm init -y$ npm install webpack webpack-cli --save-dev project 123456webpack-dev-demo|- package.json|- /public |- index.html|- /src |- index.js src/index.js123456789function component() &#123; var element = document.createElement('div'); element.innerHTML = 'Hello World'; return element;&#125; document.body.appendChild(component()); public/index.js123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpack 开发环境配置&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; package.json1234567891011121314151617&#123; \"name\": \"webpack-dev-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^4.29.0\", \"webpack-cli\": \"^3.2.1\" &#125;&#125; 创建配置文件在项目根目录下创建 webpack.config.js 配置文件 project 1234567 webpack-dev-demo |- package.json |- /public |- index.html |- /src |- index.js+ |- webpack.config.js 配置入口和输出webpack.config.js123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: '[name]-[hash:8].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 运行 webpack1$ npm run build 控制台的打印结果 第一次打印结果 可以看到打印日志，打包成功了，但是此时在浏览器打开我们的 index.html 文件，却发现界面上什么都不显示，这个也好理解，因为 index.html 此时还没有引入任何的 js 文件。所以这个时候就要将打包后的文件引入到 index.html 文件中，但是可以看到 dist 文件夹下的 js 文件名有很多的 hash 值，而且每次编译都可能不同，怎么办呢？这时候就要引入 html-webpack-plugin 插件了 html-webpack-plugin 插件的使用安装插件：1$ npm install html-webpack-plugin --save-dev 使用插件： webpack.config.js1234567891011121314...const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; ... plugins: [ new HTMLWebpack(&#123; // 用于生成的HTML文档的标题 title: 'Webpack 开发环境配置', // webpack 生成模板的路径 template: './public/index.html' &#125;) ]&#125; 关于 html-webpack-plugin 插件更多配置请参考：插件文档。 再次运行 webpack1$ npm run build 可以看到 dist 文件夹下生成了一个 index.html 文件，在浏览器中打开这个 index.html 文件，可以看到，’Hello World’ 已经能够正常显示了 至此，项目能够正常打包了，但是还不够，此时可以看到 dist 文件夹下有两个 js 文件，但是明明只打了一个包啊。是因为另一个包使我们上一次操作打出来的，并没有删除掉。所以，为了避免 dist 文件夹中的文件变得杂乱，我们还需要引入 clean-webpack-plugin 插件帮助我们清理 dist 文件夹 clean-webpack-plugin 插件的使用安装插件：1$ npm install clean-webpack-plugin --save-dev 用法：new CleanWebpackPlugin(paths [, {options}]) webpack.config.js1234567891011...const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; ... plugins: [ ..., // 用法：new CleanWebpackPlugin(paths [, &#123;options&#125;]) new CleanWebpackPlugin(['dist']) ]&#125; 再次运行 webpack1$ npm run build 此时 dist 文件夹下只有一个 js 和 html 文件了。说明插件配置成功了，关于 clean-webpack-plugin 更多配置请参考：插件文档。 配置 Http 服务并进行实时预览安装 webpack-dev-server 包：1$ npm install --save-dev webpack-dev-server 使用： webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859...const webpack = require('webpack');module.exports = &#123; ... devServer: &#123; // 必须配置的选项，服务启动的目录，默认为跟目录 contentBase: './dist', // 使用热加载时需要设置为 true hot: true, /** * 下面为可选配置 */ // 指定使用一个 host。默认是 localhost host: 'localhost', // 端口号 port: 8000, // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html。通过设置为 true 进行启用 historyApiFallback: &#123; disableDotRule: true &#125;, // 出现错误时是否在浏览器上出现遮罩层提示 overlay: true, /** * 在 dev-server 的两种不同模式之间切换 * 默认情况下，应用程序启用内联模式 inline * 设置为 false，使用 iframe 模式，它在通知栏下面使用 &lt;iframe&gt; 标签，包含了关于构建的消息 */ inline: true, /** * 统计信息，枚举类型，可供选项： * \"errors-only\": 只在发生错误时输出 * \"minimal\": 只在发生错误或有新的编译时输出 * \"none\": 没有输出 * \"normal\": 标准输出 * \"verbose\": 全部输出 */ stats: \"errors-only\", // 设置接口请求代理，更多 proxy 配置请参考 https://github.com/chimurai/http-proxy-middleware#options proxy: &#123; '/api/': &#123; changeOrigin: true, // 目标地址 target: 'http://localhost:3000', // 重写路径 pathRewrite: &#123; '^/api/': '/' &#125; &#125; &#125; &#125;, plugins: [ ..., // 添加 NamedModulesPlugin，以便更容易查看要修补(patch)的依赖，由于设置了 mode: 'development'，所以这个插件可以省略 // new webpack.NamedModulesPlugin(), // 进行模块热替换 new webpack.HotModuleReplacementPlugin() ]&#125; 启用热加载功能：(上面已经添加了) 1、在 devServer 配置中添加 hot: true 属性 2、在 plugins 中添加 new webpack.NamedModulesPlugin() 和 new webpack.HotModuleReplacementPlugin() 在 package.json 中添加一个执行命令 package.json1234567...\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\",+ \"start\": \"webpack-dev-server\"&#125;... 启动 Http 服务 执行命令：1$ npm run start 可以看到控制台打印输出： 打印日志 打开浏览器，输入：http://localhost:8000/，可以看到浏览器中可以正常显示 Hello World。 模式配置webpack 配置中有一个 mode 属性的配置，三个可选属性： production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 none 不选用任何默认优化选项 这里我们配置的是开发环境，所以需要将 mode 设置为 development webpack.config.js12345...module.exports = &#123;+ mode: 'development', ...&#125; 启用调试工具 Source Map此时项目能够正常运行，所以没有什么问题，但是现在我们修改一下，将 index.js 中的 return element 改成错误的 return ele。我们 F12 打开开发工具，可以看到控制台的错误提示，点进去却发现跟我们写的代码不一致，难以对错误的代码进行调试，此时 Source Map 就派上用场了。 在 webpack.config.js 中添加 devtool 属性 webpack.config.js123456...module.exports = &#123; mode: 'development',+ devtool: inline-source-map ...&#125; devtool 的多个属性之间的差异 devtool 构建速度 重新构建速度 生产环境 品质(quality) (none) +++ +++ yes 打包后的代码 eval +++ +++ no 生成后的代码 cheap-eval-source-map + ++ no 转换过的代码（仅限行） cheap-module-eval-source-map o ++ no 原始源代码（仅限行） eval-source-map – + no 原始源代码 cheap-source-map + o yes 转换过的代码（仅限行） cheap-module-source-map o - yes 原始源代码（仅限行） inline-cheap-source-map + o no 转换过的代码（仅限行） inline-cheap-module-source-map o - no 原始源代码（仅限行） source-map – – yes 原始源代码 inline-source-map – – no 原始源代码 hidden-source-map – – yes 原始源代码 nosources-source-map – – yes 无源代码内容 再次运行项目：1$ npm run start 可以看到报错依旧，但是在开发工具的控制台上，查看错误提示，可以根据提示清楚的找到我们写的代码所在位置. 测试之后请将错误的 return ele 改为正确的 return element 为项目添加模块解析规则此时，开发环境已经配置的差不多了，但是我现在想给 div 加一个样式，想让文字编程蓝色，居中显示，那么此时就需要用的 loader 了，因为 webpack 默认无法解析 css，所以就需要我们自己配置了 配置 css 模块解析安装所需插件：1$ npm install css-loader style-loader --save-dev css-loader 用来解析 css 文件，而 style-loader 则用来将解析好的 css 内容注入到 JavaScript 里。由于 loader 执行顺序是从下到上，所以要将 css-loader 写在下面。 使用： webpack.config.js1234567891011121314151617181920212223...module.exports = &#123; ... plugins: [...], module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', // 还可以给 loader 添加一些配置 &#123; loader: 'css-loader', options: &#123; // 开启 sourceMop sourceMap: true &#125; &#125; ] &#125; ] &#125;&#125; 在 src 目录下新建一个 css 文件 src/index.css：1234div &#123; color: blue; text-align: center;&#125; src/index.js123require('./index.css');... 重新运行项目：1$ npm run start 可以看到浏览器上此时文字颜色已经变蓝，并且居中显示。 配置其他模块解析除了 css 之外，其他文件在 webpack 也都被认为是一个模块，也都需要对应的 loader 进行解析。下面就不一一演示了，先把代码贴出来看一看。 下载所有需要的插件：1$ npm install file-loader csv-loader xml-loader html-loader markdown-loader --save-dev webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546...module.exports = &#123; ... plugins: [...], module: &#123; rules: [ ... // 解析图片资源 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, // 解析 字体 &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, // 解析 MakeDown 文件 &#123; test: /\\.md$/, use: [ \"html-loader\", \"markdown-loader\" ] &#125; ] &#125;&#125; 这些配置基本上可以满足常规开发中使用到的各种模块资源，不过在开发过程中可能还会需要用到 less、scss 等 css 预编译语言，还需要使用 less-loader，sass-loader 进行配置。更多配置用法这里也无法一一详述，等大家用到的时候再去查阅对应文档即可。 使用 babel 进行配置目前项目可以正常运行，但是现在 ES6、7 语法已经出来了，但是浏览器中还不能完全识别，所以我们需要 babel 讲 js 文件转换成浏览器可以识别的 ES5 语法。 安装 bable-loader 插件1$ npm install babel-core babel-loader --save-dev babel 还能进行配置，可以像上面那样直接在 loader 中进行配置，也可以在根目录下创建 .babelrc 文件配置，项目运行会自动从此文件中读取 使用 babel-loader： webpack.config.js1234567891011121314...module.exports = &#123; ... plugins: [...], module: &#123; rules: [ &#123; test: /\\.js/, include: path.resolve(__dirname, 'src'), loader: 'babel-loader?cacheDirectory', &#125;, ] &#125;&#125; babel 的 cacheDirectory 属性默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。如果设置了一个空值 (loader: &#39;babel-loader?cacheDirectory&#39;) 或者 true (loader: babel-loader?cacheDirectory=true)，loader 将使用默认的缓存目录 node_modules/.cache/babel-loader，如果在任何根目录下都没有找到 node_modules 目录，将会降级回退到操作系统默认的临时文件目录。 使用 cacheDirectory 选项，将 babel-loader 提速至少两倍。 babel 的 Presets 配置presets 属性告诉 Babel 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 Presets 可以叠加。 Presets 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作。Presets 是按照 ECMAScript 草案来组织的，通常可以分为以下三大类： 已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为： es2015 包含在2015里加入的新特性； es2016 包含在2016里加入的新特性； es2017 包含在2017里加入的新特性； env 包含当前所有 ECMAScript 标准里的最新特性。 被社区提出来的但还未被写入 ECMAScript 标准里特性，这其中又分为以下四种： stage0 只是一个美好激进的想法，有 Babel 插件实现了对这些特性的支持，但是不确定是否会被定为标准； stage1 值得被纳入标准的特性； stage2 该特性规范已经被起草，将会被纳入标准里； stage3 该特性规范已经定稿，各大浏览器厂商和 Node.js 社区开始着手实现； stage4 在接下来的一年将会加入到标准里去。 为了支持一些特定应用场景下的语法，和 ECMAScript 标准没有关系，例如 babel-preset-react 是为了支持 React 开发中的 JSX 语法。 babel 的 Plugins 配置plugins 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。 安装项目中需要使用的 Presets 插件1$ npm install babel-preset-env babel-preset-stage-0 --save-dev 安装项目中需要的 babel Plugin1$ npm install babel-plugin-transform-class-properties babel-plugin-transform-runtime babel-runtime --save-dev babel-plugin-transform-class-properties 可以在项目中使用新增的 class 属性用法 babel-plugin-transform-runtime 由于 babel 转换文件时会在每个文件中都写入辅助代码，使用此插件可以直接使用 babel-runtime 中的代码进行转换，避免代码冗余。所以 babel-plugin-transform-runtime 和 babel-runtime 成对使用 .babelrc1234567&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [ \"transform-runtime\", \"transform-class-properties\" ]&#125; 配置完成，此时就可以在项目中自由的使用 ES6 等新增 js 语法了。 使用 friendly-errors-webpack-plugin有时候项目提示错误，可能是编译错误，可能是 ESLint 提示错误等等，我们希望错误提示能够友好一些，就可以使用这个插件 插件安装：1npm install friendly-errors-webpack-plugin --save-dev 使用： webpack.config.js12345678910...const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin');module.exports = &#123; ..., plugins: [ ... new FriendlyErrorsWebpackPlugin() ]&#125; 更多配置请参考插件文档 配置模块如何解析 resolve开发的时候我们经常会需要引入自己写的文件模块，可能会需要按照路径一级一级的找，这个时候我们就可以配置 resolve，为一些常用的路径设置别名 配置： webpack.config.js1234567891011...module.exports = &#123; ... plugins: [...], modules: &#123;...&#125;, resolve: &#123; alias: &#123; src: path.resolve(__dirname, 'src') &#125; &#125;&#125; 使用：无论在任何文件里，引入 src 目录下的 index.css 文件时，路径都可以按照下面的这个引入路径来写 index.js12- require('./index.css');+ import 'src/index.css'; 重新运行项目，发现项目正常启动，index.css 中的样式也正常生效 至此，一个简单的开发环境的 Webpack 脚手架搭建完成了。 最终的项目结构以及文件代码project1234567webpack-dev-demo|- package.json|- /public |- index.html|- /src |- index.js |- index.css public/index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpack 开发环境配置&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; src/index.js1234567891011import 'src/index.css';function component() &#123; var element = document.createElement('div'); element.innerHTML = 'Hello World'; return element; &#125; document.body.appendChild(component()); src/index.css1234div &#123; color: blue; text-align: center;&#125; .babelrc1234567&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [ \"transform-runtime\", \"transform-class-properties\" ]&#125; webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140const path = require('path');const HTMLWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; mode: 'development', devtool: 'inline-source-map', entry: './src/index.js', output: &#123; filename: '[name]-[hash:8].js', path: path.resolve(__dirname, 'dist') &#125;, devServer: &#123; // 必须配置的选项，服务启动的目录，默认为跟目录 contentBase: './dist', // 使用热加载时需要设置为 true hot: true, /** * 下面为可选配置 */ // 指定使用一个 host。默认是 localhost host: 'localhost', // 端口号 port: 8000, // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html。通过设置为 true 进行启用 historyApiFallback: &#123; disableDotRule: true &#125;, // 出现错误时是否在浏览器上出现遮罩层提示 overlay: true, /** * 在 dev-server 的两种不同模式之间切换 * 默认情况下，应用程序启用内联模式 inline * 设置为 false，使用 iframe 模式，它在通知栏下面使用 &lt;iframe&gt; 标签，包含了关于构建的消息 */ inline: true, /** * 统计信息，枚举类型，可供选项： * \"errors-only\": 只在发生错误时输出 * \"minimal\": 只在发生错误或有新的编译时输出 * \"none\": 没有输出 * \"normal\": 标准输出 * \"verbose\": 全部输出 */ stats: \"errors-only\", // 设置接口请求代理，更多 proxy 配置请参考 https://github.com/chimurai/http-proxy-middleware#options proxy: &#123; '/api/': &#123; changeOrigin: true, // 目标地址 target: 'http://localhost:3000', // 重写路径 pathRewrite: &#123; '^/api/': '/' &#125; &#125; &#125; &#125;, plugins: [ new HTMLWebpackPlugin(&#123; // 用于生成的HTML文档的标题 title: 'Webpack 开发环境配置', // webpack 生成模板的路径 template: './public/index.html' &#125;), // 用法：new CleanWebpackPlugin(paths [, &#123;options&#125;]) new CleanWebpackPlugin(['dist']), // 添加 NamedModulesPlugin，以便更容易查看要修补(patch)的依赖，由于设置了 mode: 'development'，所以这个插件可以省略 // new webpack.NamedModulesPlugin(), // 进行模块热替换 new webpack.HotModuleReplacementPlugin() ], module: &#123; rules: [ &#123; test: /\\.js/, include: path.resolve(__dirname, 'src'), loader: 'babel-loader?cacheDirectory' &#125;, // 解析 css &#123; test: /\\.css$/, include: path.resolve(__dirname, 'src'), use: [ 'style-loader', // 还可以给 loader 添加一些配置 &#123; loader: 'css-loader', options: &#123; // 开启 sourceMop sourceMap: true &#125; &#125; ] &#125;, // 解析图片资源 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, // 解析 字体 &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, // 解析数据资源 &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, // 解析 MakeDown 文件 &#123; test: /\\.md$/, use: [ \"html-loader\", \"markdown-loader\" ] &#125; ] &#125;, resolve: &#123; alias: &#123; src: path.resolve(__dirname, 'src') &#125; &#125;&#125; package.json123456789101112131415161718192021222324252627282930&#123; \"name\": \"webpack-dev-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\", \"start\": \"webpack-dev-server\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-transform-class-properties\": \"^6.24.1\", \"babel-plugin-transform-runtime\": \"^6.23.0\", \"babel-preset-env\": \"^1.7.0\", \"babel-preset-stage-0\": \"^6.24.1\", \"babel-runtime\": \"^6.26.0\", \"clean-webpack-plugin\": \"^1.0.1\", \"css-loader\": \"^2.1.0\", \"html-webpack-plugin\": \"^3.2.0\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.29.0\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\" &#125;&#125; 源码地址本文 Demo 地址 总结本文篇幅较长，感谢各位的耐心阅读。本文主要从 入口、输出、插件（Plugins）、模块处理（Module）、loader、解析（resolve）等 6 个配置项着手配置了一个基本的 webpack 开发环境脚手架。本文主要讲解的内容为： loader 的作用以及如何配置使用 babel 的作用以及配置项 各个插件的功能以及适用场景 解析能够为开发带来的效率 本文内容对于已经熟练掌握 Webpack 的朋友来说，可能有些浅薄，但是着重讲解了各个配置项的功能以及配置后对项目产生的效果。对于准备入门 webpack 的朋友应该会有一定的帮助。","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"},{"name":"Development","slug":"Development","permalink":"https://beichensky.github.io/tags/Development/"}]},{"title":"Webpack 的简单介绍","date":"2019-01-30T07:40:29.000Z","path":"20190130/webpack-basic/","text":"本文介绍了一些 webpack 的核心概念以及一些概念术语，并对核心配置做了一些简单的用法讲解。建议刚刚接触 Webpack 的朋友可以先了解一下。想了解更多 Webpack 使用以及配置的话可以参考我的下一篇文章： 从零开始搭建一个 Webpack 开发环境配置（附 Demo） 为什么需要使用 webpack 模块化开发的趋势我们在开发的过程中，之前都是使用引入 script 的方式进行各种工具和插件的引入，但是这样会造成很大程度上的全局污染，所以引入了 模块化 的概念，但是不管是 commomJs 还是 CMD，AMD 的方式，浏览器无法识别，而使用 webpack 就可以自动的将文件编译成浏览器可以识别的代码 less、sass 以及 ES6 语法的使用同样的，直接使用 less、sass 和 ES6 语法，直接使用，浏览器甚至 node 环境也无法正常识别，所以这时候 loader 就派上用场了，可以使用 less-loader、sass-loader 以及 babel-lodaer 对对应的文件进行转换之后，就可以正常的编译了 监听文件的变化并自动刷新网页，做到实时预览 提供 HTTP 服务而不是使用本地文件预览 对于打包后的文件进行压缩，模块拆分，减小打包后的文件体积 等等还有很多别的优势，这里我就不一一列举了 webpack 安装 全局安装： 1npm install --global webpack 本地安装： 12npm install --save-dev webpacknpm install --save-dev webpack-cli Webpack 概念webpack 是一个可高度配置的现代 JavaScript 应用程序模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 Webpack 核心概念入口入口点可以告诉 webpack 从哪里启动以及遵循依赖关系图，以此知道要打包什么东西。你可以考虑将待打包文件的根目录作为你应用程序的入口点。 个人理解：入口就是 webpack 在处理应用程序时，需要知道从哪个文件开始执行，这个文件就是整个程序的入口文件。 用法：entry: string|Array|Object 基本用法webpack.config.js12345const config = &#123; entry: './src/index.js'&#125;;module.exports = config; 数组语法一般适用于多页面应用，多个入口的场景。 webpack.config.js12345const config = &#123; entry: ['./src/entry1', './src/entry2']&#125;;module.exports = config; 对象语法一般适用于分离 应用程序(app) 和 第三方库(vendor) 入口。 webpack.config.js 12345678const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;;module.exports = config; 配置动态入口假如项目里有多个页面需要为每个页面的入口配置一个 Entry ，但这些页面的数量可能会不断增长，则这时 Entry 的配置会受到到其他因素的影响导致不能写成静态的值。 webpack.config.js12345678910111213141516// 同步函数entry: () =&gt; &#123; return &#123; a:'./pages/a', b:'./pages/b', &#125;&#125;;// 异步函数entry: () =&gt; &#123; return new Promise((resolve)=&gt;&#123; resolve(&#123; a:'./pages/a', b:'./pages/b', &#125;); &#125;);&#125;; 输出上面既然已经有入口文件了，那么 webpack 执行了一系列操作之后，生成的新的打包后的文件应该放到哪儿呢，所以我们需要指定一下。 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名 目标输出目录 path 的绝对路径 基本用法webpack.config.js123456789101112const path = require('path');const config = &#123; entry: './src/index.js', output: &#123; // 最基本的两个配置要求 filename: 'bundle.js', // 输出文件的文件名 path: path.resolve(__dirname, 'dist') // 目标输出目录 path 的绝对路径，这里必须是绝对路径 &#125;&#125;;module.exports = config; 多个入口起点如果配置创建了多个单独的 “chunk”，则应该使用占位符（参考内置的占位符变量）来确保每个文件具有唯一的名称。 webpack.config.js1234567891011const path = require('path');const config = &#123; output: &#123; // 最基本的两个配置要求 filename: '[name]-bundle.js', // 输出文件的文件名 path: path.resolve(__dirname, 'dist') // 目标输出目录 path 的绝对路径 &#125;&#125;;module.exports = config; 内置的占位符变量 变量名 含义 id Chunk 的唯一标识，从0开始 name Chunk 的名称 hash Chunk 的唯一标识的 Hash 值 chunkhash Chunk 内容的 Hash 值 loaderloader 用于对模块的源代码进行转换。loader 可以使你在 import、require() 或”加载”模块时预处理文件。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 基本使用例如：加载 css 模块： 安装对应的 loader 1npm install --save-dev style-loader css-loader 然后指示 webpack 对每个 .css 使用 css-loader 和 style-loader webpack.config.js 1234567module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader' &#125; ] &#125;&#125;; 配置 loaderrules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 rules 时大致通过以下方式： 条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件 应用规则：对选中后的文件通过 use 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数 重置顺序：一组 Loader 的执行顺序默认是从右到左（从下到上、从后到前）执行，通过 enforce 选项可以让其中一个 Loader 的执行顺序放到最前或者最后 在 Loader 需要传入很多参数时，你还可以通过一个 Object 来描述 test include exclude 这三个命中文件的配置项可以传入一个字符串或正则，其实它们还都支持数组类型 具体使用：1234567891011121314151617181920212223242526272829303132333435363738module.exports = &#123; module: &#123; rules: [ &#123; // 命中 JavaScript 文件 test: [ /\\.js?$/, /\\.jsx?$/ ], // 用 babel-loader 转换 JavaScript 文件 // ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度 use: [ &#123; loader:'babel-loader', options:&#123; cacheDirectory:true, &#125;, // enforce:'post' 的含义是把该 Loader 的执行顺序放到最后 // enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面 enforce:'post' &#125; ], // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, 'src') &#125;, &#123; // 命中 SCSS 文件 test: /\\.scss$/, // 使用一组 Loader 去处理 SCSS 文件。 // 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。 use: ['style-loader', 'css-loader', 'sass-loader'], // 排除 node_modules 目录下的文件 exclude: path.resolve(__dirname, 'node_modules') &#125; ] &#125;&#125;; pluginsPlugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。 基本使用比如每次打包文件到 dist 文件夹下，就可能导致文件夹下面的文件过多，内容过大，那么此时我们可能需要在打包之前先将 dist 文件下的文件都删除掉，但是每次都手动删除岂不是太麻烦，此时我们就可以使用 clean-webpack-plugin 插件来帮助我们清理 dist 文件夹 插件安装1npm install clean-webpack-plugin --save-dev webpack.config.js1234567const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; plugins: [ new CleanWebpackPlugin(['dist']) ]&#125; 其他概念术语资源(Asset)这是一个普遍的术语，用于图片、字体、媒体，还有一些其他类型的文件，常用在网站和其他应用程序。这些文件通常最终在输出(output ) 中成为单个文件，但也可以通过一些东西内联，像 style-loader 或者 url-loader 。 Bundle由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 Chunk这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk) 和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。 依赖关系图(Dependency Graph)有时候一个文件依赖于其他文件，webpack 将其视为依赖关系(dependency)。从一个或多个入口点开始，webpack 递归构建一个依赖关系图，里面包含了你的应用程序需要的所有模块/资源(mudule/asset)。 模块(Module)提供比完整程序接触面(surface area)更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 模块解析(Module Resolution)：一个模块可以作为另一个模块的依赖模块，resolver 是一个库( library )用于帮助找到模块的绝对路径… 模块将在 resolve.modules 中指定的所有目录内搜索。 Tree Shaking移除未使用/多余的代码，或者更准确地说，只导入引用的代码。编译器(compiler)（例如 webpack）将通过分析各种 import 语句和引入代码的使用情况，来确定哪些部分的依赖关系被实际使用，删除不是“树”的部分，以实现此功能 第三方库入口点(Vendor Entry Point) 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的，允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle。可以帮助你在 webpack 中实现被称为长效缓存的通用模式。 优化 Bundle 分离(Bundle Splitting)这个流程提供一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。 代码分离(Code Splitting)指将代码分离到每个 bundles/chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。 总结本文简单介绍了一下 Webpack 的作用以及 Webpack 核心概念的用法。想了解更多的朋友可以参考我的下一篇文章：从零开始搭建一个 Webpack 开发环境配置（附 Demo）","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://beichensky.github.io/tags/Webpack/"}]},{"title":"React 组件生命周期详解","date":"2019-01-21T07:57:59.000Z","path":"20190121/react-component-lifecycle/","text":"本文详细介绍了 React 生命周期的用法以及各个阶段的生命周期进行，并且用实例代码做了详细演示。代码位置 话不多说，先上图 React生命周期图解 上图是基于 React 16.4 之后的生命周期图解。如感觉不对，请先查看 React 版本 React 生命周期详解各个阶段的生命周期函数constructor 构造函数在 React 组件挂载之前被调用，实现 React.Component 的子类的构造函数时，要在第一行加上 super(props)。 React 构造函数通常只用于两个目的： 通过分配一个对象到 this.state 来初始化本地 state 将 事件处理程序 方法绑定到实例 如果没有初始化状态（state），并且没有绑定方法，通常不需要为 React 组件实现一个构造函数。 不需要在构造函数中调用 setState()，只需将初始状态设置给 this.state 即可 。 static getDerivedStateFromProps()getDerivedStateFromProps 在每次调用 render 方法之前调用。包括初始化和后续更新时。 包含两个参数：第一个参数为即将更新的 props 值，第二个参数为之前的 state 值 返回值：返回为 null 时，不做任何副作用处理。倘若想更新某些 state 状态值，则返回一个对象，就会对 state 进行修改 该生命周期是静态函数，属于类的方法，其作用域内是找不到 this 的 render()render() 方法是类组件中唯一必须的方法，其余生命周期不是必须要写。组件渲染时会走到该生命周期，展示的组件都是由 render() 生命周期的返回值来决定。 注意：如果 shouldComponentUpdate() 方法返回 false ，render() 不会被调用。 componentDidMount()在 React 组件装载(mounting)（插入树）后被立即调用。 componentDidMount 生命周期是进行发送网络请求、启用事件监听的好时机 如果有必要，可以在此生命周期中立刻调用 setState() shouldComponentUpdate(nextProps, nextState)在组件准备更新之前调用，可以控制组件是否进行更新，返回 true 时组件更新，返回 false 组件不更新。 包含两个参数，第一个是即将更新的 props 值，第二个是即将跟新后的 state 值，可以根据更新前后的 props 或 state 进行判断，决定是否更新，进行性能优化 不要 shouldComponentUpdate 中调用 setState()，否则会导致无限循环调用更新、渲染，直至浏览器内存崩溃 getSnapshotBeforeUpdate(prevProps, prevState)getSnapshotBeforeUpdate() 在最近一次的渲染输出被提交之前调用。也就是说，在 render 之后，即将对组件进行挂载时调用。 它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 componentDidUpdate()。如不需要传递任何值，那么请返回 null componentDidUpdate(prevProps, prevState, snapshot)componentDidUpdate() 在更新发生之后立即被调用。这个生命周期在组件第一次渲染时不会触发。 可以在此生命周期中调用 setState()，但是必须包含在条件语句中，否则会造成无限循环，最终导致浏览器内存崩溃 componentWillUnmount()componentWillUnmount() 在组件即将被卸载或销毁时进行调用。 此生命周期是取消网络请求、移除监听事件、清理 DOM 元素、清理定时器等操作的好时机 注意：componentWillMount()、componentWillUpdate()、componentWillReceiveProps() 即将被废弃，请不要再在组件中进行使用。因此本文不做讲解，避免混淆。 生命周期执行顺序挂载时 constructor() static getDerivedStateFromProps() render() componentDidMount() 更新时 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 卸载时 componentWillUnmount() 生命周期中是否可以调用 setState()初始化 state constructor() 可以调用 setState() componentDidMount() 根据判断条件可以调用 setState() componentDidUpdate() 禁止调用 setState() shouldComponentUpdate() getSnapshotBeforeUpdate() render() componentWillUnmount() 实例演示源码地址 下面根据一个父子组件的props 改变、state 改变以及子组件的挂载/卸载等事件，对各生命周期执行顺序进行理解，有兴趣的同学可以一起看一下，也可以下载代码自己进行测试。 编写组件代码父组件：Parent.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React, &#123; Component &#125; from 'react';import Child from './Child.js';const parentStyle = &#123; padding: 40, margin: 20, border: '1px solid pink'&#125;const TAG = \"Parent 组件：\"export default class Parent extends Component &#123; constructor(props) &#123; super(props); console.log(TAG, 'constructor'); this.state = &#123; num: 0, mountChild: true &#125; &#125; static getDerivedStateFromProps(nextProps, prevState) &#123; console.log(TAG, 'getDerivedStateFromProps'); return null; &#125; componentDidMount() &#123; console.log(TAG, 'componentDidMount'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(TAG, 'shouldComponentUpdate'); return true; &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log(TAG, 'getSnapshotBeforeUpdate'); return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(TAG, 'componentDidUpdate'); &#125; componentWillUnmount() &#123; console.log(TAG, 'componentWillUnmount'); &#125; /** * 修改传给子组件属性 num 的方法 */ changeNum = () =&gt; &#123; let &#123; num &#125; = this.state; this.setState(&#123; num: ++ num &#125;); &#125; /** * 切换子组件挂载和卸载的方法 */ toggleMountChild = () =&gt; &#123; let &#123; mountChild &#125; = this.state; this.setState(&#123; mountChild: !mountChild &#125;); &#125; render() &#123; console.log(TAG, 'render'); const &#123; num, mountChild &#125; = this.state; return ( &lt;div style=&#123; parentStyle &#125;&gt; &lt;div&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;button onClick=&#123; this.changeNum &#125;&gt;改变传给子组件的属性 num&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;button onClick=&#123; this.toggleMountChild &#125;&gt;卸载 / 挂载子组件&lt;/button&gt; &lt;/div&gt; &#123; mountChild ? &lt;Child num=&#123; num &#125; /&gt; : null &#125; &lt;/div&gt; ) &#125;&#125; 子组件：Child.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; Component &#125; from 'react'const childStyle = &#123; padding: 20, margin: 20, border: '1px solid black'&#125;const TAG = 'Child 组件：'export default class Child extends Component &#123; constructor(props) &#123; super(props); console.log(TAG, 'constructor'); this.state = &#123; counter: 0 &#125;; &#125; static getDerivedStateFromProps(nextProps, prevState) &#123; console.log(TAG, 'getDerivedStateFromProps'); return null; &#125; componentDidMount() &#123; console.log(TAG, 'componentDidMount'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(TAG, 'shouldComponentUpdate'); return true; &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log(TAG, 'getSnapshotBeforeUpdate'); return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(TAG, 'componentDidUpdate'); &#125; componentWillUnmount() &#123; console.log(TAG, 'componentWillUnmount'); &#125; changeCounter = () =&gt; &#123; let &#123; counter &#125;= this.state; this.setState(&#123; counter: ++ counter &#125;); &#125; render() &#123; console.log(TAG, 'render'); const &#123; num &#125; = this.props; const &#123; counter &#125; = this.state; return ( &lt;div style=&#123; childStyle &#125;&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;p&gt;父组件传过来的属性 num ： &#123; num &#125;&lt;/p&gt; &lt;p&gt;自身状态 counter ： &#123; counter &#125;&lt;/p&gt; &lt;button onClick=&#123; this.changeCounter &#125;&gt;改变自身状态 counter&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 从五种组件状态改变的时机来探究生命周期的执行顺序一、父子组件初始化父子组件第一次进行渲染加载时，界面展示为： 初始化展示界面 控制台中的 log 打印顺序为： Parent 组件： constructor() Parent 组件： getDerivedStateFromProps() Parent 组件： render() Child 组件： constructor() Child 组件： getDerivedStateFromProps() Child 组件： render() Child 组件： componentDidMount() Parent 组件： componentDidMount() 二、修改子组件自身状态 state 时点击子组件中的 改变自身状态 按钮，则界面上 自身状态 counter： 的值会 + 1，控制台中的 log 打印顺序为： Child 组件： getDerivedStateFromProps() Child 组件： shouldComponentUpdate() Child 组件： render() Child 组件： getSnapshotBeforeUpdate() Child 组件： componentDidUpdate() 三、修改父组件中传入子组件的 props 时点击父组件中的 改变传给子组件的属性 num 按钮，则界面上 父组件传过来的属性 num： 的值会 + 1，控制台中的 log 打印顺序为： Parent 组件： getDerivedStateFromProps() Parent 组件： shouldComponentUpdate() Parent 组件： render() Child 组件： getDerivedStateFromProps() Child 组件： shouldComponentUpdate() Child 组件： render() Child 组件： getSnapshotBeforeUpdate() Parent 组件： getSnapshotBeforeUpdate() Child 组件： componentDidUpdate() Parent 组件： componentDidUpdate() 四、卸载子组件点击父组件中的 卸载 / 挂载子组件 按钮，则界面上子组件会消失，控制台中的 log 打印顺序为： Parent 组件： getDerivedStateFromProps() Parent 组件： shouldComponentUpdate() Parent 组件： render() Parent 组件： getSnapshotBeforeUpdate() Child 组件： componentWillUnmount() Parent 组件： componentDidUpdate() 五、重新挂载子组件再次点击父组件中的 卸载 / 挂载子组件 按钮，则界面上子组件会重新渲染出来，控制台中的 log 打印顺序为： Parent 组件： getDerivedStateFromProps() Parent 组件： shouldComponentUpdate() Parent 组件： render() Child 组件： constructor() Child 组件： getDerivedStateFromProps() Child 组件： render() Parent 组件： getSnapshotBeforeUpdate() Child 组件： componentDidMount() Parent 组件： componentDidUpdate() 父子组件生命周期执行顺序总结： 当子组件自身状态改变时，不会对父组件产生副作用的情况下，父组件不会进行更新，即不会触发父组件的生命周期 当父组件中状态发生变化（包括子组件的挂载以及）时，会触发自身对应的生命周期以及子组件的更新 render 以及 render 之前的生命周期，则 父组件 先执行 render 以及 render 之后的声明周期，则子组件先执行，并且是与父组件交替执行 当子组件进行卸载时，只会执行自身的 componentWillUnmount 生命周期，不会再触发别的生命周期 可能总结的不好，不是很完整。只是根据一般情况进行的总结。有不妥之处，希望各位朋友能够多多指正。 示例代码下载源码地址 还没看够？移步至：React Component 官网","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"生命周期","slug":"生命周期","permalink":"https://beichensky.github.io/tags/生命周期/"}]},{"title":"PureComponent 使用注意事项以及源码解析","date":"2019-01-16T09:42:05.000Z","path":"20190116/pure-component/","text":"本文简要介绍了 React 中 PureComponent 与 Component 的区别以及使用时需要注意的问题，并在后面附上了源码解析，希望对有疑惑的朋友提供一些帮助。 前言先介绍一下 PureComponent，平时我们创建 React 组件一般是继承于 Component，而 PureComponent 相当于是一个更纯净的 Component，对更新前后的数据进行了一次浅比较。只有在数据真正发生改变时，才会对组件重新进行 render。这样的话可以大大提高组件的性能。 对比 Component 和 PureComponent继承 Component 创建组件App.js里面的 state 有两个属性，text 属性是基本数据类型，todo 属性是引用类型。针对这两种数据类型分别进行对比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Component, PureComponent &#125; from 'react';import './App.css';class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; text: 'Hello', todo: &#123; id: 1, message: '学习 React' &#125; &#125; &#125; /** * 修改 state 中 text 属性的函数 */ changeText = () =&gt; &#123; this.setState(&#123; text: 'World' &#125;); &#125; /** * 修改 state 中 todo 对象的函数 */ changeTodo = () =&gt; &#123; this.setState(&#123; id: 1, message: '学习 Vue' &#125;); &#125; render() &#123; // 打印 log，查看渲染情况 console.log('tag', 'render'); const &#123; text, todo &#125; = this.state; return ( &lt;div className=\"App\"&gt; &lt;div&gt; &lt;span&gt;文字：&#123; text &#125;&lt;/span&gt; &lt;button onClick=&#123; this.changeText &#125;&gt;更改文字&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;div&gt; &lt;span&gt;计划：&#123; todo.message &#125;&lt;/span&gt; &lt;button onClick=&#123; this.changeTodo &#125;&gt;更改计划&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 浏览器中界面 界面显示 测试运行项目，打开控制台，此时看到只有一个 log：tag render 点击 5 次 ·更改文字· 按钮，可以看到控制台再次多打印了 5 次 log，浏览器中的 Hello 文字变成了 World 点击 5 次 ·更改计划· 按钮，控制台一样多打印 5 次 log，浏览器中的 学习 React 计划变成了 学习 Vue 分析一下，其实 5 次点击中只有一次是有效的，后来的数据其实并没有真正改变，但是由于依然使用了 setState()，所以还是会重新 render。所以这种模式是比较消耗性能的。 继承 PureComponent其实 PureComponent 用法也是和 Component 一样，只不过是将继承 Component 换成了 PureComponent。 App.js12345678910...// 上面的代码和之前一致class App extends PureComponent &#123; // 下面的代码也和之前一样 ...&#125;export default App; 浏览器中界面 界面显示 测试和上面 Component 的测试方式一样 点击 5 次 ·更改文字· 按钮，可以看到控制台只多打印了一次 log，浏览器中的 Hello 文字变成了 World 点击 5 次 ·更改计划· 按钮，控制台只多打印了一次 log，浏览器中的 学习 React 计划变成了 学习 Vue 由此可以看出，使用 PureComponent 还是比较节省性能的，即便是使用了 setState()，也会在数据真正改变时才会重新渲染组件 使用时可能遇到的问题下面我们将代码中 changeText 和 changeTodo 方法修改一下 123456789101112131415161718192021/** * 修改 state 中 text 属性的函数 */changeText = () =&gt; &#123; let &#123; text &#125; = this.state; text = 'World'; this.setState(&#123; text &#125;);&#125;/** * 修改 state 中 todo 对象的函数 */changeTodo = () =&gt; &#123; let &#123; todo &#125; = this.state; todo.message = \"学习 Vue\"; this.setState(&#123; todo &#125;);&#125; 此时我们再重新测试一下： 点击 ·更改文字· 按钮，控制台多打印一次 log，浏览器中的 Hello 文字变成了 World 注意：点击 ·更改计划· 按钮，控制台没有 log 打印，浏览器中的计划也没有发生改变 为什么代码修改之后，明明 todo 里的 message 属性也已经发生变化了，调用 setState()，却不进行渲染了呢？这是因为 PureComponent 在调用 shouldComponent 生命周期的时候，对数据进行了一次浅比较，判断数据是否发生改变，没发生改变，返回 false，改变了，就返回 true。那这个浅比较的机制是怎么做的呢？我们一起看下面源码解析，来分析一下。 PureComponent 源码解析ReactBaseClasses.js （Github 代码位置）12345678910111213141516171819function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;/** * Convenience component with default shallow equality check for sCU. */function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);pureComponentPrototype.isPureReactComponent = true; 可以看到 PureComponent 的使用和 Component 一致，只时最后为其添加了一个 isPureReactComponent 属性。ComponentDummy 就是通过原型模拟继承的方式将 Component 原型中的方法和属性传递给了 PureComponent。同时为了避免原型链拉长导致属性查找的性能消耗，通过 Object.assign 把属性从 Component 拷贝了过来。 但是这里只是 PureComponent 的声明创建，没有显示如何进行比较更新的，那我们继续看下面的代码。 ReactFiberClassComponent.js （Github 代码位置）123456789101112131415161718function checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext,) &#123; ... // 这里根据上面 PureComponent 设置的属性 isPureReactComponent 判断一下，如果是 PureComponent，就会走里面的代码，将比较的值返回出去 if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123; return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) ); &#125;&#125; shallowEqual 是在 share 包中一个工具方法，看一下其中的内部实现吧。 shallowEqual.js （Github 代码位置）1234567891011121314151617181920212223242526272829303132333435363738394041424344import is from './objectIs';const hasOwnProperty = Object.prototype.hasOwnProperty;/** * Performs equality by iterating through keys on an object and returning false * when any key has values which are not strictly equal between the arguments. * Returns true when the values of all keys are strictly equal. */function shallowEqual(objA: mixed, objB: mixed): boolean &#123; if (is(objA, objB)) &#123; return true; &#125; if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) &#123; return false; &#125; const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) &#123; if ( !hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]]) ) &#123; return false; &#125; &#125; return true;&#125;export default shallowEqual; 这里面还调用了 is 函数，这个函数也是 share 包中的一个工具方法。 objectIs.js （Github 代码位置）1234567891011/** * inlined Object.is polyfill to avoid requiring consumers ship their own * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is */function is(x: any, y: any) &#123; return ( (x === y &amp;&amp; (x !== 0 || 1 / x === 1 / y)) || (x !== x &amp;&amp; y !== y) // eslint-disable-line no-self-compare );&#125;export default is; PureComponent 源码分析总结由上面的源码可以发现，其实 PureComponent 和 Component 中的方法和属性基本一致，只不过 PureComponent 多了一个 isPureReactComponent 为 true 的属性。在 checkShouldComponentUpdate 的时候，会根据这个属性判断是否是 PureComponent，如果是的话，就会根据 !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) 这个判断语句的返回值作为更新依据。所以，查看了 shallowEqual 和 objectIs 的文件源码，我们可以得出 PureComponent 的浅比较结论： 先通过 is 函数判断两个参数是否相同，相同则直接返回 ture，也就是不更新组件。 根据 objectIs.js 代码可知，基本属性类型判断值是否相同（包括 NaN），引用数据类型判断是否是一个引用 若 is 函数判断为 false，则判断两个参数是否都为 对象 且 都不为 null，若任意一个 不是对象 或 任意一个为 null，直接返回 false，也就是更新组件 若前两个判断都通过，则可断定两个参数皆为对象，此时判断它们 keys 的长度是否相同，若不同，则直接返回 false，即更新组件 若 keys 长度不同，则对两个对象中的第一层属性进行比较，若都相同，则返回 true，有任一属性不同，则返回 false 总结阅读源码之后，可以发现之前我们修改了 changeTodo 方法的逻辑之后，为什么数据改变，组件却依然不更新的原因了。是因为修改的是同一个对象，所以 PureComponent 默认引用相同，不进行组件更新，所以才会出现这个陷阱，在使用的过程中希望大家注意一下这个问题。 对比 PureComponent 和 Component，可以发现，PureComponent 性能更高，一般有几次有效修改，就会进行几次有效更新 为了避免出现上面所说的陷阱问题，建议将 React 和 Immutable.js 配合使用，因为 Immutable.js 中的数据类型都是不可变，每个变量都不会相同。但是由于 Immutable 学习成本较高，可以在项目中使用 immutability-helper 插件，也能实现类似的功能。关于 immutability-helper 的使用，可以查看我的另一篇博客：immutability-helper 插件的基本使用 虽然 PureComponent 提高了性能，但是也只是对数据进行了一次浅比较，最能优化性能的方式还是自己在 shouldComponent 生命周期中实现响应逻辑 关于 PureComponent 浅比较的总结可以查看上面的PureComponent 源码分析总结","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"PureComponent","slug":"PureComponent","permalink":"https://beichensky.github.io/tags/PureComponent/"}]},{"title":"在 Create React App 中启用 Sass 和 Less","date":"2019-01-15T05:12:23.000Z","path":"20190115/cra-sass-less/","text":"本文介绍了如何在 Create React App 脚手架中启用 Sass 和 Less 前言关于创建 create-react-app 项目请查看： create-react-app 的安装与创建 关于在 less 和 sass 如何在 create-react-app 启用 CSS Modules，请查看我的上一篇文章：在 Create React App 中使用 CSS Modules 启用 Sass 语法编写 CSS create-react-app 脚手架中已经添加了 sass-loader 的支持，所以只需要安装 node-sass 插件即可 安装 node-sass 插件1234$ npm install node-sass --save# 或者# $ yarn add node-sass 用法：编写 sass 文件：App.scss1234567.App &#123; text-align: center; &amp;-logo &#123; animation: App-logo-spin infinite 20s linear; height: 40vmin; &#125;&#125; 在 js 文件中直接使用：改写 App.js 文件1234567891011121314151617import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.scss';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; 在浏览器中查看效果运行项目，此时在浏览器中即可查看到 logo 图片在缓慢转动 启用 Less 语法编写 CSS 由于 create-react-app 脚手架中并没有配置关于 less 文件的解析，所以我们需要自己进行配置。需要安装的插件 less， less-loader。 添加 Less 相关配置 在命令行运行 npm run eject 命令 此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆 运行完成之后，打开 config 目录下的 webpack.config.js 文件，找到 // style files regexes 注释位置，仿照其解析 sass 的规则，在下面添加两行代码 123// 添加 less 解析规则const lessRegex = /\\.less$/;const lessModuleRegex = /\\.module\\.less$/; 找到 rules 属性配置，在其中添加 less 解析配置 12345678910111213141516171819202122232425// Less 解析配置&#123; test: lessRegex, exclude: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, 'less-loader' ), sideEffects: true,&#125;,&#123; test: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent, &#125;, 'less-loader' )&#125; 此时配置完成，安装 less 和 less-loader 插件即可 1$ npm install less less-loader --save 用法 以下代码根据上面 sass 用法中的文件进行修改 编写 less 文件：App.less1234567.App &#123; text-align: center; &amp;-logo &#123; animation: App-logo-spin infinite 20s linear; height: 40vmin; &#125;&#125; 在 js 文件中直接使用：改写 App.js 文件1234567891011121314151617import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.less';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; 在浏览器中查看效果运行项目，此时在浏览器中即可查看到 logo 图片在缓慢转动","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"Sass","slug":"Sass","permalink":"https://beichensky.github.io/tags/Sass/"},{"name":"Less","slug":"Less","permalink":"https://beichensky.github.io/tags/Less/"}]},{"title":"在 Create React App 中使用 CSS Modules","date":"2019-01-14T08:02:02.000Z","path":"20190114/cra-css-modules/","text":"本文介绍了如何在 Create React App 脚手架中使用 CSS Modules 的两种方式 前提条件 请先进行全局安装 create-react-app 插件哈，安装命令：npm install create-react-app -g 先使用 create-react-app 命令下载一个脚手架工程，安装命令：12345678# 使用 npx$ npx create-react-app my-app# 使用 npm $ npm init npx create-react-app my-app# 使用 yarn$ yarn create react-app my-app 运行项目1234567$ cd my-app# 使用 npm$ npm start# 或者使用yarn# yarn start 在浏览器中输入 http://localhost:3000 查看项目效果 使用 CSS Module 的第一种方式 create-react-app 中内置了使用 CSS Modules 的配置，当前方式就是使用 create-react-app 内置的用法 方式 将所有的 .css/.lee/.scss 等样式文件都修改成 .module.css/.module.less/.module.scss 等。即可使用 CSS Modules 的方式进行引入使用了。 用法编写一个 css 文件：Button.module.css123.error &#123; background-color: red;&#125; 在编写一个普通的 css 文件：another-stylesheet.css123.error &#123; color: red;&#125; 在 js 文件中使用 CSS Modules 的方式进行引用：Button.js12345678910import React, &#123; Component &#125; from 'react';import styles from './Button.module.css'; // 使用 CSS Modules 的方式引入import './another-stylesheet.css'; // 普通引入class Button extends Component &#123; render() &#123; // reference as a js object return &lt;button className=&#123;styles.error&#125;&gt;Error Button&lt;/button&gt;; &#125;&#125; 在浏览器中查看效果此时 Button 组件的背景颜色是红色，但是字体颜色却不是红色，因为使用了 Css Modules 之后，普通的 css 样式就不起效果了，需要用全局的方式编写才可以(:global)。最后添加到元素上的样式结果为：&lt;button class=&quot;Button_error_ax7yz&quot;&gt;Error Button&lt;/button&gt; 使用 CSS Module 的第二种方式方式 在命令行运行 npm run eject 命令 此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆 运行完成之后，打开 config 目录下的 webpack.config.js 文件，找到 test: cssRegex 这一行 在 use 属性执行的方法中添加 modules: true，如下图： 用法 和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了 编写一个 css 文件：Button.css123.error &#123; background-color: red;&#125; 再编写一个普通的 css 文件：another-stylesheet.css123.error &#123; color: red;&#125; 在 js 文件中使用 CSS Modules 的方式进行引用：Button.js12345678910import React, &#123; Component &#125; from 'react';import styles from './Button.css'; // 可以直接使用 CSS Modules 的方式引入了import './another-stylesheet.css'; // 普通引入class Button extends Component &#123; render() &#123; // reference as a js object return &lt;button className=&#123;styles.error&#125;&gt;Error Button&lt;/button&gt;; &#125;&#125; 在浏览器中查看效果此时 Button 组件的背景颜色是红色，但是字体颜色却不是红色，因为使用了 Css Modules 之后，普通的 css 样式就不起效果了，需要用全局的方式编写才可以(:global)。最后添加到元素上的样式结果为：&lt;button class=&quot;Button_error_ax7yz&quot;&gt;Error Button&lt;/button&gt; 如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加modules: true 即可。 注意 默认 create-react-app 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置。 关于如何在 create-react-app 脚手架中启用 sass 和 less 语法，可参考我的下一篇文章： 在 Create React App 中启用 Sass 和 Less。","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"CSS Modules","slug":"CSS-Modules","permalink":"https://beichensky.github.io/tags/CSS-Modules/"}]},{"title":"使用 redux-devtools-extension 查看 Redux 中状态变化","date":"2019-01-09T10:57:00.000Z","path":"20190109/redux-devtools/","text":"本文简单介绍了在 Redux 使用 redux-devtools-extension 插件的用法，可以对状态变化进行可视化查看。 本文例子源码源码地址 欢迎 Star！欢迎 Watch！ 前提条件请先安装 redux：npm install redux -S redux-devtools-extension 的使用 用法非常简单，只需要三步，而且代码修改极少，跟着下面的提示进行操作即可 插件安装1$ npm install redux-devtools-extension -D 在谷歌浏览器中安装 Redux DevTools 如果可以访问谷歌扩展程序，直接在 Chrome 网上应用商店下载即可 如果不能访问，可以百度搜索资源进行下载 下载完成之后 可以在浏览器工具栏右上角可以看到图标（当应用可以使用该工具时，图标变亮） 在页面上右键可以看到 Redux DevTools 选项 打开控制台，在菜单栏可以找到 Redux 菜单栏此时项目中尚未应用工具，面板应该这样显示： 在代码中添加用法12345const &#123; createStore &#125; = require('redux');// 引入工具插件const &#123; composeWithDevTools &#125; = require('redux-devtools-extension');// 创建 store 时，传入参数const store = createStore(reducer, composeWithDevTools()); 此时启动应用，在控制台找到 Redux 菜单，点击切换，就可以看到上面提到的正常显示的场景： 应用成功 扩展当 Redux 包含其他中间件进行使用时123456789// 创建 Store 的参数稍微发生改变const &#123; createStore, applyMiddleware &#125; = require('redux');// 引入工具插件const &#123; composeWithDevTools &#125; = require('redux-devtools-extension');// 创建 Storeconst storeCompose = createStore(reducer, composeWithDevTools( applyMiddleware(...middleware) // other store enhancers if any)); 只希望在开发环境使用1234567const enhancers = process.env.NODE_ENV === \"development\" ? composeWithDevTools( applyMiddleware(middleware) // other store enhancers if any ) : applyMiddleware(thunk);const storeEnv = createStore(counters, enhancers); 官方说明更多信息可以查看：redux-devtools-extension 官方 Github","tags":[{"name":"Redux","slug":"Redux","permalink":"https://beichensky.github.io/tags/Redux/"},{"name":"redux-devtools","slug":"redux-devtools","permalink":"https://beichensky.github.io/tags/redux-devtools/"}]},{"title":"一分钟学会在 Redux 中使用 redux-thunk 进行异步操作","date":"2019-01-08T10:07:28.000Z","path":"20190108/redux-thunk/","text":"本文主要介绍了在 Redux 中使用 redux-thunk 进行异步操作。 如果对 Redux 尚不熟悉，建议先看我的前一篇博客：Redux 基础教程以及结合 React 使用方式。 最下方贴上了 applyMiddleware 和 redux-thunk 的实现源码，有兴趣的同学可以看一看。只能用两个字来形容：优秀。 在项目中引入 安装插件 1$ npm install redux-thunk; 在创建 store 时引入 redux-thunk 使用 commonJs 方式引入时要注意，这样引入才可以正常使用：const thunk = require(&#39;redux-thunk&#39;).default 123456import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';// 创建 store// applyMiddleware，在 Redux 中使用中间件时，就需要使用 applyMiddleware() 这个函数进行包裹const store = createStore(reducer, applyMiddleware(thunk)); 在 action 中的书写方式 123456789101112131415161718192021222324252627// 异步请求成功需要用到的同步 action 创建函数function actionSuccess(msg) &#123; return &#123; type: 'SUCCESS', message: msg &#125;&#125;// 异步请求失败需要用到的同步 action 创建函数function actionError() &#123; return &#123; type: 'ERROR' &#125;&#125;// 暴露异步 Actionexport function asyncAction(param) &#123; // 异步 action 的固定写法，返回一个函数，第一个参数为 dispatch 函数，第二个参数为 state return (dispatch, state) =&gt; &#123; // 执行异步操作 fetch(url) .then(reponse =&gt; response.json) // 请求成功调用成功的同步 Action .then(json =&gt; dispatch(actionSuccess(actionSuccess))) .catch(error =&gt; dispatch(actionError())) &#125;&#125; 在组件中调用 在组件中和调用同步 Action 一致1store.dispatch(asyncAction(param)); 在 Reducer 中不需要处理异步 Action，还是只关注同步 Action 即可。因为异步 Action 结束之后还是会调用同步 Action 发送数据更新指令 实现原理本文只是单纯的记录一下 redux-thunk 中间件如何进行使用，想要深入了解 applyMiddleware 和 redux-thunk 实现原理的朋友可以移步至阮老师的 Redux 入门教程（二）：中间件与异步操作 applyMiddleware 源码1234567891011121314151617181920212223242526272829function applyMiddleware() &#123; for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key &lt; _len; _key++) &#123; middlewares[_key] = arguments[_key]; &#125; return function (createStore) &#123; return function () &#123; var store = createStore.apply(void 0, arguments); var _dispatch = function dispatch() &#123; throw new Error(\"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\"); &#125;; var middlewareAPI = &#123; getState: store.getState, dispatch: function dispatch() &#123; return _dispatch.apply(void 0, arguments); &#125; &#125;; var chain = middlewares.map(function (middleware) &#123; return middleware(middlewareAPI); &#125;); _dispatch = compose.apply(void 0, chain)(store.dispatch); return _objectSpread(&#123;&#125;, store, &#123; dispatch: _dispatch &#125;); &#125;; &#125;;&#125; redux-thunk 源码1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk;","tags":[{"name":"Redux","slug":"Redux","permalink":"https://beichensky.github.io/tags/Redux/"},{"name":"thunk","slug":"thunk","permalink":"https://beichensky.github.io/tags/thunk/"}]},{"title":"Redux 基础教程以及结合 React 使用方式","date":"2019-01-08T06:22:22.000Z","path":"20190108/react-redux-basic/","text":"本文教你实现一个最简单的 Redux 应用，以及结合 React 如何使用 Redux简介概念状态管理工具，使用之后可以清晰的知道应用里发生了什么。数据如何修改，如何更新的。 出现的动机以前我刚接触 Redux 这类状态管理工具的时候就在想：为什么需要这些东西呢，刷新数据就消失了，也不能持久化存储数据，有啥用呢？后来慢慢的应用越做越多，功能越做越复杂，就会发现，很多数据什么原因修改的，什么时候修改的，自己是一脸懵逼。啥也想不起来了，维护起来真的痛苦。到了这个时候才发现 Redux 这类工具的厉害之处。名字也很应景的，状态管理工具。说的很清楚了，就是管理状态的。让数据变化过程尽可能的清晰、可预测。 在项目中添加 Redux 并不是必须的。请根据项目需求选择是否引入 Redux 三大原则 单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改为了描述 action 如何改变 state tree ，你需要编写 reducers。 Redux 三要素 Action（将要发生的操作） Reducer（根据 action 更新 state，是一个纯函数） 提供 combineReducers(reducers) 函数组合多个 reducer 存放 state 数据的 Store（将 action 和 reducer 联系到一起的对象） 提供 getState() 方法获取 state 提供 dispatch(action) 方法更新 state 通过 subsctibe(listener) 注册监听器 通过 subscribr(listener) 返回的函数注销监听器 示例代码说了这边文章是教你创建一个最简单的 Redux 应用，那我们下面就看看使用一个 Redux 到底能有多简单，多快呢 使用前先引入 Redux：npm install redux -S 先来个 Action三要素之一不就是有 Action 么，有我们就先写一个 Action 创建函数呗 Action 创建函数，是一个返回 action 的函数，非必须这样写，只是更方便移植和复用，建议使用 Action 创建函数来生成 action 12345function increment() &#123; return &#123; type: \"INCREMENT\" &#125;&#125; 有了Action，还要有 Reducer 来执行更新啊Reducer 既然必不可少，就在写一个 Reducer。（这里可能会有点迷糊，reducer 不是一个对象，而是一个返回更新后 state 的纯函数） 12345678910111213/*** counters 就是一个 reducer，根据传入的 action 的 type 不同，返回一个新的 state 数据*/// 先初始化 stateconst initCounter = 0;function counters(state = initCounter, action) &#123; switch(action.type) &#123; case 'INCREMENT': return state ++; default: return state; &#125;&#125; 还得有一个存放 state 数据的 store 吧现在要把我们写好的 Action 和 Reducer 连接起来 先通过 reducer 创建 store 123const &#123; createStore &#125; = require('redux');const store = createStore(counters); 通过 store.dispatch(action) 将 action 发送给 reducer，更新 state 1store.dispatch(increment()); 查看结果就这三步，操作完了吧，那我们现在可以看一下结果了 12// 通过 store.getState() 获取 State 数据console.log('counters: ', store.getState()); // =&gt; counters： 1 过程总结：创建一个操作指令 action -&gt; 创建一个 reducer -&gt; 通过 createStore(reducer) 创建一个 store -&gt; 通过 store.dispatch(action) 执行 reducer 中的更新操作，更新 store 中的数据 这些就是 Redux 的核心用法，有没有感觉很简单的，有兴趣的话可以跟我一起继续往下，看一看结合 React 该如何使用呢。 结合 React 使用React-Redux用来组合 React 和 Redux 配合使用的插件 以 create-react-app 脚手架为例，请先使用 create-react-app 创建一个本地项目。本例中默认 create-react-app 已全局安装过了 12$ npm npm init react-app react-redux-todos$ cd react-redux-todos 插件安装1$ npm install redux react-redux -S 配合组件使用 在组件根目录使用 react-redux 提供的 Prodiver 标签包裹 12345import &#123; Provider &#125; from 'react-redux';&lt;Provider store=&#123; store &#125;&gt; ...&lt;/Provider&gt; 在需要用到 state 或 action 的组件中使用 connect 高阶组件进行包装 12345678910111213141516171819import &#123; connect &#125; from 'react-redux';import &#123; createAction &#125; from './actions'// mapStateToProps 编写方式const mapStateToProps = (state) =&gt; &#123; return &#123; reducer: state.reducer &#125;&#125;// mapDispatchToProps 编写方式const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; createAction: text =&gt; dispatch(createAction(field)); &#125;&#125;// 使用 connect 将 state 和 dispatch 包装到 Component 的属性中export default connect(mapStateToProps, mapDispatchToProps)(Component); 在组件中就可以通过 this.props.reducer 和 this.props.createAction 的方式获取数据以及调用 action 了 TodoList 示例示例代码预览地址 扩展Reducer 的 combineReducers 方法当有多个 reducer 时，创建 store 之前需要将它们先进行合并12345678import &#123; combineReducers &#125; from 'redux';// 合并成一个 reducersconst reducers = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;); Store 的 subsctibe 方法 调用 store.subsctibe(listener) 注册监听事件store 中的数据发生变化时，就会调用 listener 函数 1234/** * 通过 store.subscribe(function) 注册一个监听器。每次 state 更新时，都会打印输出日志 */store.subscribe(() =&gt; console.log(store.getState())); store.subsctibe(listener) 的返回值是一个 注销监听的函数 /** * store.subscribe(func) 会返回一个函数，执行这个函数可以注销监听器 */ // 返回一个函数 unsubscribe const unsubscribe = store.subscribe(() =&gt; console.log(store.getState())); // 执行这个函数可以注销监听器 unsubscribe(); 如果还没看够Redux 中文文档这里有关于 Redux 最详细的介绍和讲解，我就不多此一举了，有兴趣的同学可以去看看哈。","tags":[{"name":"Redux","slug":"Redux","permalink":"https://beichensky.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"}]},{"title":"immutability-helper 插件的基本使用（附源码）","date":"2019-01-04T08:30:08.000Z","path":"20190104/immutability-helper-basic/","text":"本文介绍了 immutability-helper 插件的基本使用，详细介绍了相关 API 的用法及注意事项。 概念先理解一下 Immutable 的概念，Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。但是由于 Immutable 的 API 和用法学习起来比较困难，所以可以使用 immutability-helper 这个工具来对原生JS对象进行操作。本文主要是对 immutability-helper 的用法做一个讲解。 源码源码位置 欢迎 Star！欢迎 Watch！ 注意事项总结 immutability-helper 不会对原有对象进行修改，只是会返回一个新的对象 $push、$unshift、$splice 的使用目标必须是数组，否则会报错 $add、$remove 的使用目标必须是 Set 或 Map 其余 API 的使用目标可以是任意数据 $splice 的参数是一个操作数组，可以对目标数组一次进行多次操作，但是参数 arrays 中的项是按顺序执行的，所以使用时需要注意顺序 任意 API 均可在多层结构内使用。可查看扩展用法示例 可以同时执行多个 API 操作，但是请注意：多个 API 在一个语句中执行时，只会执行最后一个！！！。可查看注意用法示例 常用 API {$push: array} 同数组的 push 方法，将参数 array 中的所有项 push 到目标数组中 {$unshift: array} 同数组的 unshift 方法，将参数 array 中的所有项 unshift 到目标数组中 {$splice: array of arrays} 同数组的 splice 方法，对于参数 arrays 中的每一项，使用该项提供的参数对目标数组调用 splice() PS: 参数 arrays 中的项是按顺序应用的，所以顺序很重要。在操作过程中，目标的指针可能会发生变化 {$set: any} 使用 any 值替换目标 {$toggle: array of strings} 将参数 array 中提供的下标或者属性的值切换成相反的布尔值 {$unset: array of strings} 从目标对象中移除参数 array 中的键列表 {$merge: object} 将参数 object 的键与目标合并 {$apply: function} 将当前值传递给函数并用新的返回值更新它 {$add: array of objects} 向 Set 或 Map 中添加值。添加到 Set 时，参数 array 为要添加的对象数组，添加到 Map 时，参数 array 为 [key, value] 数组 {$remove: array of strings} 从 Set 或 Map 中移除参数 array 中的键列表 API 用法及示例初始化四个变量，之后的各种 API 操作都是基于这四个变量12345678const initialObject = &#123; name: 'Jack', age: 22, gender: 'Man'&#125;;const initialArray = ['a', 'b', 'c', 'd', 'e'];const initialSet = new Set(['2', '0', '1', '9', '猪', '年', '快', '乐']);const initialMap = new Map([['id', '1'], ['color', 'blue'], ['alias', 'map']]); {$push: array}123456/** * API: &#123;$push: array&#125; * 同数组的 push 方法，将数组 array 中包含的所有元素添加到 initialArray 的后面，作为一个新数组返回 */const pushArray = update(initialArray, &#123; $push: ['f'] &#125;);console.log('pushArray：', pushArray); // =&gt; [ 'a', 'b', 'c', 'd', 'e', 'f' ] {$unshift: array}123456/** * API: &#123;$unshift: array&#125; * 同数组的 unshift 方法，将数组 ['f'] 中包含的所有元素添加到 initialArray 的前面，作为一个新数组返回 */const unshiftArray = update(initialArray, &#123; $unshift: ['f'] &#125;);console.log('unshiftArray：', unshiftArray); // =&gt; [ 'f', 'a', 'b', 'c', 'd', 'e' ] {$splice: array of arrays}1234567891011/** * API: &#123;$splice: array of arrays&#125; * 同数组的 splice 方法 * 数组 arrays 中包含的是所有需要执行的操作集合 * 元素 array 中第一个元素代表下标，第二个元素代表需要删除的个数，第三个元素代表需要插入到 initialArray 中的的元素 * * PS: 1、可以在 arrays 中执行多个集合； * 2、两个操作不是同时执行，而是按顺序执行，后面的操作会在前面一个操作的执行结果上执行 */const spliceArray = update(initialArray, &#123; $splice: [[1, 2], [2, 0, 'f', 'g']] &#125;);console.log('spliceArray：', spliceArray); // =&gt; [ 'a', 'd', 'f', 'g', 'e' ] {$set: any}1234567891011/** * API: &#123;$set: any&#125; * 可以将数组或者对象中某一下标或者属性的值进行替换 */// 将 initialArray 数组中下标为 1 的元素修改为 'f'const setArray = update(initialArray, &#123; 1: &#123; $set: 'f' &#125; &#125;);console.log('setArray', setArray); // =&gt; [ 'a', 'f', 'c', 'd', 'e' ]// 将 initialObject 对象中 age 属性值修改为 26const setObject = update(initialObject, &#123; age: &#123; $set: 26 &#125; &#125;);console.log('setObject', setObject); // =&gt; &#123; name: 'Jack', age: 26, gender: 'Man' &#125; {$toggle: array of strings}12345678910/** * API: &#123;$toggle: array of strings&#125; * 可以将数组或者对象中下标集合或者属性集合的值进行切换：任何 Truthy 都会切换成 false，任何 Falsy 值都会切换成 true */// 将 initialArray 中下标为 1、2 的元素值进行切换const toggleArray = update(initialArray, &#123; $toggle: [ 1, 2 ] &#125;);console.log('toggleArray：', toggleArray); // =&gt; [ 'a', false, false, 'd', 'e' ]const toggleObject = update(initialObject, &#123; $toggle: [ 'name', 'gender' ] &#125;);console.log('toggleObject：', toggleObject); // =&gt; &#123; name: false, age: 22, gender: false &#125; {$unset: array of strings}1234567891011/** * API: &#123;$unset: array of strings&#125; * 从目标数组或者对象中移除 array 中的下标或者属性列表 */// 删除数组 initialArray 中下标为 1 和 2 的两个元素，但是保留占位const unsetArray = update(initialArray, &#123; $unset: [1, 2] &#125;);console.log('unsetArray：', unsetArray.length, unsetArray); // 5 [ 'a', &lt;2 empty items&gt;, 'd', 'e' ]// 删除对象 initialObject 中 name 和 gender 属性const unsetObject = update(initialObject, &#123; $unset: ['name', 'gender'] &#125;);console.log('unsetObject', unsetObject); // unsetObject &#123; age: 22 &#125; {$merge: object}1234567891011/** * API: &#123;$merge: object&#125; * 从目标数组或者对象中合并 object 中下标或者属性相同的元素，下标或属性相同时 object 中的元素会替换掉目标中的元素 */// 将 initialArray 数组中的 'a', 'b', 'c' 替换为 1, 2, 3const mergeArray = update(initialArray, &#123; $merge: [1, 2, 3] &#125;);console.log('mergeArray：', mergeArray); // =&gt; [ 1, 2, 3, 'd', 'e' ]// 将 initialObject 和 &#123; name: 'Rose', gender: 'Woman', hobby: 'Swimming' &#125; &#125; 对象进行合并const mergeObject = update(initialObject, &#123; $merge: &#123; name: 'Rose', gender: 'Woman', hobby: 'Swimming' &#125; &#125;);console.log('mergeObject', mergeObject); // =&gt; &#123; name: 'Rose', age: 22, gender: 'Woman', hobby: 'Swimming' &#125; {$apply: function}123456789101112/** * API: &#123;$apply: function&#125; * 为目标数组或者对象中某个下标或者属性应用 function */const apply = (val) =&gt; val + '--apply'// 为 initialArray 数组中下标为 1 的元素执行 apply 函数const applyArray = update(initialArray, &#123; 1: &#123; $apply: apply &#125; &#125;);console.log('applyArray：', applyArray); // =&gt; [ 'a', 'b--apply', 'c', 'd', 'e' ]// 为 initialObject 对象中 name 属性执行 apply 函数const applyObject = update(initialObject, &#123; name: &#123; $apply: apply &#125; &#125;);console.log('applyObject：', applyObject); // =&gt; &#123; name: 'Jack--apply', age: 22, gender: 'Man' &#125; {$add: array of objects}1234567891011/** * API: &#123;$add: array of objects&#125; * 向 Set 中添加元素时，array 是一个对象的数组，向 Map 中添加元素时， array 是一个 [key, value] 的数组 */// 将 ['Hello', 'World'] 中的元素添加到 initialSet 后，并返回一个新的 Setconst addSet = update(initialSet, &#123; $add: ['Hello', 'World'] &#125;);console.log('addSet：', addSet); // =&gt; Set &#123; '2', '0', '1', '9', '猪', '年', '快', '乐', 'Hello', 'World' &#125;// 将 [[3, 'Hello'], ['width', '20px']] 中的元素添加到 initialMap 中，并返回一个新的 Mapconst addMap = update(initialMap, &#123; $add: [[3, 'Hello'], ['width', '20px']] &#125;);console.log('addMap', addMap); // =&gt; Map &#123; 'id' =&gt; '1', 'color' =&gt; 'blue', 3 =&gt; 'Hello', 'width' =&gt; '20px' &#125; {$remove: array of strings}1234567891011/** * API: &#123;$remove: array of strings&#125; * 从 Set 或者 Map 中移除 array 中的键列表 */// 删除 initialSet 中的 '猪' 和 '年' 这两个元素const removeSet = update(initialSet, &#123; $remove: ['猪', '年'] &#125;);console.log('removeSet：', removeSet); // =&gt; removeSet： Set &#123; '2', '0', '1', '9', '快', '乐' &#125;// 删除 initialMap 中的 'color'和 'alias' 对应的两个键值对const removeMap = update(initialMap, &#123; $remove: ['color', 'alias'] &#125;);console.log('removeMap：', removeMap); // =&gt; Map &#123; 'id' =&gt; '1' &#125; 扩展用法 可多层结构内使用12345678910111213141516171819202122/** * 扩展用法：可多层结构内使用 */const initialConfig = &#123; width: 100, height: 100, options: [ &#123; color: 'red', shape: 'Square' &#125;, &#123; color: 'blue', shape: 'Circular' &#125; ]&#125;// 多层结构内使用const multiConfig1 = update(initialConfig, &#123; options: &#123; color: &#123; $set: 'pink' &#125; &#125; &#125;);console.log('multiConfig1：', multiConfig1);/* =&gt; &#123; width: 100, height: 100, options: [ &#123; color: 'red', shape: 'Square' &#125;, &#123; color: 'blue', shape: 'Circular' &#125;, color: 'pink' ] &#125;*/ 注意用法 多种操作不要一起使用，否则只会执行最后的一个操作123456789101112131415161718192021222324/** * 注意用法：多种操作不要一起使用，否则只会执行最后的一个操作 */const initialConfig = &#123; width: 100, height: 100, options: [ &#123; color: 'red', shape: 'Square' &#125;, &#123; color: 'blue', shape: 'Circular' &#125; ]&#125;// 例子：只会执行最后的设置 color 属性的操作const multiConfig2 = update(initialConfig, &#123; options: &#123; $push: [ &#123; color: 'deepPink', shape: 'Triangle' &#125; ] &#125;, options: &#123; color: &#123; $set: 'pink' &#125; &#125; &#125;);console.log('multiConfig2：', multiConfig2); /* =&gt; &#123; width: 100, height: 100, options: [ &#123; color: 'red', shape: 'Square' &#125;, &#123; color: 'blue', shape: 'Circular' &#125;, color: 'pink' ] &#125;*/","tags":[{"name":"React","slug":"React","permalink":"https://beichensky.github.io/tags/React/"},{"name":"Immutable","slug":"Immutable","permalink":"https://beichensky.github.io/tags/Immutable/"}]},{"title":"Github仓库中分支的创建和删除","date":"2019-01-02T10:37:33.000Z","path":"20190102/github-branch/","text":"本文介绍了 GitHub 仓库中分支的创建、删除以及默认分支的设置，希望对有需要的朋友提供些帮助。 创建和删除分支直接在仓库上创建分支 登录 Github，打开仓库，默认就在 Code 菜单下，不在的话，请点击上面的 Code 菜单栏，切换到 Code 菜单下。 可以看到有一个下拉选择框 Branch:master此时默认是master分支 点击当前选择框展开已有分支，可进行选择 在文本框中输入想要新建的分支名下方会出现 Create branch: 分支名 的选项，点击即可创建成果 在本地创建分支发布到 Github 上 先将代码从 Github 拉取到本地打开命令行，执行以下命令： 123$ git init $ git clone https://github.com/username/repo.git$ cd repo ps: username 请替换为你的用户名，repo 请替换为你的仓库名 本地新建分支并切换 1$ git checkout -b develop ps: develop 可替换为你的分支名 发布新分支到 Github 1$ git push origin develop 删除分支 注意： 删除分支之前：1、本地需要先切换到其他分支上；2、要删除的分支在远程仓库上不能是默认分支。 在 Github 上没有找到删除分支的操作，因此只能从本地进行远程分支的删除。 删除本地分支 1$ git branch -d develop 删除 Github 远程分支 1$ git push origin :develop ps: 分支前的冒号代表删除 修改默认分支在仓库中，选择菜单栏 Settings 菜单，之后选择右侧菜单中的 Branches，将 master 切换为我们刚才新建的分支，选择后右侧出现 Update 按钮，点击即可完成默认分支的修改。 选择默认分支 更新分支 确认更新 PS:会弹窗一个提示框，点击 I understand, update the default branch. 按钮即可。","tags":[{"name":"Git","slug":"Git","permalink":"https://beichensky.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://beichensky.github.io/tags/Github/"}]},{"title":"聊聊TypeScript中类、接口之间相互继承与实现的那些事儿","date":"2018-12-28T07:42:26.000Z","path":"20181228/ts-extends-impl/","text":"本文讲述了类的继承、接口的实现中需要注意的一些小细节，同时也对类、接口的多继承做了一些讲解。 先看一下继承类的继承 子类继承了父类之后，就会将父类中定义的非 private 属性以及方法都继承下来 123456789101112131415161718192021class Animal &#123; public name: string = \"Animal\"; public age: number; sayHello() &#123; console.log(`Hello $&#123; this.name &#125;`); &#125;&#125;class Dog extends Animal &#123; age: number; constructor(age) &#123; super(); this.age = age; &#125;&#125;const dog = new Dog(6);dog.sayHello(); 由于 Dog 继承了 Animal 类，所以同时也继承了 Animal 的 name 属性和 sayHello 方法，因此可以直接使用 dog 实例调用 sayHello 方法。 那么问题来了：如果可以进行多继承，若多个父类中都包含同一个属性，那么子类使用的应该是哪个父类的属性呢？ 因此 TypeScript 中不允许进行多继承，可是我就是想进行类的多继承该怎么办呢？可以使用用下节所说的 Mixins 的方式。 类的多继承（Mixins 模拟） 先定义两个类，Person 和 Student 类 12345678910111213141516// Person 类class Person &#123; name: string; sayHello() &#123; console.log('tag', `Helo $&#123; this.name &#125;!`) &#125;&#125;// Student 类class Student &#123; grade: number; study() &#123; console.log('tag', ' I need Study!') &#125;&#125; 下面创建一个类，结合 Person 和 Student 这两个类首先应该注意到的是，没使用 extends 而是使用 implements。 把类当成了接口，仅使用 Person 和 Student 的类型而非其实现。我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 123456789class SmartObject implements Person, Student &#123; // Person name: string = 'person'; sayHello: () =&gt; void; // Activatable grade: number = 3; study: () =&gt; void;&#125; 最后，把mixins混入定义的类，完成全部实现部分 123456789101112// 把mixins混入定义的类applyMixins(SmartObject, [Person, Student]);// applyMixins 方法function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;);&#125; 接口与类之间的继承 接口继承类的方式以及特点与上面类的继承和类的多继承一致。 接口与接口之间的多继承 接口与接口之间是可以直接进行多继承的。 先定义两个接口 12345678910// 阿里接口interface Ali &#123; pay: () =&gt; void&#125;// 腾讯接口interface Tencent &#123; game: string play: () =&gt; void&#125; 在定义一个接口继承 Ali、Tencent 接口 12345// 自己的接口interface Self extends Ali, Tencent &#123; name: string say: () =&gt; void&#125; 此时Self 接口就包含了 Ali 和 Tencent 接口中所有的属性和方法 验证一下用一个类继承 Self 接口，必须要将 Ali、 Tencent、 Self 接口中包含的所有属性和方法都声明了才可以，不然会编译报错 12345678910111213141516// 使用 Test 类实现 Self 接口class Test extends Self &#123; game: string; name: string; pay() &#123; cosole.log('经常用于支付'); &#125; play() =&gt; &#123; cosole.log('可以玩各种游戏'); &#125; say() &#123; cosole.log('不知道说点儿什么'); &#125;&#125; 再来看一下接口的实现接口的实现 接口在定义的时候，不能初始化属性以及方法，属性不能进行初始化，方法不能实现方法体。 类实现接口之后，必须声明接口中定义的属性以及方法。 1234567891011121314151617interface Animal &#123; name: string; eat: () =&gt; void;&#125;class Dog implements Animal &#123; name: string; eat() &#123; console.log('tag', 'I love eat bone!') &#125;&#125;const dog: Dog = new Dog();dog.eat(); 类对于接口的多实现 一个类可以实现多个接口，不过要将实现的所有接口的属性和方法都实现了。 123456789101112131415161718192021222324252627282930// 动物接口interface Animal &#123; name: string; eat: () =&gt; void;&#125;// 猫科接口interface Felidae &#123; claw: number; run: () =&gt; void;&#125;// 让猫类实现 Animal 和 Felidae 两个接口class Cat implements Animal, Felidae &#123; name: string; claw: number; eat() &#123; console.log('tag', 'I love eat Food!'); &#125; run: () &#123; console.log('tag', 'My speed is very fast!') &#125;&#125;const dog: Dog = new Dog();dog.eat(); 总结 类与类之间只能进行单继承，想要实现多继承需要使用 Mixins 的方式 接口继承类也只能进行单继承，想要实现多继承需要使用 Mixins 的方式Mixins 方式模拟多继承的缺陷： 只能在继承一级父类的方法和属性 如果父类中含有同一种方法或属性，会根据赋值的顺序，先赋值的会被覆盖掉 接口与接口之间可以直接进行多继承 类实现接口可以进行多实现，每个接口用 , 隔开即可","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://beichensky.github.io/tags/TypeScript/"}]},{"title":"JavaScript性能优化（八）","date":"2018-12-21T10:29:19.000Z","path":"20181221/js-hack8/","text":"本文是阅读《高性能JavaScript》一书后，从 编程实践 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 避免双重求值当你在 JavaScript 代码中执行另一段 JavaScript 代码时，都会导致双重求值的性能消耗。此代码首先会以正常的方式求值，然后在执行过程中对包含于字符串找哪个的代码发起另一个求值运算。双重求值是一项低价昂贵的操作，它比直接包含的代码执行速度慢许多。 尽量不使用 eval() 函数 和 Function() 构造函数 使用 setTimeout() 和 setInterval() 第一个参数尽量传入函数而不是字符串 使用原生代码和 eval() 分别读取 10 000 个数组项的速度对比： 浏览器类别 原生代码（毫秒） eval()（毫秒） Firefox 3 10.57 822.62 Firefox 3.5 0.72 141.54 Chrome 1 5.7 106.41 Chrome 2 5.17 54.55 Internet Explorer 7 31.25 5086.13 Internet Explorer 8 40.06 420.55 Opera 9.64 2.01 402.82 Opera 10 Beta 10.52 315.16 Safari 3.2 30.37 306.6 Safari 4 22.16 54.47 优化后的 JavaScript 引擎通常会魂村住那些使用了 eval() 且重复运行的代码。如果你在 Safari 4 和所有版本 Chrome 中对同一段代码字符串反复求值，你会看到显著的性能提升。 使用 Object/Array 直接量 对象属性和数组项的数量越多，使用直接量的好处就越明显。 避免重复工作先来看一段基本代码，之后对其进行优化123456789101112131415function addHandle(target, eventType, handler) &#123; if (target.addEvenetListener) &#123; // DOM2 Events target.addEvenetListener(eventType, handler, false); &#125; else &#123; // IE target.attachEvent(\"on\" + eventType, handler); &#125;&#125;function removeHandle(target, eventType, handler) &#123; if (target.removeEvenetListener) &#123; // DOM2 Events target.removeEvenetListener(eventType, handler, false); &#125; else &#123; // IE target.detachEvent(\"on\" + eventType, handler); &#125;&#125; 使用延迟加载进行优化 调用延迟加载函数时，第一次总会消耗较长的时间，因为它必须运行监测接着再调用另一个函数完成任务。然随后调动相同的函数会更快，因为不需要再执行检测逻辑。当一个函数在页面中不会立刻调用时，延迟加载是最好的选择 12345678910111213141516171819202122232425262728function addHandle(target, eventType, handler) &#123; if (target.addEvenetListener) &#123; // DOM2 Events addHandle = function(target, eventType, handler) &#123; target.addEvenetListener(eventType, handler, false); &#125;; &#125; else &#123; // IE addHandle = function(target, eventType, handler) &#123; target.attachEvent(\"on\" + eventType, handler); &#125;; &#125; // 调用新函数 addHandle(target, eventType, handler)&#125;function removeHandle(target, eventType, handler) &#123; if (target.removeEvenetListener) &#123; // DOM2 Events removeHandle = function(target, eventType, handler) &#123; target.removeEvenetListener(eventType, handler, false); &#125; &#125; else &#123; // IE removeHandle = function(target, eventType, handler) &#123; target.detachEvent(\"on\" + eventType, handler); &#125; &#125; // 调用新函数 removeHandle(target, eventType, handler)&#125; 使用条件预加载进行优化 条件预加载确保所有函数调用消耗的时间相同。其代价是需要在脚本加载时就检测，而不是加载后。预加载适用于一个函数马上就要被用到，并且在整个页面的生命周期中频繁出现的场合。1234567891011121314var addHandler = document.body.addEvenetListener ? function(target, eventType, handler) &#123; target.addEvenetListener(eventType, handler, false); &#125; : function(target, eventType, handler) &#123; target.attachEvent(\"on\" + eventType, handler); &#125;;var removeHandler = document.body.removeEvenetListener ? function(target, eventType, handler) &#123; target.removeEvenetListener(eventType, handler, false); &#125; : function(target, eventType, handler) &#123; target.detachEvent(\"on\" + eventType, handler); &#125;; 使用速度快的部分位操作符 使用位操作符比 JavaScript 其他数学运算和布尔操作相比要快很多。 按位与 &amp; 两个操作数的对应位数都是 1 时，则在该位返回 1 按位或 | 两个操作数的对应位数只要一个为 1 时，则在该位返回 1 按位异或 ^ 两个操作数的对应位数只有一个为 1，则在该位返回 1 按位取反 ~ 遇 0 则返回 1，反之亦然 范例 位运算 123456789101112131415161718192021222324252627// 普通写法for (var i = 0, len = rows.length; i &lt; len; i ++) &#123; if (i % 2) &#123; className = \"even\"; &#125; else &#123; className = \"odd\"; &#125; // 增加class ……&#125;// 使用位操作符进行优化for (var i = 0, len = rows.length; i &lt; len; i ++) &#123; if (i &amp; 1) &#123; className = \"odd\"; &#125; else &#123; className = \"even\"; &#125; // 增加class ……&#125;// 优化后的版本比普通版本快了 50% 位掩码 用于处理同时存在多个布尔值的情形。期数即使用单个数字的每一位来判断是否选项成立，从而有效的把数字转换成有不二指标及组成的数组。掩码中的每个选项的值都等于 2 的幂。 12345678910111213141516171819202122var OPTION_A = 1;var OPTION_B = 2;var OPTION_C = 4;var OPTION_D = 8;var OPTION_E = 16;// 通过这些选项，可以用按位或运算创建一个数字来包含多个设置选项var options = OPTIONS_A | OPTIONS_C | OPTIONS_D;// 如果该选项未设置则运算结果为 0， 如果已设置则运算结果为 1// 选项 A 是否在列表中？if (options &amp; OPTIONS_A) &#123; // 代码处理&#125;// 选项 B 是否在列表中？if (options &amp; OPTIONS_B) &#123; // 代码处理&#125;// 像这样的位掩码运算速度非常快，原因正如前面提到的，计算操作发生在系统底层。 JavaScript 也支持按位左移（&lt;&lt;）， 按位右移（&gt;&gt;），和无符号右移（&gt;&gt;&gt;）等位运算符 原生方法 无论你的 JavaScript 代码如何优化，都永远不会比 JavaScript 引擎提供的原生方法更快。 当你想进行数学运算时，请先查看 Math 对象 选择器 API，即使 JQuery 提供的方法也比原生方法要慢 当原生方法可用时，尽量使用它们。特别是数学运算和 DOM 操作。用编译后的代码做更多的事情，你的代码就会越快 小结 通过避免使用 eval() 和 Function() 构造器来避免双重求值带来的性能消耗。同样的，给 setTimeout 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组。直接量的创建和初始化都比非直接量形式要快 避免做重复的工作。当需要检测浏览器时，可使用延迟加载或条件预加载 在进行数学计算时，考虑使用直接操作数字的二进制形式的位运算 JavaScript 的原生方法总会比你写的任何代码都要快。尽量使用原生方法","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"Practice","slug":"Practice","permalink":"https://beichensky.github.io/tags/Practice/"}]},{"title":"JavaScript性能优化（七）","date":"2018-12-21T10:29:09.000Z","path":"20181221/js-hack7/","text":"本文是阅读《高性能JavaScript》一书后，从 Ajax 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 请求数据有五种常用技术： XMLHttpRequest(XHR) Dynamic script tag insertion 动态脚本注入 iframes Comet Multipart XHR XMLHttpRequest目前最常用的技术，他允许异步发送和接收数据。所有的主流浏览器对它都提供了完善的支持，而且它还能精准的控制发送请求和数据接收。 范例： 12345678910111213141516171819var url = '/data.php';var params = [ 'id=934875', 'limit=20'];var req = new XMLHttpRequest();req.onreadystatechange = function() &#123; if (req.readyState === 4) &#123; var responseHeaders = req.getAllResponseHeaders(); // 获取响应头信息 var data = req.responseText; // 获取数据 // 数据处理 &#125;&#125;req.open('GET', url + '?' + params.join('&amp;'), true);req.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); // 设置请求头信息req.send(null); 通过监听 readyState 值等于 3，可以与正在传输的服务器响应进行交互： 123456789req.onreadystatechange = function() &#123; if (req.readyState === 3) &#123; // 接收到部分信息，但不是所有 var dataSoFar = req.responseText; ... &#125; else if (req.readyState === 4) &#123; // 所有信息接收完毕 ... &#125;&#125; 动态脚本注入 这种技术克服了 XHR 的最大限制：它能跨域请求数据。范例： 1234567891011var scriptElement = document.createElement('script');scriptElement.src = 'http://any-domin.com/javascript/lib.js';document.getElementByTagName('head')[0].appendChild(scriptElement);function jsonCallback(jsonString) &#123; var data = eval('(' + jsonString + ')'); // 处理数据...&#125;// 本例中 libs 文件需要将数据封装在 jsonCallback 函数里：// jsonCallback(&#123; \"status\": 1, \"colors\": ['#fff', '#000', '#ff0000']&#125;); - 弊端： 1. 不能设置请求的头信息 2. 参数传递只能使用 GET 请求 3. 不能设置请求的超时处理或重试 4. 不能使用纯 XML、JSON、或其他任何格式的数据，无论哪种格式，都必须封装在一个回调函数中 Multipart XHR编写健壮的 MXHR 代码很复杂，但值得深入研究，访问以下网址可获取完整的类库：http://techfoolery.com/mxhr/。 优点：发送多个资源（图片，文件，HTML 片段）只用一次 HTTP 请求 适用场景： 页面包含了大量其他地方用不到的资源（因此也无须缓存），尤其是图片 网站已经在每个页面中使用一个独立打包的 JavaScript 或 CSS 文件以减少 HTTP请求 局限性： 这种方式获得的资源不能被缓存 老版的 IE 不支持 readyState 为 3 的状态和 data: URL。因此无法使用 发送数据XMLHttpRequest 当使用XHR 发送数据到服务器时， GET方式会更快。这是因为，对于少量数据而言，一个 GET 请求网服务器只发送一个数据包。而一个 POST 请求，至少要发送两个数据包，一个装载头信息，另一个装在 POST 正文。 POST 更适合发送大量数据到服务器，因为它不关心额外数据包的数量，另一个原因是 IE 对URL 长度有限制，它不可能使用过长的 GET 请求 Beacons(信标) 这项技术非常类似动态脚本注入。使用JavaScript 创建一个新的 Image 对象，并把 src 属性设置为服务器上脚本的 URL。该 URL 包含了我们要通过 GET 传回的键值对数据。 请注意，并没有创建 img 元素或把它插入 DOM 123456var url = '/status_tracker.php';var params = [ 'step=2', 'tmee=1248027314'];(new Image()).src = url + '?' + params.join('&amp;); 信标是向服务器会窜数据中最快切最有想的方式。服务器根本不需要发送人性和响应文本，因此你也无须担心客户端下载数据。唯一缺点是你接收到的响应类型是有限的。如果你需要返回大量数据，请使用XHR。 数据格式不同数据格式情况下，响应内容大小和解析事件 格式 大小 下载耗时 解析耗时 总耗时 标准的 XML 582 960 字节 999.4 毫秒 343.1 毫秒 1342.5 毫秒 简化的 XML 437 960 字节 475.1 毫秒 83.1 毫秒 558.2 毫秒 标准 JSON 487 895 字节 527.7 毫秒 26.7 毫秒 554.4 毫秒 简化的 JSON 392 895 字节 498.7 毫秒 29.0 毫秒 527.7 毫秒 数组 JSON 292 895 字节 305.4 毫秒 18.6 毫秒 324.0 毫秒 Verbose JSON-P 487 913 字节 598.2 毫秒 0.0 毫秒 598.2 毫秒 Simple JSON-P 392 913 字节 454.0 毫秒 3.1 毫秒 457.1 毫秒 Array JSON-P 292 912 字节 316.0 毫秒 3.4 毫秒 319.4 毫秒 HTML 1063 416 字节 273.1 毫秒 121.4 毫秒 394.5 毫秒 Custom Format (XHR) 222 892 字节 63.1 毫秒 14.5 毫秒 77.6 毫秒 Custom Format (script insertion) 222 912 字节 66.3 毫秒 11.7 毫秒 78.0 毫秒 JSON 是高性能 Ajax 的基础，尤其在使用动态脚本注入时。 数据格式总结通常来说数据格式越轻量级越好，JSON 和字符分隔的自定义格式是最好的。如果数据集很大并且对解析事件有要求，那么就从如下两种格式中作出选择： JSON-P 格式，使用动态脚本注入获取。它把数据当做可执行 JavaScript 而不是字符串，解析速度极快。它能跨域使用，但涉及敏感数据时不应该使用它 字符分隔的自定义格式，使用XHR 或动态脚本注入获取，用 split() 解析。这项技术解析大数据比 JSON-P略快，而且通常文件尺寸更小 Ajax 性能指南缓存数据 设置 HTTP 头信息 如果希望 Ajax 响应能够被浏览器缓存，那么你必须使用 GET 方式发出请求。但这还不够，你还必须在响应中发送正确的 HTTP 头信息。Expires 头信息会告诉浏览器应该缓存响应多久。 设置 Expires 头信息是确保浏览器缓存 Ajax 响应最简单的方法。 本地数据存储 直接将服务器接收到的数据存储到一个对象中，以 URL 为键值对作为索引。使用时直接从对象中获取。清除缓存时删除对应的 URL 属性即可 Ajax 类库的局限性 不能放到到 XMLHttpRequest 的完整功能 直接操作 XHR 对象减少了函数开销，进一步提升了性能。需要的是，如果放弃使用 Ajax 类库，那么你可能在一些古怪的浏览器上遇到一些问题。 小结作为数据格式，纯文本和 HTML 是高度限制的，但它们可节省客户端的 CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速（作为本地代码而不是字符串），交互性与 XML 相当。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。 当从页面域请求数据时，XHR 提供最完善的控制和灵活性，尽管它将所有传入数据视为一个字符串，这有可能降低解析速度。另一方面，动态脚本标签插入技术允许跨域请求和本地运行 JavaScript 和 JSON，虽然它的接口不够安全，而且不能读取信息头或响应报文代码。多部分 XHR 可减少请求的数量，可在一次响应中处理不同的文件类型，尽管它不能缓存收到的响应报文。当发送数据时，图像灯标是最简单和最有效的方法。XHR 也可用 POST 方法发送大量数据。 除这些格式和传输技术之外，还有一些准则有助于进一步提高 Ajax 的速度： 减少请求数量，可通过 JavaScript 和 CSS 文件打包，或者使用 MXHR 缩短页面的加载时间，在页面其它内容加载之后，使用 Ajax 获取少量重要文件 确保代码错误不要直接显示给用户，并在服务器端处理错误 知道何时使用成熟的 Ajax 类库，以及何时编写自己的底层 Ajax 代码","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"Ajax","slug":"Ajax","permalink":"https://beichensky.github.io/tags/Ajax/"}]},{"title":"JavaScript性能优化（六）","date":"2018-12-20T15:33:16.000Z","path":"20181220/js-hack6/","text":"本文是阅读《高性能JavaScript》一书后，从 快速响应的用户界面 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 浏览器 UI 线程用于执行 JavaScript 和更新用户界面的进程通常被称为“浏览器 UI 线程”。UI 线程的工作基于一个简单的队列系统，任务会被保存到队列中知道进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行 JavaScript 代码，要么是执行 UI 更新，包括重绘和重排。一次输入（包括：响应用户时间，自执行的 JavaScript 代码等）可能会导致一个或多个任务被加入队列。 当所有 UI 线程任务都执行完毕，进程进入空闲状态，并等待更多任务加入队列。空闲状态是理想的，因为用户所有的交互都会立刻出发 UI 更新。如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，甚至可能新的 UI 更新任务都不会被创建并加入到队列。事实上，大多数浏览器在 JavaScript 运行时会停止把新任务加入 UI 线程的队列中，也就是说 JavaScript 任务必须尽快结束，以避免对用户体验造成不良影响。 浏览器限制浏览器限制了 JavaScript 任务的运行时间。这种限制是有必要的，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器或计算机。此类限制分两种：调用栈大小限制和长时间运行脚本限制 有两种方法可以度量脚本运行了多“长”： 记录脚本开始以来执行的语句的数量 记录脚本执行的总时长 不同浏览器检测长时间运行脚本的方法会略有不同： IE 自第 4 版开始，设置默认限制为 500 万条语句；此限制存放在 Windows 注册表中，叫做 HKEY_CURRENT_USER\\Software\\Microsoft\\InternetExplorer\\Styles\\MaxScriptStatements Firefox 的默认限制时间为 10 秒；该限制记录在浏览器配置设置中（通过地址栏输入 about: config 访问），键名为 dom.max_script_run_time Safari 的默认限制为 5 秒；该限制无法更改，但是你可以通过 Develop 菜单选择 DisableRunaway JavaScript Timer 来禁用定时器。 Chrome 没有单独的长运行脚本限制，替代做法是依赖其通用崩溃检测系统来处理此类问题 Opera 没有长于宁脚本限制，它会继续执行 JavaScript 代码知道结束，鉴于 Opera 的架构，脚本运行结束时不会导致系统不稳定 多久才算“太久”浏览器允许脚本持续运行好几秒，但并不意味着你也允许它这样做。 单个 JavaScript 操作花费的总时间（最大值）不应该超过 100 毫秒。这个数字源自 Robert Miller 于 1968 年的研究。 IE 会控制用户交互行为触发的 JavaScript 任务，因此它会识别连续两次的重复的动作。例如，当有脚本运行时点击一个按钮四次，最终按钮的 onclick 事件处理器只被调用两次。 使用定时器让出时间片段尽管你进了最大努力，但难免有一些复杂的 JavaScript 任务不能再 100 毫秒内完成。这个时候，最理想的方法是让出 UI 线程的控制权，使得 UI 可以更新，然后再继续执行 JavaScript。于是引入了 JavaScript 定时器。 定时器基础在 JavaScript 中可以使用 setTimeout() 和 setInterval() 创建定时器，他们接收相同的参数：要执行的函数和执行前的等待时间。setTimeout() 创建一个只执行一次的定时器，而 setInterval() 创建了一个周期性重复运行的定时器。这个执行前等待时间是从 setTimeout() 或 setInterval() 调用时开始计算，而不是在整个函数运行结束后才开始计算。 setTimeout() 和 setInterval() 几近相同，除了前者会重复添加 JavaScript 任务到队列。它们最主要的区别是，如果 UI 队列中已经存在由同一个 setInterval() 创建的任务，那么后续任务不会被添加到 UI 队列中。 每个定时器的真实延时时间在很大程度上屈居于具体情况。普通来讲，最好使用至少 25 毫秒，因为更小的延时，对大多数 UI 更新来说不够用。 定时器的精度JavaScript 定时器延迟通常不太精准，相差大约几毫秒。因此，定时器不可用于测量实际时间。 定时器延时的最小值有助于避免在其他浏览器和其他操作系统中的定时器出现分辨率问题。大多数浏览器在定时器延时等于或小于 10 毫秒时表现不太一致。 使用定时器处理数组 使用定时器取代循环的两个决定性因素： 处理过程是否必须同步？否 数据是否必须按顺序处理？否 实例代码： 123456789101112131415161718192021// 普通循环for (var i = 0, len = items.length; i &lt; len; i++) &#123; process(items[i]);&#125;// 使用定时器处理var todo = items.concat(); // 克隆原数组setTimeout(function() &#123; // 取得数组的下个元素并进行处理 process(todo.shift()); // 如果还有需要处理的元素，创建另一个定时器 if (todo.length &gt; 0) &#123; setTimeout(arguments.callee, 25); &#125; else &#123; callback(items); &#125;&#125;, 25); 这种优化模式的基本私立：创建一个原始数组的克隆，并将它作为数组向队列来处理。第一次调用 setTimeout() 创建一个定时器处理数组中的第一个条目。调用 todo.shift() 返回它的第一个条目然后把它从数组中删除。这个值作为参数传给 process()。处理完后，检查是否还有更多条目需要处理。如果 todo 数组中还有条目，那么就再启动一个定时器。因为下一个定时器需要运行相同的代码，所以第一个参数为 arguments.callee。该值指向当前正在运行的匿名函数。如果不再有条目需要处理，那么调用 callback() 函数。 功能封装 1234567891011121314151617181920212223242526272829// 封装后的函数function processArray(items, process, callback) &#123; var todo = items.concat(); // 克隆原数组 setTimeout(function() &#123; // 取得数组的下个元素并进行处理 process(todo.shift()); // 如果还有需要处理的元素，创建另一个定时器 if (todo.length &gt; 0) &#123; setTimeout(arguments.callee, 25); &#125; else &#123; callback(items); &#125; &#125;, 25);&#125;// 使用var items = [123, 789, 323, 778, 232, 654, 219, 543, 321, 160];function outputValue(value) &#123; console.log(value);&#125;processArray(items, outputValue, function() &#123; console.log('Done!');&#125;) 使用定时器处理数组的副作用是处理数组的总时长增加了。因为在每一个条目处理完后 UI 线程会空闲出来，并且在下一条目开始处理之前会有一段延时。尽管如此，为避免锁定浏览器给用户带来的糟糕体验，这种取舍是有必要的。 分割任务我们通常会把一个任务分解成一些列子任务。如果一个函数运行时间太长，那么检查一下是否可以把它拆分成一系列能在较短时间内完成的子函数。 例如： 12345678function saveDocument(id) &#123; openDocument(id); writeText(id); closeDocument(id); // 将成功信息更新至界面 updateUI(id);&#125; 如果这个函数运行时间太长，可以把每个独立的方法放在定时器中调用。使用上一节提到的数组处理模式： 12345678910111213141516function saveDocument(id) &#123; var tasks = [openDocument, writeText, closeDocument, updateUI]; setTimeout(function () &#123; // 执行下一个任务 var task = tasks.shift(); task(id); // 检查是否还有其他任务 if (tasks.length &gt; 0) &#123; setTimeout(arguments.callee, 25); &#125; &#125;, 25)&#125; 封装以备用： 12345678910111213141516171819202122232425// 功能函数function multistep(steps, args, callback) &#123; var tasks = steps.concat(); setTimeout(function() &#123; // 执行下一个任务 var task = tasks.shuift(); task.apply(null, args || []); // 检查是否还有其他任务 if (tasks.length &gt; 0) &#123; setTimeout(arguments.callee, 25); &#125; &#125;, 25)&#125;// 调用时function saveDoucment(id) &#123; var tasks = [openDocument, writeText, closeDocument, updateUI]; multistep(tasks, [id], function() &#123; alert(\"save completed!\"); &#125;)&#125; 正如数组处理那样，使用此函数的前提条件是：任务可以异步处理而不影响用户体验或造成相关代码错误。 记录代码运行时间 使用原生的 Date 对象来跟踪代码的运行时间123456789101112var start = + new Date();var stop;someLongProcsee();stop = + new Date();if(stop - start &lt; 50) &#123; alert('Juest about right.');&#125; else &#123; alert('Taking too long.);&#125; 定时器与性能 当多个重复的定时器同时创建旺旺会出现性能问题。因为只有一个 UI 线程，而所有的定时器都在争夺运行时间 优化建议： 在 Web 应用重限制高频率重复定时器的数量 创建一个独立的重复定时器，每次执行多个操作 Web Workers每个新的 Worker 都在自己的线程中运行代码。意味着 Worker 运行代码不仅不会影响浏览器 UI，也不会影响其他 Worker 中运行的代码 Worker 运行环境 一个 navigator 对象，只包括四个属性：appName、appVersion、user Agent 和 platform 一个 location 对象（与 window。location 相同，不过所有的属性都是只读的） 一个 Self 对象，指向全局 Worker 对象 一个 importScripts() 方法，用来加载 Worker 所用到的外部 JavaScript 文件 所有的 ECMAScript 对象，诸如：Object、Array、Date 等 XMLHttpRequest 构造器 setTimeout() 和 setInterval() 方法 一个 close() 方法，它能立刻停止 Worker 运行 与 Worker 通信 消息系统是网页和 Worker 通信的唯一途径 网页代码可以通过 postMessage() 方法给 Worker 传递数据，它接受一个参数，即需要传递给 Worker 的数据 Worker 还有一个用来接收信息的 onmessage 事件处理器 例子： 123456789101112131415// 创建 Workervar worker = new Worker('code.js');worker.onmessage = function(event) &#123; // 此处的 event.data 是 code.js 中组合之后的字符串 alert(event.data);&#125;worker.postMessage('any message');// code.js 内部self.onmessage = function(event) &#123; // 此处的 event.data 是上面传过来的 'any message' sele.postMessage('Hello, ' + event.data + '!');&#125; 加载外部文件Worker 通过 importScripts() 方法家在外部 JavaScript 文件，该方法接受一个或多个 JavaScript 文件URL 作为参数。 importScripts() 调用过程是阻塞式的，知道所有文件加载并执行完成之后，脚本才会继续执行。由于 Worker 在 UI 线程之外运行，所以这种阻塞并不会影响 UI 相应 123456// code.js 内部代码importScripts('file1.js', 'file2.js');self.onmessage = function(event) &#123; self.postMessage('Hello, ' + event.data + '!');&#125; 实际应用 适用于处理纯数据或者与浏览器 UI 无关的长时间运行脚本 解析一个大字符串 编码/解码大字符串 复杂数学运算（包括图像或视频处理） 大数组排序 任何超过 100 毫秒的处理过程 解析一个很大的 JSON 字符串的例子：1234567891011121314151617181920212223242526272829303132/** * 创建 Worker 的代码 */var worker = new Worker('jsonparser.js');// 数据就位时，调用事件处理器worker.onmessage = function(event) &#123; // JSON 结构被回传回来 var jsonData = event.data; // 使用 JSON 结构 evaluateData(jsonData);&#125;;worker.postMessage(jsonText);/** * jsonparser.js 内部代码 */self.onmessage = function(event) &#123; // JSON 字符串由 event.data 传入 var jsonText = event.data; // 解析 var jsonData = JSON.parse(jsonText); // 回传结果 self.postMessage(jsonData);&#125; 小结 任何 JavaScript 任务都不应当执行超过 100 毫秒。过长的运行时间会导致 UI 更新出现明显的延迟，从而对用户体验产生负面影响 JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验变得混乱和脱节 定时器可用来安排代码延迟执行，它使得你可以长时间运行脚本分解成一系列的小任务 Web Workers 是新版浏览器支持的特性，它允许你在 UI 线程外部执行 JavaScript 代码，从而避免锁定 UI Web 应用越复杂，积极主动地管理 UI 线程就越重要。即使 JavaScript 代码再重要，也不应该影响用户体验。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"}]},{"title":"JavaScript性能优化（五）","date":"2018-12-20T07:20:16.000Z","path":"20181220/js-hack5/","text":"本文是阅读《高性能JavaScript》一书后，从 字符串和正则表达式 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 字符串连接使用循环 向字符串末尾不断地添加内容。这种方式在某些浏览器中性能很糟糕 使用 + 或者 += 操作符 常用方法：str += &quot;one&quot; + &quot;two&quot;此代码运行会经历四个步骤 在内存中穿件一个临时字符串 连接后的字符串 “onetwo” 被赋值给临时字符串 临时字符串与 str 当前的值连接 结果赋值给 str 优化版本 12str += \"one\";str += \"two\"; 更简化的写法：str = str + &quot;one&quot; + &quot;two&quot; 下面这两种优化写法避免了产生临时字符串。但是如果改变连接顺序（例如：str = “one” + str + “two”），本优化将失效。这与浏览器合并字符串时分配内存的方法有关。除 IE 外，其他浏览器会尝试为表达式左侧的字符串分配更多的内存，然后简单地将第二个字符串拷贝至它的欧威。如果在一个循环中，基础字符串位于最左端的位置，就可以避免重复拷贝一个逐渐变大的基础字符串。 Firefox 和编译器合并 在复制变大是中所有要连接的字符串都属于编译期常量，Firefox 会在编译过程中自动合并它们。下面的方式可以看到这一过程： 1234567891011121314function foldingDemo() &#123; var str = \"complie\" + \"time\" + \"folding\"; str += \"this\" + \"works\" + \"too\"; str = str + \"but\" + \"not\" + \"this\";&#125;alert(foldingDemo.toString);// alert 出的结果function foldingDemo() &#123; var str = \"complietimefolding\"; str += \"thisworkstoo\"; str = str + \"but\" + \"not\" + \"this\";&#125; 当字符串通过这种方式合并在一起时，由于运行期没有中间字符串，所以花在连接过程的时间和内存可以减少到零。这种做法非常不错，但它不是经常起作用，因为更多的时候是用运行期的数据构建字符串，而不是用编译期常量。 数据项合并（Array.prototype.join） 在大多数浏览器中，数据项合并比其他字符串连接方法更慢，但事实上，它却是IE7及更早版本浏览器中合并大量字符串 唯一高效的途径。因为 IE7 的连接算法要求浏览器在循环过程中为逐渐增大的字符串不断复制并分配内存。结果是运行时间和内存消耗以平方关系递增。 实例： 12345678910111213141516171819var str = \"I'm a thirty-five character string.\", newStr = \"\", appends = 5000;while (appends --) &#123; newStr += str;&#125;// 在 IE 中优化var str = \"I'm a thirty-five character string.\", strs = [], newStr, appends = 5000;while (appends --) &#123; strs[strs.length] = str;&#125;newStr = strs.join(\"\"); 性能提升原因：当把所有的数组元素连接在一起时，浏览器会分配足够的内存来存放整个字符串，而且不会多次拷贝最终字符串中相同的部分。 String.prototype.concat 这是最灵活的字符串合并方法，因为你可以用它只附加一个字符串，或者同事附加多个字符串，以至整个字符串数组。 遗憾的是，在多数情况下，使用 concat 比使用简单的 + 和 += 稍慢，尤其是在 IE、Opear、Chrome 中慢的更明显。此外，尽管使用 concat 合并字符串数组与前面讨论的数组项连接类似，但它通常更慢一些（Opera 除外），并且它也潜伏着灾难性的性能问题，就像在 IE7 及早期版本中使用 + 和 += 构建大字符串时那样。 正则表达式优化正则表达式处理的基本步骤 编译 设置起始位置 匹配每个正则表达式字元 匹配成功或失败 回溯回溯先关篇幅过长，文字描述过多，想要更多了解请参阅《高性能 JavaScript》第五章：“字符串和正则表达式”。第 89 页 提高正则表达式效率的方法 关注如何让匹配更快失败正则表达式处理慢往往是因为匹配失败过程慢，而不是匹配成功过程慢。如果你使用正则表达式匹配一个很大字符串的一小部分，情况更为严重，正则表达式匹配失败的位置比匹配成功的位置要多得多。如果 一个修改使正则表达式匹配更快但失败更慢（例如，通过增加所需的回溯次数去尝试所有分支的排列组合），这通常是一个失败的修改。 正则表达式以简单、必需的字元开始最理想的情况是，一个正则表达式的起始字元应当尽可能快速地测试并排除明显不匹配的位置。用于此目的好的起始字元通常是一个锚（^或$），特定字符（例如 x 或\\u363A），字符类（例如，[a-z]或速记符例如\\d），和单词边界（\\b）。如果可能的话，避免以分组或选择字元开头，避免顶级分支例如/one|two/，因为它强迫正则表达式识别多种起始字元。Firefox 对起始字元中使用的任何量词都很敏感，能够优化的更好，例如，以\\s\\s*替代\\s+或\\s{1,}。其他浏览器大多优化掉这些差异。 使用量词模式，使它们后年的字元互斥当字符与字元毗邻或子表达式能够重叠匹配时，一个正则表达式尝试分解文本的路径数量将增加。为避免此现象，尽量具体化你的模板。当你想表达“[^&quot;\\r\\n]*”时不要使用“.*?”（依赖回溯） 减少分支数量，缩小分支范围分支使用 | ，竖线，可能要求在字符串的每一个位置上测试所有的分支选项。你通常可通过使用字符类和选项组件减少对分支的需求，或将分支在正则表达式上的位置推后（允许到达分支之前的一些匹配尝试失败）。 使用非捕获组捕获组花费时间和内存用于记录后向引用，并保持它们是最新的。如果你不需要一个后向引用，可通过使用非捕获组避免这种开销——例如，(?:…)替代（…）。有些人当他们需要一个完全匹配的后向引用时，喜欢将他们的正则表达式包装在一个捕获组中。这是不必要的，因为你能够通过其他方法引用完全匹配，例如，使用 regex.exec()返回数组的第一个元素，或替换字符串中的$&amp;。 只捕获感兴趣的文本以减少后处理作为上一条的补充说明，如果你需要引用匹配的一部分，应当通过一切手段，捕获那些片断，再使用后向引用处理。例如，如果你写代码处理一个正则表达式所匹配的引号中的字符串内容，使用/&quot;([^&quot;]*)&quot;/然后使用一次后向引用，而不是使用/&quot;[^&quot;]*&quot;/然后从结果中手工剥离引号。当在循环中使用时，减少这方面的工作可以节省大量时间。 暴露必须的字元为帮助正则表达式引擎在如何优化查询例程时做出明智的决策，应尽量简单地判断出那些必需的字元。当字元应用在子表达式或者分支中，正则表达式引擎很难判断他们是不是必需的，有些引擎并不作此方面努力。例如，正则表达式/^(ab|cd)/暴露它的字符串起始锚。IE 和 Chrome 会注意到这一点，并阻止正则表达式尝试查找字符串头端之后的匹配，从而使查找瞬间完成而不管字符串长度。但是，由于等价正则表达式/(^ab|^cd)/不暴露它的^锚，IE 无法应用同样的优化，最终无意义地搜索字符串并在每一个位置上匹配。 使用适当的量词在确保正确等价的前提下，使用更合适的量词类型（基于预期的回溯次数）可以显著提高性能，尤其在处理长字符串时。 把正则表达式赋值给变量并重用它们将正则表达式赋给变量以避免对它们重新编译。有人做的太过火，使用正则表达式缓存池，以避免对给定的模板和标记组合进行多次编译。不要过分忧虑，正则表达式编译很快，这样的缓存池所增加的负担可能超过他们所避免的。重要的是避免在循环体中重复编译正则表达式。 将复杂的正则表达式拆分成简单的片段（化繁为简）尽量避免一个正则表达式做太多的工作。复杂的搜索问题需要条件逻辑，拆分为两个或多个正则表达式更容易解决，通常也更高效，每个正则表达式只在最后的匹配结果中执行查找。在一个模板中完成所有工作的正则表达式怪兽很难维护，而且容易引起回溯相关的问题。 何时不使用正则表达式 当只是搜索字面字符串时，可以使用 string 的 charAt()、slice()、 substr、substring() 等方法替代正则表达式 去除字符串首尾空白使用正则表达式去首尾空白 第一种 1234567891011if (!Strig.prototype.trim) &#123; // trim 1 Strig.prototype.trim = function() &#123; return this.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\"); &#125;&#125;// 测试新方法// 头部空白中包含了制表(\\t)和换行符(\\n)var str = \"\\t\\n test string \".trim();alert(str == \"test string\"); // 弹出信息为 true 第二种：使用分支功能合并了两个简单正则表达式 1234// trim 2Strig.prototype.trim = function() &#123; return this.replace(/^\\s+|\\s+$/g, \"\");&#125; 在处理较长字符串时要比第一种使用两个简单的子表达式要慢。 第三种 1234// trim 3Strig.prototype.trim = function() &#123; return this.replace(/^\\s*([\\s\\S]*?)\\s*$/, \"$1\");&#125; 这个正则表达式的作用是匹配整个字符串，捕获从第一个到最后一个非空白字符串。在处理较长字符串时就变得很慢。 第四种 1234// trim 4Strig.prototype.trim = function() &#123; return this.replace(/^\\s*([\\s\\S]*\\S)?\\s*$/, \"$1\")&#125; 这个与第三种类似，但是考虑到性能原因，它把惰性量词替换成了一个贪婪量词。速度很快，甚至超过第一种使用两个子表达式的方案。（除非字符串里的尾部空白比其他文字还多）。但是这个方案在 Firefox 和 Opera 9 中相当慢。因此，第一种方案目前仍是最好的跨浏览器方案。 第五种 1234// trim 5String.prototype.trim = function() &#123; return this.replace(/^\\s*(\\S*(\\s+\\S+)\\s*$/), \"$1\"); &#125; 无论在何种情况下，这种方案都是上述所有方法中最慢的。 使用正则表达式去除空白时的缺陷：当字符串的末尾有一小段空白时，正则表达式会陷入疯狂工作状态，这是因为正则表达式很好的去除了字符串头部的空白，但它们却不能同样快速地去除长字符串尾部的空白。 不使用正则表达式去除字符串首尾空白12345678910111213141516// trim 6String.prototype.trim = function() &#123; var start = 0, end = this.length - 1, ws = \" \\n\\r\\t\\f\\x0b\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\"; while (ws.indexOf(this.charAt(start)) &gt; -1) &#123; start++; &#125; while (end &gt; start &amp;&amp; ws.indexOf(this.charAt(end)) &gt; -1) &#123; end--; &#125; return this.slice(start, end + 1);&#125; 不使用正则表达式去除字符串首尾空白时的缺陷：不宜用来处理前后打断的空白字符。因为通过循环遍历字符串来确定白字符的效率比不上正则表达式使用的优化后的搜索代码。 混合解决方案使用正则表达式方法过滤头部空白，用非正则表达式的方法过滤尾部字符。123456789101112// trim 7String.prototype.trim = function() &#123; var str = this.replace(/^\\s+/, \"\"), end = str.length - 1, ws = /\\s/; while (ws.test(str.charAt(end))) &#123; end --; &#125; return str.slice(0, end + 1);&#125; 这种混合方法在过来吧一小段空白时速度非常快，在处理头部有很多空白或者仅由空白组成的字符串时，也没有性能风险（尽管在处理尾部长空白时仍然存在不足）。 不同 trim 实现版本在各种浏览器上的性能 浏览器类别 Trim1 Trim2 Trim3 Trim4 Trim5 Trim6 Trim6 IE 7 80/80 315/312 547/539 36/42 218/224 14/1015 18/409 IE 8 70/70 252/256 512/425 26/30 216/222 4/334 12/205 Firefox 3 136/147 164/174 650/600 1098/1525 1416/1488 21/151 20/144 Firefox 3.5 130/147 157/172 500/510 1004/1437 1344/1394 21/332 18/50 Safari 3.2.3 253/253 424/425 351/359 27/29 541/554 2/140 5/80 Safari 4 37/37 33/31 69/68 32/33 510/514 &lt;0.5/29 4/18 Opera 9.64 494/517 731/748 9066/9601 901/955 1953/2016 &lt;0.5/210 20/241 Opera 10 75/75 94/100 360/370 46/46 514/514 2/186 12/198 Chrome 2 78/78 66/68 100/101 59/59 140/142 1/37 24/55 报告时间以毫秒为单位，是修剪一个大字符串（40KB）100次所用的时间，每个字符串以 10 个空格开头，以 1000 个空格结尾 trim 1 方案测试时关闭 /\\s\\s*$\\优化 trim 5 方案测试时关闭非捕获组优化 小结密集的字符串操作和草率地编写正则表达式可能产生严重的性能障碍，下面的的优化方案可以帮助你避免这些常见的陷阱： 当连接数量巨大或尺寸巨大的字符串时，数组项合并是唯一在 IE7 及更早版本中性能合理的方法 如果不考虑 IE7 及更早版本的性能，数组向合并是最慢的字符串链接方法之一。推荐使用简单的 + 或者 += 操作符替代，避免不必要的中间字符串 回溯既是正则表达式匹配功能的基本组成部分，也是正则表达式的低效之源 回溯失控发生在正则表达式本应快速匹配的地方，但因为某些特殊的字符串匹配动作导致运行缓慢甚至浏览器崩溃。避免这个问题的方法是：使相邻的字元互斥，避免嵌套两次对同一字符串的相同部分多次匹配，通过重复利用预查的原子组去除不必要的回溯 提高正则表达式效率的各种手段会有助于正则表达式更快的匹配，并在非匹配位置上花更少的时间 正则表达式并不总是完成工作的最佳工具，尤其当你只搜索字面字符串的时候 尽管有许多方法可以去除字符串的首尾空白，但使用两个简单的正则表达式（一个用来去除头部空白，一个用来去除尾部空白）来去除大量字符串内容能提供一个简洁而跨浏览器的方法。从字符串末尾开始循环向前搜索第一个非空白字符，或者将此技术同正则表达式结合起来，会提供一个更好的替代方案，它很少受到字符串长度的影响","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"String","slug":"String","permalink":"https://beichensky.github.io/tags/String/"},{"name":"Regex","slug":"Regex","permalink":"https://beichensky.github.io/tags/Regex/"}]},{"title":"JavaScript性能优化（四）","date":"2018-12-19T03:19:59.000Z","path":"20181219/js-hack4/","text":"本文是阅读《高性能JavaScript》一书后，从 算法与流程控制 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 循环循环类型 普通 for 循环 在for循环中初始化的var语句会创建一个函数级的变量，而不是循环级。由于JavaScript只有函数级作用域，因此在for循环中使用var定义一个新变量相当于在循环体外定义一个新变量 while 循环，while 循环是最简单的前测循环 do-while 循环，是 JavaScript 中唯一一种后测循环 for-in 循环：可以枚举任何对象的属性名 for-in 循环是四种循环中最慢的，另外三种循环性能相仿 不要用 for-in 来遍历数组成员 尽量避免使用 for-in 循环，除非你明确需要一个属性数量未知的对象 循环性能 当循环复杂度为 O(n) 时，减少每次迭代的工作量是最有效的方法。当复杂度大于 O(n)，建议着重减少迭代次数 减少迭代的工作量 减少对象成员及数组项的查找次数 123456789101112// 原始版本for (var i = 0; i &lt; items.length; i ++) &#123; process(items[i]);&#125;// 最小化属性查找（优化版本）for (var i = 0, len = items.length; i &lt; len; i ++) &#123; process(items[i]);&#125;// 优化后的版本大概能节省25%的运行时间（IE中甚至可以节省50%）// 另外三种循环也是一样的优化方式 使用倒序循环来提高循环性能 1234// 数组项的顺序与索要执行的染污无关时，可以按照下面方式改写。可以略微提升性能for (var i = items.length; i --; ) &#123; process(items[i]);&#125; 减少迭代次数 达夫设备（Duff’s Device） 是否应该使用“达夫设备”，无论是原始版本还是优化版本，很大程度上取决于迭代次数。若循环次数小于1000，性能提升微不足道。如果迭代次数超过1000，那么“达夫设备”的执行效率明显提升。 初始版本 123456789101112131415161718// credit: Jeff Greenbergvar iterations = Math.floor(items.length / 8), startAt = items.length % 8, i = 0;do &#123; switch(startAt) &#123; case 0: process([items[i++]]); case 7: process([items[i++]]) case 6: process([items[i++]]) case 5: process([items[i++]]) case 4: process([items[i++]]) case 3: process([items[i++]]) case 2: process([items[i++]]) case 1: process([items[i++]]) &#125; startAt = 0;&#125; while (--iterations); 优化版本 此算法将余数处理和主循环分开。尽管这种方式使用两次循环代替之前的一次循环，但它移除了循环体中的 switch 语句，速度比原始循环更快 123456789101112131415161718// credit: Jeff Greenbergvar i = items.length % 8;while(i) &#123; process([items[i--]]);&#125;i = Math.floor(items.length / 8);while(i) &#123; process([items[i--]]); process([items[i--]]); process([items[i--]]); process([items[i--]]); process([items[i--]]); process([items[i--]]); process([items[i--]]); process([items[i--]]);&#125; 其他方案 基于函数的迭代 尽管基于函数的迭代提供了一个更为便利的迭代方法，但它仍然 比基于循环的迭代要慢一些 Ecma-262 标准第四版一如了一个新的原生数组方法：forEach()：items.forEach(function(value, index, array) {}) YUI 3 的each()：Y.Array.each(items, function(value, index, array) {}) Jquery 的 each()：jQuery.each(items, function(index, value) {}) Dojo 的 forEach()：dojo.each(items, function(value, index, array) {}) ProtoType 的 each()：items.each(function(value, index) {}) MooTools 的 each()：$each(items, function(value, index) {}) 条件语句if-else 对比 switch 大多数的语言对 switch 语句的实现都采用了 branch table（分支表）索引来进行优化。另外，在 JavaScript 中，switch 语句比较值时使用权等操作符，不会发生类型转换的消耗。 大多数情况下，switch 比 if-else 运行得要快 循环条件较少时，if-else 更易读，条件数量较多时，switch 更易读 if-else 适用于判断两个离散值或者几个不同的值域。当判断多与两个离散值时，switch 语句是更佳选择 优化 if-else优化 if-else 的目标是：最小化到达正确分之前所需判断的条件数量 最简单的优化方法是确保可能出现的条件放在首位 把 if-else 组织成一系列嵌套的 if-else 语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 实例代码：// 普通版本if (value == 0) &#123; return result0;&#125; else if (value == 1) &#123; return result1;&#125; else if (value == 2) &#123; return result2;&#125; else if (value == 3) &#123; return result3;&#125; else if (value == 4) &#123; return result4;&#125; else if (value == 5) &#123; return result5;&#125; else if (value == 6) &#123; return result6;&#125; else if (value == 7) &#123; return result7;&#125; else if (value == 8) &#123; return result8;&#125; else if (value == 9) &#123; return result9;&#125;// 优化版本if (value &lt; 6) &#123; if (value &lt; 3) &#123; if (value == 0) &#123; return result0; &#125; else if (value == 1) &#123; return result1; &#125; else &#123; return result2; &#125; &#125; else &#123; if (value == 3) &#123; return result3; &#125; else if (value == 4) &#123; return result4; &#125; else &#123; return result5; &#125; &#125;&#125; else &#123; if (value &lt; 8) &#123; if (value == 6) &#123; return result6; &#125; else &#123; return result7; &#125; &#125; else &#123; if (value == 8) &#123; return result8; &#125; else &#123; return result9; &#125; &#125;&#125; 重写后的 if-else 语句每次到达正确分支最多经过4次条件判断。它使用二分法把值域分成一系列的区间，然后逐步缩小范围。耗时仅是普通版本的一半。这个方法非常适用于有多个值域需要测试的时候（如果是离散值，那么switch语句通常更为合适）。 查找表有些时候优化条件语句的最佳方案是避免使用 if-else 和 switch。当有大量离散值需要测试时，if-else 和 switch 比使用查找表慢很多。JavaScript 中可以使用数组和普通对象来构建查找表。通过查找表访问数据比用 if-else 或 switch 快很多，特别是在条件语句数量很大的时候。 使用查找表相对于 if-else 和 switch，不仅速度更快，而且有时代码的可读性更好，特别是当需要测试的离散值数量非常大的时候。 1234567891011121314151617181920212223242526272829303132// 普通switchswitch (value) &#123; case 0: return result0; case 1: return result1; case 2: return result2; case 3: return result3; case 4: return result4; case 5: return result5; case 6: return result6; case 7: return result7; case 8: return result8; case 9: return result9; default: return result10;&#125;// 使用查找表技术优化// 将返回值集合存入数组var results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];// 返回当前结果值return results[value]; 调用栈限制 JavaScript 引擎支持的递归数量与 JavaScript 调用栈大小直接相关。只有 IE 例外，它的调用栈与系统空闲内存有关，而其他浏览器都有固定数量的调用栈限制。 使用了太多递归，甚至超过最大调用栈容量时，浏览器会报告一下错误信息： Internet Explorer: “Stack overflow at line x” Firefox: “Too much recursion” Safari: “Maximum call stack exceeded” Opera: “Abort（control stack overflow）” Chrome 是唯一不显示调用栈溢出错误的浏览器 尽管在 JavaScript 中捕获这些错误是有可能的，但并不推荐这样做。那些有潜在问题的调用栈溢出问题的脚本不应该发布上线 递归使用递归可以把复杂的算法变简单。比如阶乘函数：1234567function factorial(n) &#123; if(n == 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 递归的潜在问题是终止条件不明确或缺少终止条件会导致函数长时间运行，并使得用户界面处于假死状态 当遇到调用栈大小限制时，第一步应该先检查代码中的递归实例。为此，有两种递归模式值得注意： 直接递归模式（即函数调用自身） 1234function recurse() &#123; recurse();&#125;recurse(); 隐伏模式（两个或多个函数互相调用） 1234567function first() &#123; second();&#125;function second() &#123; first();&#125;first(); 大多数调用栈错误都这两种模式有关。组常见的导致栈溢出的原因是不正确的终止条件，因此定位模式错误的第一步是验证终止条件。如果终止条件没有问题，那么可能是算法中包含了太多层递归，为了能在浏览器中安全的工作，建议改用 迭代、Memoization，或者结合两者使用。 迭代任何递归能实现的算法同样可以用迭代来实现。迭代算法通常包含以下几个不同的循环，分别对应计算过程的不同方面，这也会引入它们自身的性能问题。然而，使用优化后的循环替代长时间运行的递归函数可以提升性能，因为 运行一个循环比反复调用一个函数的开销要少很多 例如合并排序算法： 使用递归 1234567891011121314151617181920212223242526function merge(left, right) &#123; var result = []; while (left.length &gt; 0 &amp;&amp; right.length &gt;0) &#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; return result.concat(left).concat(right);&#125;function mergeSort(items) &#123; if(items.length == 1) &#123; return items; &#125; var middle = Math.floor(items.length / 2), left = items.slice(0, middle), right = items.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125; 这段代码相当直观，但是 mergeSort() 函数会导致很频繁的自调用。一个长度为 n 的数组最终会调用 mergeSort() 2*n - 1 次，这意味着一个长度超过 1500 的数组会在 Firefox 上发生栈溢出错误。 使用迭代优化 1234567891011121314151617181920212223242526272829303132333435function merge(left, right) &#123; var result = []; while (left.length &gt; 0 &amp;&amp; right.length &gt;0) &#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; return result.concat(left).concat(right);&#125;function mergeSort(items) &#123; if (items.length == 1) &#123; return items; &#125; var work = []; for (var i = 0, len = items.length; i &lt; len; i ++) &#123; work.push([items[i]]); &#125; work.push([]); for (var lim = len; lim &gt; 1; lim = (lim + 1) / 2) &#123; for (var j = 0, k = 0; k &lt; lim; j ++, k += 2) &#123; work[j] = merge(work[k], work[k + 1]); &#125; work[j] = []; // 如果数组长度为奇数 &#125; return work[0];&#125; 这个版本没有使用递归，尽管迭代版本的合并排序算法比递归实现得要慢一些，但它不会像递归版本那样受调用栈限制的影响。把递归算法改用迭代实现是避免栈溢出错误的方法之一。 Memoization减少工作量就是最好的性能优化技术。代码要处理的事越少，它的运行速度就越快。沿着这个思路，避免重复工作也是有意义的。多次执行相同的任务纯粹是浪费时间。Memoization 正是一种避免重复工作方法，它缓存前一个计算结果供后续计算使用，避免了重复工作。这使得它成为递归算法中有用的技术。 普通的阶乘函数 12345678910function factorial(n) &#123; if(n == 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;var fact6 = factorial(6);var fact5 = factorial(5);var fact4 = factorial(4); 这段代码有3次阶乘计算，导致 factorial() 函数一共被调用了 18 次。改代码中最糟糕的部分是，所有必要的计算在第一行代码里已经处理掉了。 使用 Memoization 技术进行重写（保存并重用计算结果，而不是每次都重新计算整个函数） 123456789101112131415161718function memfactorial(n) &#123; if (!memfactorial.cache) &#123; memfactorial.cache = &#123; \"0\": 1, \"1\": 1 &#125; &#125; if (!memfactorial.cache.hasOwnProperty(n)) &#123; memfactorial.cache[n] = n * memfactorial(n - 1); &#125; return memfactorial.cache[n];&#125;var fact6 = memfactorial(6);var fact5 = memfactorial(5);var fact4 = memfactorial(4); 该代码返回了3个不同的阶乘值，但只调用了 memfactorial() 函数 8 次。因为所有必要的计算都在第一行完成并缓存了，所以接下来的梁行代码不会发生地柜运算，而是直接返回缓存中的值了。 更简单的版本 123456789101112131415161718192021222324252627282930/** * 基础功能的 memoize 函数 * @param &#123;*&#125; fundamental 需要增加缓存功能的函数 * @param &#123;*&#125; cache 可选的缓存对象 */function memoize(fundamental, cache) &#123; cache = cache || &#123;&#125;; var shell = function(arg) &#123; if (!cache.hasOwnProperty(arg)) &#123; cache[arg] = fundamental(arg); &#125; return cache[arg]; &#125;; return shell;&#125;function factorial(n) &#123; if(n == 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;var memfactorial = memoize(factorial, &#123;\"0\": 1, \"1\": 1&#125;);var fact6 = memfactorial(6);var fact5 = memfactorial(5);var fact4 = memfactorial(4); 这种通用的 Memoization 与手工更新给定函数的算法先比优化效果要差一些，因为 memoize() 函数会缓存特定参数的函数调用结果。当代码以相同的参数多次调用外壳函数时才能节省时间。因此，当 Memoization 函数存在显著性能问题时，最好有针对性的手工实现它，而不是直接用通用 Memoization 方案。 小结 for、while、和 do-while 循环性能特性相当，并没有一种循环类型明显快于或慢于其他类型 避免使用 for-in 循环，除非你需要遍历一个属性数量未知的对象 改善循环性能的最佳方式是减少每次迭代的运算量和减少循环迭代次数 通常来说，switch 总是比 if-else 快，但并不总是最佳解决方案 在判断条件较多时，使用查找表比 if-else 和 switch 更快 浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用；栈溢出错误会导致其他代码中断执行 如果你遇到栈溢出错误，可将方法改为迭代算法，或使用 Memoization 来避免重复计算 运行的代码数量越大，使用这些策略所带来的性能提升也就越明显。 JavaScript 和其他编程语言一样，代码的写法和算法会影响运行时间。与其他语言不同的是，JavaScript 可用资源有限（由于JavaScript是解释型语言，与编译性语言不同的是，它无需编译，而是将代码以字符串的形式交给 JavaScript 引擎来执行。因此，代码性能在一定程度上取决于客户端浏览器的JavaScript引擎），因此优化技术更为重要。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"}]},{"title":"JavaScript性能优化（三）","date":"2018-12-18T03:19:40.000Z","path":"20181218/js-hack3/","text":"本文是阅读《高性能JavaScript》一书后，从 DOM编程 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 慢的必然性 简单理解，两个相互独立的功能只要通过接口彼此连接，就会产生消耗。 DOM 的修改与访问访问DOM元素是有代价的，修改元素的代价则更为昂贵，因为它会导致浏览器重新计算页面的集合变化 当然，最坏的情况就是在循环中访问或修改元素，尤其是对 HTML 元素集合循环操作 例一 12345function innerHTMLLoop() &#123; for(var count = 0; count &lt; 15000; count ++) &#123; document.getElementById('here').innerHTML += 'a'; &#125;&#125; 例二 1234567function innerHTMLLoop2() &#123; var content = ''; for(var count = 0; count &lt; 15000; count ++) &#123; content += 'a'; &#125; document.getElementById('here').innerHTML += content;&#125; 结果显而易见，例二中的 innerHTMLLoop2 运行得更快 得出结论，访问DOM的次数越多，代码运行得速度越慢，因此，通用的经验法则是：减少访问 DOM 的次数，把运算尽量留在ECMAScript 这一端处理 innerHTML 对比 DOM 方法 在旧版本浏览器中 innerHTML 的优势明显，在新版本的浏览器中两种方式相差无几 节点克隆 使用 element.cloneNode() 替代 document。createElemnt()，运行效率会稍快一点，但是差距不大 HTML 集合 HTML 集合以一种“假定实时态”实时存在，这意味着当底层文档对象更新时，它也会自动更新123456789101112131415161718// 一个意外的死循环var alldivs = document.getElementsByTagName('div');for(var i = 0; i &lt; alldivs.length; i ++) &#123; document.body.appendChild(document.createElement('div));&#125;/** * 结局方案 * 将 HTML 集合拷贝到普通数组，再进行操作 */function toArray(coll) &#123; for(var i = 0, a = []; i &lt; coll.length; i ++) &#123; a[i] = coll[i]; &#125; return a;&#125;var coll = document.getElementsByTagName('div');var ar = toArray(coll); 昂贵的集合优化方案： 相同的内容和数量下，便利一个数组的速度明显快于便利一个 HTML 集合 循环时缓存数组长度 遍历 DOM获取 DOM 元素 在不同浏览器中，elemnt.nextSibling 和 parentEle.childNode 运行时间相差无几 但是在 IE6 中，nextSibling 快16倍 在 IE7 中，nextSibling 快 105 倍 因此得出结论，在老版本的 IE 中，推荐使用 nextSibling 来查找DOM 节点，其他情况取决于个人或团队偏好 元素节点 在所有浏览器中，children 都比 childNodes 要快，因为集合项更少 选择器 API 如果需要处理大量组合查询，推荐使用 querySelectorAll() 还有一个新的选择器API，querySelector()，可以获取第一个匹配到的节点 重绘与重排 概念： 当DOM的变化影响了元素的几何属性（宽和高）——比如改变边框宽度或给段落增加文字，导致行数增加——浏览器需要重新计算元素的几何数形，同样其他元素的几何属性也会因此受到影响。浏览器回事渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为“重排”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为“重绘”。 并不是所有的 DOM 变化都会影响几何属性，例如，改变一个元素的背景色并不会影响它的宽和高。这种情况下，只会发生一次重绘（不需要重排） 重排何时发生 添加或删除可见的 DOM 元素 元素位置改变 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变） 内容改变，例如：文本改变或图片被另一个不同尺寸的图片替代 页面渲染器初始化 浏览器窗口尺寸改变 滚动条出现时 渲染树变化的排队与刷新 由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重拍过程，然而，你可能会（经常不知不觉）强制刷新队列要求计划任务立即执行。获取布局信息的操作会导致队列刷新。例如一下方法: offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle() （currentStyle in IE） 以上属性和方法需要最新的布局信息，因此浏览器不得不执行渲染队列的“待处理变化”并触发重排以返回正确的值。 因此，在修改样式的过程中，最好避免出现上面列出的属性。它们都会刷新渲染队列，即使你是在获取最近未发生改变的或者与最新改变无关的布局信息 最小化重绘与重排 如上所述，通过延迟访问布局信息来避免“重排” 改变样式 合并所有的改变然后依次处理 12345678var el = document.getElementById('box');el.style.borderLeft = '1px';el.style.borderRight = '2px';el.style.padding = '5px';// 上面可能会导致浏览器触发三次重排// 改写成下面的方式就会更高效var el = document.getElementById('box');el.style.cssText = 'border-left: 1px; border-right: 1px; padding: 5px;' 另一个一次性修改样式的方法是修改CSS的class名称，而不是修改内联样式。适用于那些不依赖运行逻辑和计算的情况 12var el = document.getElementById('box');el.className = 'active' 批量修改 DOM可以使用以下步骤进行优化： 使元素脱离文档流 对其应用多重改变 把元素带回文档中 使 DOM 脱离文档的三种基本方法： 前情提要12345678910111213141516171819202122232425262728293031323334&lt;!-- 如下元素 --&gt;&lt;ul id=\"myList\"&gt; &lt;li&gt;&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.google.com\"&gt;谷歌&lt;/a&gt;&lt;/li&gt;&lt;ul&gt;&lt;script&gt; var data = [ &#123; \"name\": \"Jack\", \"url\": \"https://www.redux.org.cn\" &#125;, &#123; \"name\": \"Ross\", \"url\": \"https://github.com\" &#125; ] // 通用函数 function appendDataToElement(appendToElement, data) &#123; var a, li; for (var i = 0, max = data.length; i &lt; max; i ++) &#123; a = document.createElement('a'); a.href = data[i].url; a.appendChild(document.createTextNode(data[i].name)); li = document.createElement('li'); li.appendChild(a); appendToElement.appendChild(li); &#125; &#125; // 最普通的更新列表方式 var ul = document.getElementById('myList'); appendDataToElement(ul, data);&lt;/script&gt; 隐藏元素，应用修改，重新显示 12345// 修改之后的更新方式var ul = document.getElementById('myList');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档 12345// 修改之后的更新方式var ul = document.getElementById('myList');var fragment = document.creatDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素 12345// 修改之后的更新方式var ul = document.getElementById('myList');var clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 缓存布局信息 正如开始所说的，尽量减少获取布局信息的获取次数 应用场景：获取偏移量、滚动位置、计算出的样式值 例子： 1234567891011121314151617181920// 移动元素到一定位置后停止动画// 低效的myElement.style.left = 1 + myElement.offsetLeft + 'px';myElement.style.top = 1 + myElement.offsetTop + 'px';if (myElement.offsetLeft &gt;= 500) &#123; stopAnimation();&#125;// 改写之后：// 先将 myElement.offsetLeft 缓存给局部变量 currentvar current = myElement.offsetLeft;....// 循环体中current ++;myElement.style.left = current + 'px';myElement.style.top = current + 'px';if (current &gt;= 500) &#123; stopAnimation();&#125; 让元素脱离动画流 步骤 使用绝对位置定位页面上的动画元素，将其脱离文档流 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容 当动画结束时恢复定位，从而只会下移一次文档的其他元素 hover 伪类 如果你有大量元素使用了 :hover，那么会降低响应速度。此问题在 IE8 中更为明显 因此在元素很多时应避免使用这种效果，比如很大的表格或很长的列表 事件委托当页面中存在大量元素，且每一个都要一次或多次绑定事件处理器时，这种情况可能会影响性能。每绑定一个事件处理器都是有代价的，它要么是加重了页面负担（更多的标签或JavaScript代码），要么是增加了运行期的执行时间。 因此，一个简单而优雅的处理 DOM 事件的技术是事件委托。它基于这样一个原理：事件逐层冒泡并能被父级元素捕获 实例代码 1234567891011121314151617181920212223242526272829303132333435/** * 场景： &lt;div&gt;&lt;ul id=\"menu\"&gt;&lt;li&gt;&lt;a href=\"http://www.github.com\"&gt;menu #1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; * 用户点击链接 “menu #1”，点击事件首先由&lt;a&gt;元素收到，然后向 DOM 树上层冒泡，被&lt;li&gt;元素接受，接着是&lt;ul&gt;，然后是&lt;div&gt;。 * 以此类推，一直到达document 的顶层乃至 window。这使得你可以添加一个事件处理器到父级元素，由它接受所有子节点的事件消息 * */document.getElementById('menu').onclick = function(e) &#123; // 浏览器 target e = e || window.event; var target = e.target || e.srcElement; var pageid, hrefparts; // 只关心hrefs， 非链接点击则退出 if (target.nodeName !== 'A') &#123; return; &#125; // 从链接中找出页面 ID hrefparts = target.href.split('/'); pageid = hrefparts[hrefparts.length - 1]; pageid = pageid.replace('.html', ''); // 更新页面 ajaxReauest('xhr.php?page=' + id, updatePageContents); // 浏览器阻止默认行为并取消冒泡 if (typeof e.preventDefault === 'function') &#123; e.preventDefault(); e.stopPropagation(); &#125; else &#123; e.returnValue = false; e.cancelBubble = true; &#125;&#125; 跨浏览器兼容性的部分（可封装到可重用的类库） 访问事件对象，并判断事件源 取消文档树中的冒泡（可选） 阻止默认动作（可选，但本例需要，因为需要捕获并阻止打开链接） 小结访问和操作 DOM 是现代 Web 应用的重要部分。范每次穿越连接 ECMAScript 和 DOM 两个岛屿之间的前两，都会被收取“过桥费”。为了减少 DOM 编程带来的性能损失，请记住以下几点： 最小化 DOM 访问次数，尽可能在 JavaScript 端处理 如果需要多次访问某个 DOM 节点，请使用局部变量存储它的引用 小心处理 HTML 集合，因为它实时连系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用。如果需要经常操作集合，建议把它拷贝到一个数组中 如果可能的话，使用速度更快的 API，比如 querySelectorAll()和 firstElementChild 要留意重绘和重排；批量修改样式时，“离线”操作 DOM 树，使用缓存，并减少访问布局信息的次数 动画中使用绝对定位，使用拖放代理 使用事件委托来减少事件处理器的数量","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"DOM","slug":"DOM","permalink":"https://beichensky.github.io/tags/DOM/"}]},{"title":"JavaScript性能优化（二）","date":"2018-12-17T08:14:33.000Z","path":"20181217/js-hack2/","text":"本文是阅读《高性能JavaScript》一书后，从 数据存取 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 作用域和标识符解析每个js函数都表示一个对象，是Function对象的一个实例，拥有可以变成访问的属性和一系列不能通过代码访问而仅供JS引擎存取的内部属性，其中一个属性就是[[Scope]] 内部属性[[Scope]]包含了一个函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链。这个全局对象代表着所有在全局范围内定义的变量。包含诸如window，navigation和document等。 执行函数时会创建一个称为执行环境的内部对象。一个执行环境定义了一个函数执行时的环境。函数每次执行时对应的执行环境都是独一无二的，所以多次调用同一个函数就会导致创建多个执行环境。当函数执行完毕，执行环境就被销毁。 每个执行环境都有自己的作用域链，用于解析标识符。当执行环境被创建时，它的作用域链初始化为当前运行函数的[[Scope]]属性中的对象。这些值按照它们出现在函数中的顺序被复制到执行环境的作用域链中。这个过程一旦完成，一个被称为“活动对象”的新对象就为执行环境创建好了。活动对象作为函数运行时的变量对象，包含所有局部变量，命名参数，参数集合以及this。然后此对象被推入作用域链的最前端。当执行环境被销毁，活动对象也随之销毁 标识符解析的性能标识符解析是有代价的，在执行环境的作用域链中，一个标识符所在的位置越深，它的读写速度也就越慢，因此，函数中读写局部变量总是最快的，而读写全局变量通常是最慢的。全局变量总是存在于执行环境作用域链的最末端，因此它也是最远的。 改变作用域链 改变作用域链会导致访问对应对象的作用域时很快，但访问局部变量却变慢了 避免使用with 尽量在catch中将错误委托给一个函数来处理 在确实有必要时才推荐使用动态作用域 闭包、作用域和内存 闭包有可能会导致内存泄漏 对象成员 访问对象成员的速度比访问字面量和变量要慢，在某些浏览器中比访问数组元素还要慢 原型链 对象在原型链中存在的位置越深，存取速度也就越慢 嵌套成员 对象成员嵌套的越深，读取速度就会越慢 缓存对象成员 在同一个函数或作用域下没必要多次读取同一个对象成员，可以在第一个读取时将对象成员缓存到局部变量中 小结 访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢 由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用于变量更快。变量在作用域链中的位置越深，访问所需的时间越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的 避免使用with语句，因为它会改变执行环境作用域链。同样，try-catch与剧中的catch也有同样的影响，因此也要小心使用 嵌套的对象成员会明显影响性能，尽量少用 属性或方法在原型链中的位置越深，访问它的速度也越慢 通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"JS","slug":"JS","permalink":"https://beichensky.github.io/tags/JS/"}]},{"title":"JavaScript性能优化（一）","date":"2018-12-16T13:31:22.000Z","path":"20181216/js-hack1/","text":"本文是阅读《高性能JavaScript》一书后，从 加载和执行 模块对JavaScript性能优化做了部分总结，记录一下。可能总结的不好，不是很完整，也希望各位大佬能多给出一些建议。万分感谢！ 多数浏览器使用单一进城来处理用户界面（UI）刷新和JavaScript脚本执行，所以同一时刻只能做一件事。JavaScript执行过程耗时越久，浏览器等待相应的时间就越长。简单说，这意味着&lt;script&gt;标签每次出现都霸道地让页面等待脚本的解析和执行，无论当前的JavaScript代码是内嵌还是包含在外链文件中，页面的下载和选人都必须听下来等待脚本执行完成。 脚本位置 将所有的&lt;script&gt;标签尽可能的放到&lt;body&gt;标签的底部（雅虎特别性能小组提出的优化JavaScript的首要规则） 组织脚本 浏览器在解析HTML页面的过程中每遇到一个&lt;script&gt;，都会因执行脚本而导致一定的演示，因此最小化延时时间会名校改善页面的总体性能 建议永远不要把内嵌脚本紧跟在&lt;link&gt;标签后面，因为将一段内嵌脚本放在引用外联样式表的&lt;link&gt;标签之后会导致页面阻塞去等待样式表的下载。这么做是为了确保内嵌脚本在执行时能获得最精准的样式信息 减少页面中外链脚本的数量，将多个文件合并成一个 无阻塞的脚本意味着页面加载完成之后才加载JavaScript代码 给&lt;script&gt;标签添加 async 属性，则资源下载完成自动执行 延迟的脚本 给&lt;script&gt;标签添加 async 属性，则资源下载完成也必须等到页面加载完成后执行 PS：async和defer的共同点和区别：共同点：采用并行下载，在下载过程中不会产生阻塞区别：执行时机不同，async是加载完成后自动执行，而defer需要等待页面完成后执行注意： 使用defer和async时最好先查阅当前浏览器是否支持该属性 动态脚本元素使用动态代码操作DOM创建&lt;script&gt;元素，这种技术的重点在于：无论何时启动下载，文件的下载和执行过程不会阻塞页面其他进行。设置可以将代码放在&lt;head&gt;区域而不会影响页面其他部分 注意点 创建的&lt;script&gt;标签添加到&lt;head&gt;标签里比添加到&lt;body&gt;里更保险 因为当&lt;body&gt;中的内容没有全部加载完成时，IE可能会抛出一个“操作已终止”的错误信息 当脚本“自执行”时，这种机制运行正常。但是当代码只包含供页面其他接口调用的接口时，就会有问题 在这种情况下，必须跟踪并确保脚本下载完成并准备就绪 实现代码 12345678910111213141516171819function loadScript(url, callback) &#123; var script = document.createElement('script); script.type = \"text/script\"; if (script.readyState) &#123; // IE script.onreadystatechange = function() &#123; if (script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; // 确保事件不会处理两次 script.onreadystatechange = null; callback(); &#125; &#125; &#125; else &#123; // 其他浏览器 script.onload = function() &#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125; 调用方法 1234567loadScript(\"file1.js\", function() &#123; loadScript(\"file2.js\", function() &#123; loadScript(\"file2.js\", function() &#123; alert(\"所以文件加载完成\"); &#125;) &#125;)&#125;) XMLHTTPRequest脚本注入 此技术会先创建一个XHR对象，然后用它下载JavaScript文件，最后通过动态&lt;script&gt;元素将代码注入到页面中 123456789101112var xhr = new XMLHttpRequest();xhr.open(\"get\", \"file1.js\", true);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.statue &lt; 300 || xhr.status == 304) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125;&#125; 优点：可以下载JavaScript代码但不立即执行，由于代码实在标签之外返回的，因此下载后不会自动执行，可以将脚本的执行推迟到页面准备好的时候 局限性：JavaScript代码必须与所请求的页面处于相同的域，这意味着JavaScript文件不能从CDN下载 推荐的无阻塞模式向页面中添加大量JavaScript的推荐方式只需两步：先动态加载所需的代码，然后加载初始化页面所需的剩下的代码。第一部分的代码尽量精简 第一种做法 123456&lt;script type=\"text/javascript\" src=\"loader.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; loadScript(\"the-rest.js\", function() &#123; Application.init(); &#125;)&lt;/script&gt; 第二种做法 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; function loadScript(url, callback) &#123; var script = document.createElement('script); script.type = \"text/script\"; if (script.readyState) &#123; // IE script.onreadystatechange = function() &#123; if (script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; // 确保事件不会处理两次 script.onreadystatechange = null; callback(); &#125; &#125; &#125; else &#123; // 其他浏览器 script.onload = function() &#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script); &#125; loadScript(\"the-rest.js\", function() &#123; Application.init(); &#125;)&lt;/script&gt; 第二种做法可以比多产生一次HTTP请求，但是建议使用YUI Compressor 把初始化代码压缩到最小尺寸 YUI3 的方式 YUI3核心设计理念：由页面中的少量代码来加载丰富的功能组件 使用 12345678&lt;script type=\"text/javascript\" src=\"http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // dom实际上拼装出一个带有所有依赖文件组合的URL // Y，当前YUI实例 YUI.use(\"dom\", function(Y) &#123; Y.DOM.addClass(document.body, \"loaded\") &#125;)&lt;/script&gt; LazyLoad 类库 使用1234567&lt;!-- LazyLoader 源代码：http://github.com/rgrove/lazyload --&gt;&lt;script type=\"text/javascript\" src=\"lazyload-min.js\"&gt;&lt;/script&gt;&lt;script&gt; LazyLoad.js([\"first-file.js\", \"the-rest.js\"], function() &#123; Application.init() &#125;)&lt;/script&gt; LABjs 使用1234567891011&lt;!-- LABjs源代码：http://labjs.com --&gt;&lt;!-- 虽然是同归.script链式调用，其实也是并行下载 --&gt;&lt;script type=\"text/javascript\" src=\"lab.js\"&gt;&lt;/script&gt;&lt;script&gt; // wait 意味着加载好前面的javascript资源才会继续向下加载 $LAB.script(\"first-file.js\").wait() .script(\"the-rest.js\") .wait(function () &#123; Appication.init(); &#125;)&lt;/script&gt; 小结减少JavaScript对性能的影响的方式： &lt;/body&gt;闭合标签之前，将所有的&lt;script&gt;放到页面底部。这能确保在脚本执行前页面已经完成了渲染 合并脚本。页面中的&lt;script&gt;标签越少，加载也就越快，响应也更迅速，无论外链文件还是内嵌脚本都是如此 有多种无阻塞下载JavaScript的方法： 使用&lt;script&gt;标签的defer属性 使用动态创建的&lt;script&gt;元素来下载并执行代码 使用XHR对象下载JavaScript代码并注入到页面中","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://beichensky.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://beichensky.github.io/tags/性能优化/"},{"name":"script","slug":"script","permalink":"https://beichensky.github.io/tags/script/"}]},{"title":"Hello World","date":"2018-12-13T16:14:09.000Z","path":"20181214/hello-world/","text":"Hexo基本命令 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://beichensky.github.io/tags/Hexo/"},{"name":"md","slug":"md","permalink":"https://beichensky.github.io/tags/md/"}]}]